import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as i,o as e}from"./app-6Bz2fGO5.js";const p={};function l(r,a){return e(),s("div",null,a[0]||(a[0]=[i(`<p><audio id="audio" title="JavaScript对象：你知道全部的对象分类吗？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/e6/a1/e6da746ef307617e41b7744d4564dea1.mp3"></audio></p><p>你好，我是winter。</p><p>在前面的课程中，我已经讲解了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。</p><p>比如说，我们不论怎样编写代码，都没法绕开Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的length属性。</p><p>并且，在浏览器环境中，我们也无法单纯依靠JavaScript代码实现div对象，只能靠document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。</p><p>我们日常工作中，接触到的主要API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的API的一些特性。</p><h2 id="javascript中的对象分类" tabindex="-1"><a class="header-anchor" href="#javascript中的对象分类"><span>JavaScript中的对象分类</span></a></h2><p>我们可以把对象分成几类。</p><ul><li>宿主对象（host Objects）：由JavaScript宿主环境提供的对象，它们的行为完全由宿主环境决定。</li><li>内置对象（Built-in Objects）：由JavaScript语言提供的对象。</li><li>固有对象（Intrinsic Objects ）：由标准规定，随着JavaScript运行时创建而自动创建的对象实例。</li><li>原生对象（Native Objects）：可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。</li><li>普通对象（Ordinary Objects）：由{}语法、Object构造器或者class关键字定义类创建的对象，它能够被原型继承。</li></ul><p>下面我会为你一一讲解普通对象之外的对象类型。</p><h3 id="宿主对象" tabindex="-1"><a class="header-anchor" href="#宿主对象"><span>宿主对象</span></a></h3><p>首先我们来看看宿主对象。</p><p>JavaScript宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。</p><p>在浏览器环境中，我们都知道全局对象是window，window上又有很多属性，如document。</p><p>实际上，这个全局对象window上的属性，一部分来自JavaScript语言，一部分来自浏览器环境。</p><p>JavaScript标准中规定了全局对象属性，W3C的各种标准中规定了Window对象的其它属性。</p><p>宿主对象也分为固有的和用户可创建的两种，比如document.createElement就可以创建一些DOM对象。</p><p>宿主也会提供一些构造器，比如我们可以使用new Image来创建img元素，这些我们会在浏览器的API部分详细讲解。</p><h2 id="内置对象·固有对象" tabindex="-1"><a class="header-anchor" href="#内置对象·固有对象"><span>内置对象·固有对象</span></a></h2><p>我们在前面说过，固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例。</p><p>固有对象在任何JavaScript代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。</p><p>ECMA标准为我们提供了一份固有对象表，里面含有150+个固有对象。你可以通过<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects" target="_blank" rel="noopener noreferrer">这个链接</a>查看。</p><p>但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部JavaScript固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。</p><h2 id="内置对象·原生对象" tabindex="-1"><a class="header-anchor" href="#内置对象·原生对象"><span>内置对象·原生对象</span></a></h2><p>我们把JavaScript中，能够通过语言本身的构造器创建的对象称作原生对象。在JavaScript标准中，提供了30多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。</p><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" alt=""><p>通过这些构造器，我们可以用new运算创建新的对象，所以我们把这些对象称作原生对象。<br><br> 几乎所有这些构造器的能力都是无法用纯JavaScript代码实现的，它们也无法用class/extend语法来继承。</p><p>这些构造器创建的对象多数使用了私有字段,例如：</p><ul><li>Error: [[ErrorData]]</li><li>Boolean: [[BooleanData]]</li><li>Number: [[NumberData]]</li><li>Date: [[DateValue]]</li><li>RegExp: [[RegExpMatcher]]</li><li>Symbol: [[SymbolData]]</li><li>Map: [[MapData]]</li></ul><p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</p><h2 id="用对象来模拟函数与构造器-函数对象与构造器对象" tabindex="-1"><a class="header-anchor" href="#用对象来模拟函数与构造器-函数对象与构造器对象"><span>用对象来模拟函数与构造器：函数对象与构造器对象</span></a></h2><p>我在前面介绍了对象的一般分类，在JavaScript中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。</p><p>事实上，JavaScript为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。</p><p>函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。</p><p>JavaScript用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有[[call]]私有字段的对象”，就可以被 JavaScript 函数调用语法支持。</p><blockquote></blockquote><p>[[call]]私有字段必须是一个引擎中定义的函数，需要接受this值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。</p><p>我们可以这样说，任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p><p>对于为JavaScript提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如Symbol函数）可以模拟函数和构造器。</p><p>当然了，用户用function关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。</p><p>对于宿主和内置对象来说，它们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    console.log(new Date); // 1</span></span>
<span class="line"><span>    console.log(Date())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>而浏览器宿主环境中，提供的Image构造器，则根本不允许被作为函数调用。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>console.log(new Image); </span></span>
<span class="line"><span>console.log(Image());//抛出错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。</p><p>值得一提的是，在ES6之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    new (a =&amp;gt; 0) // error</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于用户使用 function 语法或者Function构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。</p><p>我们看一下示例。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function f(){</span></span>
<span class="line"><span>    return 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var v = f(); //把f作为函数调用</span></span>
<span class="line"><span>var o = new f(); //把f作为构造器调用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们大致可以认为，它们[[construct]]的执行过程如下：</p><ul><li>以 Object.prototype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的[[call]]；</li><li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li></ul><p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么new创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function cls(){</span></span>
<span class="line"><span>    this.a = 100;</span></span>
<span class="line"><span>    return {</span></span>
<span class="line"><span>        getValue:() =&amp;gt; this.a</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var o = new cls;</span></span>
<span class="line"><span>o.getValue(); //100</span></span>
<span class="line"><span>//a在外面永远无法访问到</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="特殊行为的对象" tabindex="-1"><a class="header-anchor" href="#特殊行为的对象"><span>特殊行为的对象</span></a></h2><p>除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。</p><ul><li>Array：Array的length属性根据最大的下标自动发生变化。</li><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li>String：为了支持下标运算，String的正整数属性访问会去字符串里查找。</li><li>Arguments：arguments的非负整数型下标属性跟对应的变量联动。</li><li>模块的namespace对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于import吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li>bind后的function：跟原来的函数相关联。</li></ul><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了JavaScript中用对象来模拟函数和构造器的机制。</p><p>这是一些不那么有规律、不那么优雅的知识，而JavaScript正是通过这些对象，提供了很多基础的能力。</p><p>我们这次课程留一个挑战任务：不使用new运算符，尽可能找到获得对象的方法。</p><p>例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var o = {}</span></span>
<span class="line"><span>var o = function(){}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>请把自己的答案留言给我，我们来比比看谁找到的多。</p><h2 id="小实验-获取全部javascript固有对象" tabindex="-1"><a class="header-anchor" href="#小实验-获取全部javascript固有对象"><span>小实验：获取全部JavaScript固有对象</span></a></h2><p>我们从JavaScript标准中可以找到全部的JavaScript对象定义。JavaScript语言规定了全局对象的属性。</p><p>三个值：</p><p>Infinity、NaN、undefined。</p><p>九个函数：</p><ul><li>eval</li><li>isFinite</li><li>isNaN</li><li>parseFloat</li><li>parseInt</li><li>decodeURI</li><li>decodeURIComponent</li><li>encodeURI</li><li>encodeURIComponent</li></ul><p>一些构造器：<br><br> Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeakSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。</p><p>四个用于当作命名空间的对象：</p><ul><li>Atomics</li><li>JSON</li><li>Math</li><li>Reflect</li></ul><p>我们使用广度优先搜索，查找这些对象所有的属性和Getter/Setter，就可以获得JavaScript中所有的固有对象。</p><p>请你试着先不看我的代码，在自己的浏览器中计算出来JavaScript有多少固有对象。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var set = new Set();</span></span>
<span class="line"><span>var objects = [</span></span>
<span class="line"><span>    eval,</span></span>
<span class="line"><span>    isFinite,</span></span>
<span class="line"><span>    isNaN,</span></span>
<span class="line"><span>    parseFloat,</span></span>
<span class="line"><span>    parseInt,</span></span>
<span class="line"><span>    decodeURI,</span></span>
<span class="line"><span>    decodeURIComponent,</span></span>
<span class="line"><span>    encodeURI,</span></span>
<span class="line"><span>    encodeURIComponent,</span></span>
<span class="line"><span>    Array,</span></span>
<span class="line"><span>    Date,</span></span>
<span class="line"><span>    RegExp,</span></span>
<span class="line"><span>    Promise,</span></span>
<span class="line"><span>    Proxy,</span></span>
<span class="line"><span>    Map,</span></span>
<span class="line"><span>    WeakMap,</span></span>
<span class="line"><span>    Set,</span></span>
<span class="line"><span>    WeakSet,</span></span>
<span class="line"><span>    Function,</span></span>
<span class="line"><span>    Boolean,</span></span>
<span class="line"><span>    String,</span></span>
<span class="line"><span>    Number,</span></span>
<span class="line"><span>    Symbol,</span></span>
<span class="line"><span>    Object,</span></span>
<span class="line"><span>    Error,</span></span>
<span class="line"><span>    EvalError,</span></span>
<span class="line"><span>    RangeError,</span></span>
<span class="line"><span>    ReferenceError,</span></span>
<span class="line"><span>    SyntaxError,</span></span>
<span class="line"><span>    TypeError,</span></span>
<span class="line"><span>    URIError,</span></span>
<span class="line"><span>    ArrayBuffer,</span></span>
<span class="line"><span>    SharedArrayBuffer,</span></span>
<span class="line"><span>    DataView,</span></span>
<span class="line"><span>    Float32Array,</span></span>
<span class="line"><span>    Float64Array,</span></span>
<span class="line"><span>    Int8Array,</span></span>
<span class="line"><span>    Int16Array,</span></span>
<span class="line"><span>    Int32Array,</span></span>
<span class="line"><span>    Uint8Array,</span></span>
<span class="line"><span>    Uint16Array,</span></span>
<span class="line"><span>    Uint32Array,</span></span>
<span class="line"><span>    Uint8ClampedArray,</span></span>
<span class="line"><span>    Atomics,</span></span>
<span class="line"><span>    JSON,</span></span>
<span class="line"><span>    Math,</span></span>
<span class="line"><span>    Reflect];</span></span>
<span class="line"><span>objects.forEach(o =&amp;gt; set.add(o));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(var i = 0; i &amp;lt; objects.length; i++) {</span></span>
<span class="line"><span>    var o = objects[i]</span></span>
<span class="line"><span>    for(var p of Object.getOwnPropertyNames(o)) {</span></span>
<span class="line"><span>        var d = Object.getOwnPropertyDescriptor(o, p)</span></span>
<span class="line"><span>        if( (d.value !== null &amp;amp;&amp;amp; typeof d.value === &amp;quot;object&amp;quot;) || (typeof d.value === &amp;quot;function&amp;quot;))</span></span>
<span class="line"><span>            if(!set.has(d.value))</span></span>
<span class="line"><span>                set.add(d.value), objects.push(d.value);</span></span>
<span class="line"><span>        if( d.get )</span></span>
<span class="line"><span>            if(!set.has(d.get))</span></span>
<span class="line"><span>                set.add(d.get), objects.push(d.get);</span></span>
<span class="line"><span>        if( d.set )</span></span>
<span class="line"><span>            if(!set.has(d.set))</span></span>
<span class="line"><span>                set.add(d.set), objects.push(d.set);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,77)]))}const d=n(p,[["render",l]]),o=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%85%A8%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是winter。 在前面的课程中，我已经讲解了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。 比如说，我们不论怎样编写代码，都没法绕开Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的length属性。 并且，在浏览...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%85%A8%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是winter。 在前面的课程中，我已经讲解了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。 比如说，我们不论怎样编写代码，都没法绕开Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的length属性。 并且，在浏览..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":9.07,"words":2721},"filePathRelative":"posts/重学前端/模块一：JavaScript/JavaScript对象：你知道全部的对象分类吗？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"JavaScript对象：你知道全部的对象分类吗？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/e6/a1/e6da746ef307617e41b7744d4564dea1.mp3\\"></audio></p>\\n<p>你好，我是winter。</p>\\n<p>在前面的课程中，我已经讲解了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。</p>","autoDesc":true}');export{d as comp,o as data};

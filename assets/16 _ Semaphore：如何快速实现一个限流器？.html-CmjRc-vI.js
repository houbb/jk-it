import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as l,b as s,d as a,e as r,w as d,r as t,o as c}from"./app-CrA-f6So.js";const o={};function m(u,n){const e=t("t");return c(),p("div",null,[n[2]||(n[2]=l(`<h1 id="_16-semaphore-如何快速实现一个限流器" tabindex="-1"><a class="header-anchor" href="#_16-semaphore-如何快速实现一个限流器"><span>16 _ Semaphore：如何快速实现一个限流器？</span></a></h1><p><audio id="audio" title="16 | Semaphore：如何快速实现一个限流器？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/55/65/559dfe29a26ff9351fcd69e127609265.mp3"></audio></p><p>Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。</p><p>信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于1965年提出，在这之后的15年，信号量一直都是并发编程领域的终结者，直到1980年管程被提出来，我们才有了第二选择。目前几乎所有支持并发编程的语言都支持信号量机制，所以学好信号量还是很有必要的。</p><p>下面我们首先介绍信号量模型，之后介绍如何使用信号量，最后我们再用信号量来实现一个限流器。</p><h2 id="信号量模型" tabindex="-1"><a class="header-anchor" href="#信号量模型"><span>信号量模型</span></a></h2><p>信号量模型还是很简单的，可以简单概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down()和up()。你可以结合下图来形象化地理解。</p><img src="https://static001.geekbang.org/resource/image/6d/5c/6dfeeb9180ff3e038478f2a7dccc9b5c.png" alt=""><p>这三个方法详细的语义具体如下所示。</p><ul><li>init()：设置计数器的初始值。</li><li>down()：计数器的值减1；如果此时计数器的值小于0，则当前线程将被阻塞，否则当前线程可以继续执行。</li><li>up()：计数器的值加1；如果此时计数器的值小于或者等于0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。</li></ul><p>这里提到的init()、down()和up()三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。在Java SDK里面，信号量模型是由java.util.concurrent.Semaphore实现的，Semaphore这个类能够保证这三个方法都是原子操作。</p><p>如果你觉得上面的描述有点绕的话，可以参考下面这个代码化的信号量模型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Semaphore{</span></span>
<span class="line"><span>  // 计数器</span></span>
<span class="line"><span>  int count;</span></span>
<span class="line"><span>  // 等待队列</span></span>
<span class="line"><span>  Queue queue;</span></span>
<span class="line"><span>  // 初始化操作</span></span>
<span class="line"><span>  Semaphore(int c){</span></span>
<span class="line"><span>    this.count=c;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // </span></span>
<span class="line"><span>  void down(){</span></span>
<span class="line"><span>    this.count--;</span></span>
<span class="line"><span>    if(this.count&amp;lt;0){</span></span>
<span class="line"><span>      //将当前线程插入等待队列</span></span>
<span class="line"><span>      //阻塞当前线程</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  void up(){</span></span>
<span class="line"><span>    this.count++;</span></span>
<span class="line"><span>    if(this.count&amp;lt;=0) {</span></span>
<span class="line"><span>      //移除等待队列中的某个线程T</span></span>
<span class="line"><span>      //唤醒线程T</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里再插一句，信号量模型里面，down()、up()这两个操作历史上最早称为P操作和V操作，所以信号量模型也被称为PV原语。另外，还有些人喜欢用semWait()和semSignal()来称呼它们，虽然叫法不同，但是语义都是相同的。在Java SDK并发包里，down()和up()对应的则是acquire()和release()。</p><h2 id="如何使用信号量" tabindex="-1"><a class="header-anchor" href="#如何使用信号量"><span>如何使用信号量</span></a></h2><p>通过上文，你应该会发现信号量的模型还是很简单的，那具体该如何使用呢？其实你想想红绿灯就可以了。十字路口的红绿灯可以控制交通，得益于它的一个关键规则：车辆在通过路口前必须先检查是否是绿灯，只有绿灯才能通行。这个规则和我们前面提到的锁规则是不是很类似？</p><p>其实，信号量的使用也是类似的。这里我们还是用累加器的例子来说明信号量的使用吧。在累加器的例子里面，count+=1操作是个临界区，只允许一个线程执行，也就是说要保证互斥。那这种情况用信号量怎么控制呢？</p><p>其实很简单，就像我们用互斥锁一样，只需要在进入临界区之前执行一下down()操作，退出临界区之前执行一下up()操作就可以了。下面是Java代码的示例，acquire()就是信号量里的down()操作，release()就是信号量里的up()操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>static int count;</span></span>
<span class="line"><span>//初始化信号量</span></span>
<span class="line"><span>static final Semaphore s </span></span>
<span class="line"><span>    = new Semaphore(1);</span></span>
<span class="line"><span>//用信号量保证互斥    </span></span>
<span class="line"><span>static void addOne() {</span></span>
<span class="line"><span>  s.acquire();</span></span>
<span class="line"><span>  try {</span></span>
<span class="line"><span>    count+=1;</span></span>
<span class="line"><span>  } finally {</span></span>
<span class="line"><span>    s.release();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们再来分析一下，信号量是如何保证互斥的。假设两个线程T1和T2同时访问addOne()方法，当它们同时调用acquire()的时候，由于acquire()是一个原子操作，所以只能有一个线程（假设T1）把信号量里的计数器减为0，另外一个线程（T2）则是将计数器减为-1。对于线程T1，信号量里面的计数器的值是0，大于等于0，所以线程T1会继续执行；对于线程T2，信号量里面的计数器的值是-1，小于0，按照信号量模型里对down()操作的描述，线程T2将被阻塞。所以此时只有线程T1会进入临界区执行<code>count+=1；</code>。</p><p>当线程T1执行release()操作，也就是up()操作的时候，信号量里计数器的值是-1，加1之后的值是0，小于等于0，按照信号量模型里对up()操作的描述，此时等待队列中的T2将会被唤醒。于是T2在T1执行完临界区代码之后才获得了进入临界区执行的机会，从而保证了互斥性。</p><h2 id="快速实现一个限流器" tabindex="-1"><a class="header-anchor" href="#快速实现一个限流器"><span>快速实现一个限流器</span></a></h2><p>上面的例子，我们用信号量实现了一个最简单的互斥锁功能。估计你会觉得奇怪，既然有Java SDK里面提供了Lock，为啥还要提供一个Semaphore ？其实实现一个互斥锁，仅仅是 Semaphore的部分功能，Semaphore还有一个功能是Lock不容易实现的，那就是：<strong>Semaphore可以允许多个线程访问一个临界区</strong>。</p><p>现实中还有这种需求？有的。比较常见的需求就是我们工作中遇到的各种池化资源，例如连接池、对象池、线程池等等。其中，你可能最熟悉数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池的，当然，每个连接在被释放前，是不允许其他线程使用的。</p><p>其实前不久，我在工作中也遇到了一个对象池的需求。所谓对象池呢，指的是一次性创建出N个对象，之后所有的线程重复利用这N个对象，当然对象在被释放前，也是不允许其他线程使用的。对象池，可以用List保存实例对象，这个很简单。但关键是限流器的设计，这里的限流，指的是不允许多于N个线程同时进入临界区。那如何快速实现一个这样的限流器呢？这种场景，我立刻就想到了信号量的解决方案。</p><p>信号量的计数器，在上面的例子中，我们设置成了1，这个1表示只允许一个线程进入临界区，但如果我们把计数器的值设置成对象池里对象的个数N，就能完美解决对象池的限流问题了。下面就是对象池的示例代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class ObjPool&amp;lt;T, R&amp;gt; {</span></span>
<span class="line"><span>  final List&amp;lt;T&amp;gt; pool;</span></span>
<span class="line"><span>  // 用信号量实现限流器</span></span>
<span class="line"><span>  final Semaphore sem;</span></span>
<span class="line"><span>  // 构造函数</span></span>
<span class="line"><span>  ObjPool(int size, T t){</span></span>
<span class="line"><span>    pool = new Vector&amp;lt;T&amp;gt;(){};</span></span>
<span class="line"><span>    for(int i=0; i&amp;lt;size; i++){</span></span>
<span class="line"><span>      pool.add(t);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    sem = new Semaphore(size);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // 利用对象池的对象，调用func</span></span>
<span class="line"><span>  R exec(Function&amp;lt;T,R&amp;gt; func) {</span></span>
<span class="line"><span>    T t = null;</span></span>
<span class="line"><span>    sem.acquire();</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      t = pool.remove(0);</span></span>
<span class="line"><span>      return func.apply(t);</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>      pool.add(t);</span></span>
<span class="line"><span>      sem.release();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// 创建对象池</span></span>
<span class="line"><span>ObjPool&amp;lt;Long, String&amp;gt; pool = </span></span>
<span class="line"><span>  new ObjPool&amp;lt;Long, String&amp;gt;(10, 2);</span></span>
<span class="line"><span>// 通过对象池获取t，之后执行  </span></span>
<span class="line"><span>pool.exec(t -&amp;gt; {</span></span>
<span class="line"><span>    System.out.println(t);</span></span>
<span class="line"><span>    return t.toString();</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27)),s("p",null,[n[1]||(n[1]=a("我们用一个List")),r(e,null,{default:d(()=>n[0]||(n[0]=[a("来保存对象实例，用Semaphore实现限流器。关键的代码是ObjPool里面的exec()方法，这个方法里面实现了限流的功能。在这个方法里面，我们首先调用acquire()方法（与之匹配的是在finally里面调用release()方法），假设对象池的大小是10，信号量的计数器初始化为10，那么前10个线程调用acquire()方法，都能继续执行，相当于通过了信号灯，而其他线程则会阻塞在acquire()方法上。对于通过信号灯的线程，我们为每个线程分配了一个对象 t（这个分配工作是通过pool.remove(0)实现的），分配完之后会执行一个回调函数func，而函数的参数正是前面分配的对象 t ；执行完回调函数之后，它们就会释放对象（这个释放工作是通过pool.add(t)实现的），同时调用release()方法来更新信号量的计数器。如果此时信号量里计数器的值小于等于0，那么说明有线程在等待，此时会自动唤醒等待的线程。")])),_:1})]),n[3]||(n[3]=s("p",null,"简言之，使用信号量，我们可以轻松地实现一个限流器，使用起来还是非常简单的。",-1)),n[4]||(n[4]=s("h2",{id:"总结",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#总结"},[s("span",null,"总结")])],-1)),n[5]||(n[5]=s("p",null,"信号量在Java语言里面名气并不算大，但是在其他语言里却是很有知名度的。Java在并发编程领域走的很快，重点支持的还是管程模型。 管程模型理论上解决了信号量模型的一些不足，主要体现在易用性和工程化方面，例如用信号量解决我们曾经提到过的阻塞队列问题，就比管程模型麻烦很多，你如果感兴趣，可以课下了解和尝试一下。",-1)),n[6]||(n[6]=s("h2",{id:"课后思考",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#课后思考"},[s("span",null,"课后思考")])],-1)),n[7]||(n[7]=s("p",null,"在上面对象池的例子中，对象保存在了Vector中，Vector是Java提供的线程安全的容器，如果我们把Vector换成ArrayList，是否可以呢？",-1)),n[8]||(n[8]=s("p",null,"欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。",-1))])}const h=i(o,[["render",m]]),g=JSON.parse('{"path":"/posts/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/16%20_%20Semaphore%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8%EF%BC%9F.html","title":"16 _ Semaphore：如何快速实现一个限流器？","lang":"zh-CN","frontmatter":{"description":"16 _ Semaphore：如何快速实现一个限流器？ Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。 信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于1965年提出，在这之后的15年，信号...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/16%20_%20Semaphore%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"16 _ Semaphore：如何快速实现一个限流器？"}],["meta",{"property":"og:description","content":"16 _ Semaphore：如何快速实现一个限流器？ Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。 信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于1965年提出，在这之后的15年，信号..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"16 _ Semaphore：如何快速实现一个限流器？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":8.64,"words":2591},"filePathRelative":"posts/Java并发编程实战/第二部分：并发工具类/16 _ Semaphore：如何快速实现一个限流器？.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"16 | Semaphore：如何快速实现一个限流器？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/55/65/559dfe29a26ff9351fcd69e127609265.mp3\\"></audio></p>\\n<p>Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。</p>","autoDesc":true}');export{h as comp,g as data};

import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as e}from"./app-6Bz2fGO5.js";const l={};function p(d,s){return e(),n("div",null,s[0]||(s[0]=[i(`<p><audio id="audio" title="24 | 中间代码：兼容不同的语言和硬件" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/9f/09/9f3b7c6de4ad431ce4e85c1119f35e09.mp3"></audio></p><p>前几节课，我带你尝试不通过IR，直接生成汇编代码，这是为了帮你快速破冰，建立直觉。在这个过程中，你也遇到了一些挑战，比如：</p><li> 你要对生成的代码进行优化，才有可能更好地使用寄存器和内存，同时也能减少代码量； </li><li> 另外，针对不同的CPU和操作系统，你需要调整生成汇编代码的逻辑。 </li><p>这些实际体验，都进一步验证了<a href="https://time.geekbang.org/column/article/145472" target="_blank" rel="noopener noreferrer">20讲</a>中，IR的作用：我们能基于IR对接不同语言的前端，也能对接不同的硬件架构，还能做很多的优化。</p><p>既然IR有这些作用，那你可能会问，<strong>IR都是什么样子的呢？有什么特点？如何生成IR呢？</strong></p><p>本节课，我就带你了解IR的特点，认识常见的三地址代码，学会如何把高级语言的代码翻译成IR。然后，我还会特别介绍LLVM的IR，以便后面使用LLVM这个工具。</p><p>首先，来看看IR的特征。</p><h2 id="介于中间的语言" tabindex="-1"><a class="header-anchor" href="#介于中间的语言"><span>介于中间的语言</span></a></h2><p>IR的意思是中间表达方式，它在高级语言和汇编语言的中间，这意味着，它的特征也是处于二者之间的。</p><p>与高级语言相比，IR丢弃了大部分高级语言的语法特征和语义特征，比如循环语句、if语句、作用域、面向对象等等，它更像高层次的汇编语言；而相比真正的汇编语言，它又不会有那么多琐碎的、与具体硬件相关的细节。</p><p>相信你在学习汇编语言的时候，会发现汇编语言的细节特别多。比如，你要知道很多指令的名字和用法，还要记住很多不同的寄存器。<a href="https://time.geekbang.org/column/article/147854" target="_blank" rel="noopener noreferrer">在22讲</a>，我提到，如果你想完整地掌握x86-64架构，还需要接触很多指令集，以及调用约定的细节、内存使用的细节等等（<a href="https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4" target="_blank" rel="noopener noreferrer">参见Intel的手册</a>）。</p><p>仅仅拿指令的数量来说，据有人统计，Intel指令的助记符有981个之多！都记住怎么可能啊。<strong>所以说，汇编语言并不难，而是麻烦。</strong></p><p>IR不会像x86-64汇编语言那么繁琐，但它却包含了足够的细节信息，能方便我们实现优化算法，以及生成针对目标机器的汇编代码。</p><p>另外，我在20讲提到，IR有很多种类（AST也是一种IR），每种IR都有不同的特点和用途，有的编译器，甚至要用到几种不同的IR。</p><p>我们在后端部分所讲的IR，目的是方便执行各种优化算法，并有利于生成汇编。<strong>这种IR，可以看做是一种高层次的汇编语言，主要体现在：</strong></p><ul><li>它可以使用寄存器，但寄存器的数量没有限制；</li><li>控制结构也跟汇编语言比较像，比如有跳转语句，分成多个程序块，用标签来标识程序块等；</li><li>使用相当于汇编指令的操作码。这些操作码可以一对一地翻译成汇编代码，但有时一个操作码会对应多个汇编指令。</li></ul><p>下面来看看一个典型IR：三地址代码，简称TAC。</p><h2 id="认识典型的ir-三地址代码-tac" tabindex="-1"><a class="header-anchor" href="#认识典型的ir-三地址代码-tac"><span>认识典型的IR：三地址代码（TAC）</span></a></h2><p>下面是一种常见的IR的格式，它叫做三地址代码（Three Address Code, TAC），它的优点是很简洁，所以适合用来讨论算法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>x := y op z   //二元操作</span></span>
<span class="line"><span>x := op y     //一元操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>每条三地址代码最多有三个地址，其中两个是源地址（比如第一行代码的y和z），一个是目的地址（也就是x），每条代码最多有一个操作（op）。</p><p>我来举几个例子，带你熟悉一下三地址代码，<strong>这样，你能掌握三地址代码的特点，从高级语言的代码转换生成三地址代码。</strong></p><p><strong>1.基本的算术运算：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int a, b, c, d;</span></span>
<span class="line"><span>a = b + c * d;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>TAC：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1 := c * d</span></span>
<span class="line"><span>a  := b + t1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>t1是新产生的临时变量。当源代码的表达式中包含一个以上的操作符时，就需要引入临时变量，并把原来的一条代码拆成多条代码。</p><p><strong>2.布尔值的计算：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int a, b;</span></span>
<span class="line"><span>bool x, y;</span></span>
<span class="line"><span>x = a * 2 &amp;lt; b;</span></span>
<span class="line"><span>y = a + 3 == b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TAC：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1 := a * 2;</span></span>
<span class="line"><span>x  := t1 &amp;lt; b;</span></span>
<span class="line"><span>t2 := a + 3;</span></span>
<span class="line"><span>y  := t2 == b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>布尔值实际上是用整数表示的，0代表false，非0值代表true。</p><p><strong>3.条件语句：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int a, b c;</span></span>
<span class="line"><span>if (a &amp;lt; b )</span></span>
<span class="line"><span>    c = b;</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>    c = a;  </span></span>
<span class="line"><span>c = c * 2;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TAC：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  t1 := a &amp;lt; b;</span></span>
<span class="line"><span>  IfZ t1 Goto L1;</span></span>
<span class="line"><span>  c := a;</span></span>
<span class="line"><span>  Goto L2;</span></span>
<span class="line"><span>L1:</span></span>
<span class="line"><span>  c := b;</span></span>
<span class="line"><span>L2:</span></span>
<span class="line"><span>  c := c * 2;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IfZ是检查后面的操作数是否是0，“Z”就是“Zero”的意思。这里使用了标签和Goto语句来进行指令的跳转（Goto相当于x86-64的汇编指令jmp）。</p><p><strong>4.循环语句：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int a, b;</span></span>
<span class="line"><span>while (a &amp;lt; b){</span></span>
<span class="line"><span>  a = a + 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>a = a + b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TAC：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>L1:</span></span>
<span class="line"><span>  t1 := a &amp;lt; b;</span></span>
<span class="line"><span>  IfZ t1 Goto L2;</span></span>
<span class="line"><span>  a := a + 1;</span></span>
<span class="line"><span>  Goto L1;</span></span>
<span class="line"><span>L2:</span></span>
<span class="line"><span>  a := a + b;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三地址代码的规则相当简单，我们可以通过比较简单的转换规则，就能从AST生成TAC。</p><p>在课程中，三地址代码主要用来描述优化算法，因为它比较简洁易读，操作（指令）的类型很少，书写方式也符合我们的日常习惯。**不过，我并不用它来生成汇编代码，因为它含有的细节信息还是比较少，**比如，整数是16位的、32位的还是64位的？目标机器的架构和操作系统是什么？生成二进制文件的布局是怎样的等等？</p><p>**我会用LLVM的IR来承担生成汇编的任务，**因为它有能力描述与目标机器（CPU、操作系统）相关的更加具体的信息，准确地生成目标代码，从而真正能够用于生产环境。</p><p>**在讲这个问题之前，我想先延伸一下，讲讲另外几种IR的格式，**主要想帮你开拓思维，如果你的项目需求，恰好能用这种IR实现，到时不妨拿来用一下：</p><li> 首先是四元式。它是与三地址代码等价的另一种表达方式，格式是：（OP，arg1，arg2，result）所以，“a := b + c” 就等价于（+，b，c，a）。 </li><li> 另一种常用的格式是逆波兰表达式。它把操作符放到后面，所以也叫做后缀表达式。“b + c”对应的逆波兰表达式是“b c +”；而“a = b + c”对应的逆波兰表达式是“a b c + =”。 </li><p>**逆波兰表达式特别适合用栈来做计算。**比如计算“b c +”，先从栈里弹出加号，知道要做加法操作，然后从栈里弹出两个操作数，执行加法运算即可。这个计算过程，跟深度优先的遍历AST是等价的。所以，采用逆波兰表达式，有可能让你用一个很简单的方式就实现公式计算功能，**如果你编写带有公式功能的软件时可以考虑使用它。**而且，从AST生成逆波兰表达式也非常容易。</p><p>三地址代码主要是学习算法的工具，或者用于实现比较简单的后端，要实现工业级的后端，充分发挥硬件的性能，你还要学习LLVM的IR。</p><h2 id="认识llvm汇编码" tabindex="-1"><a class="header-anchor" href="#认识llvm汇编码"><span>认识LLVM汇编码</span></a></h2><p>**LLVM汇编码（LLVM Assembly），是LLVM的IR。**有的时候，我们就简单地称呼它为LLVM语言，因此我们可以把用LLVM汇编码书写的一个程序文件叫做LLVM程序。</p><p>我会在下一讲，详细讲解LLVM这个开源项目。本节课作为铺垫，告诉我们在使用LLVM之前，要先了解它的核心——IR。</p><p><strong>首先，LLVM汇编码是采用静态单赋值代码形式的。</strong></p><p>在三地址代码上再加一些限制，就能得到另一种重要的代码，即静态单赋值代码（Static Single Assignment, SSA），在静态单赋值代码中，一个变量只能被赋值一次，来看个例子。</p><p>“y = x1 + x2 + x3 + x4”的普通三地址代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>y := x1 + x2;</span></span>
<span class="line"><span>y := y + x3;</span></span>
<span class="line"><span>y := y + x4;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，y被赋值了三次，如果写成SSA的形式，就只能写成下面的样子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>t1 := x1 + x2;</span></span>
<span class="line"><span>t2 := t1 + x3;</span></span>
<span class="line"><span>y  := t2 + x4;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么要费力写成这种形式呢，还要为此多添加t1和t2两个临时变量？原因是SSA的形式，体现了精确的“使用-定义”关系。</p><p>每个变量很确定地只会被定义一次，然后可以多次使用。这种特点使得基于SSA更容易做数据流分析，而数据流分析又是很多代码优化技术的基础，所以，几乎所有语言的编译器、解释器或虚拟机中都使用了SSA，因为有利于做代码优化。而LLVM的IR，也是采用SSA的形式，也是因为SSA方便做代码优化。</p><p>**其次，LLVM IR比起三地址代码，有更多的细节信息。**比如整型变量的字长、内存对齐方式等等，所以使用LLVM IR能够更准确地翻译成汇编码。</p><p>看看下面这段C语言代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int fun1(int a, int b){</span></span>
<span class="line"><span>  int c = 10;</span></span>
<span class="line"><span>  return a + b + c;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的LLLM汇编码如下（这是我在macOS上生成的）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>; ModuleID = &#39;fun1.c&#39;</span></span>
<span class="line"><span>source_filename = &amp;quot;fun1.c&amp;quot;</span></span>
<span class="line"><span>target datalayout = &amp;quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&amp;quot;</span></span>
<span class="line"><span>target triple = &amp;quot;x86_64-apple-macosx10.14.0&amp;quot;</span></span>
<span class="line"><span>; Function Attrs: noinline nounwind optnone ssp uwtable</span></span>
<span class="line"><span>define i32 @fun1(i32, i32) #0 {</span></span>
<span class="line"><span>  %3 = alloca i32, align 4        //为3个变量申请空间</span></span>
<span class="line"><span>  %4 = alloca i32, align 4     </span></span>
<span class="line"><span>  %5 = alloca i32, align 4</span></span>
<span class="line"><span>  store i32 %0, i32* %3, align 4  //参数1赋值给变量1</span></span>
<span class="line"><span>  store i32 %1, i32* %4, align 4  //参数2赋值给变量2</span></span>
<span class="line"><span>  store i32 10, i32* %5, align 4  //常量10赋值给变量3</span></span>
<span class="line"><span>  %6 = load i32, i32* %3, align 4 //</span></span>
<span class="line"><span>  %7 = load i32, i32* %4, align 4</span></span>
<span class="line"><span>  %8 = add nsw i32 %6, %7</span></span>
<span class="line"><span>  %9 = load i32, i32* %5, align 4</span></span>
<span class="line"><span>  %10 = add nsw i32 %8, %9</span></span>
<span class="line"><span>  ret i32 %10</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>attributes #0 = { noinline nounwind optnone ssp uwtable &amp;quot;correctly-rounded-divide-sqrt-fp-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;disable-tail-calls&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;less-precise-fpmad&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;no-frame-pointer-elim&amp;quot;=&amp;quot;true&amp;quot; &amp;quot;no-frame-pointer-elim-non-leaf&amp;quot; &amp;quot;no-infs-fp-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;no-jump-tables&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;no-nans-fp-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;no-signed-zeros-fp-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;no-trapping-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;stack-protector-buffer-size&amp;quot;=&amp;quot;8&amp;quot; &amp;quot;target-cpu&amp;quot;=&amp;quot;penryn&amp;quot; &amp;quot;target-features&amp;quot;=&amp;quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&amp;quot; &amp;quot;unsafe-fp-math&amp;quot;=&amp;quot;false&amp;quot; &amp;quot;use-soft-float&amp;quot;=&amp;quot;false&amp;quot; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>!llvm.module.flags = !{!0, !1, !2}</span></span>
<span class="line"><span>!llvm.ident = !{!3}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>!0 = !{i32 2, !&amp;quot;SDK Version&amp;quot;, [2 x i32] [i32 10, i32 14]}</span></span>
<span class="line"><span>!1 = !{i32 1, !&amp;quot;wchar_size&amp;quot;, i32 4}</span></span>
<span class="line"><span>!2 = !{i32 7, !&amp;quot;PIC Level&amp;quot;, i32 2}</span></span>
<span class="line"><span>!3 = !{!&amp;quot;Apple LLVM version 10.0.1 (clang-1001.0.46.4)&amp;quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些代码看上去确实比三地址代码复杂，但还是比汇编精简多了，比如LLVM IR的指令数量连x86-64汇编的十分之一都不到。</p><p><strong>我们来熟悉一下里面的元素：</strong></p><ul><li>模块</li></ul><p>LLVM程序是由模块构成的，这个文件就是一个模块。模块里可以包括函数、全局变量和符号表中的条目。链接的时候，会把各个模块拼接到一起，形成可执行文件或库文件。</p><p>在模块中，你可以定义目标数据布局（target datalayout）。例如，开头的小写“e”是低字节序（Little Endian）的意思，对于超过一个字节的数据来说，低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>target datalayout = &amp;quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&amp;quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>“target triple”用来定义模块的目标主机，它包括架构、厂商、操作系统三个部分。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>target triple = &amp;quot;x86_64-apple-macosx10.14.0&amp;quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>函数</li></ul><p>在示例代码中有一个以define开头的函数的声明，还带着花括号。这有点儿像C语言的写法，比汇编用采取标签来表示一个函数的可读性更好。</p><p>函数声明时可以带很多修饰成分，比如链接类型、调用约定等。如果不写，缺省的链接类型是external的，也就是可以像<a href="https://time.geekbang.org/column/article/150798" target="_blank" rel="noopener noreferrer">23讲</a>中做链接练习的那样，暴露出来被其他模块链接。调用约定也有很多种选择，缺省是“ccc”，也就是C语言的调用约定（C Calling Convention），而“swiftcc”则是swift语言的调用约定。<strong>这些信息都是生成汇编时所需要的。</strong></p><p>示例中函数fun1还带有“#0”的属性值，定义了许多属性。这些也是生成汇编时所需要的。</p><ul><li>标识符</li></ul><p>分为全局的（Glocal）和本地的（Local）：全局标识符以@开头，包括函数和全局变量，前面代码中的@fun1就是；本地标识符以%开头。</p><p>有的标识符是有名字的，比如@fun1或%a，有的是没有名字的，用数字表示就可以了，如%1。</p><ul><li>操作码</li></ul><p>alloca、store、load、add、ret这些，都是操作码。它们的含义是：</p><img src="https://static001.geekbang.org/resource/image/b6/3e/b60c17cd8aa27160003884a2e1e4fd3e.jpg" alt=""><p>它们跟我们之前学到的汇编很相似。但是似乎函数体中的代码有点儿长。怎么一个简单的“a+b+c”就翻译成了10多行代码，还用到了那么多临时变量？不要担心，**这只是完全没经过优化的格式，**带上优化参数稍加优化以后，它就会被精简成下面的样子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>define i32 @fun1(i32, i32) local_unnamed_addr #0 {</span></span>
<span class="line"><span>  %3 = add i32 %0, 10</span></span>
<span class="line"><span>  %4 = add i32 %3, %1</span></span>
<span class="line"><span>  ret i32 %4</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>类型系统</li></ul><p>汇编是无类型的。如果你用add指令，它就认为你操作的是整数。而用fadd（或addss）指令，就认为你操作的是浮点数。这样会有类型不安全的风险，把整型当浮点数用了，造成的后果是计算结果完全错误。</p><p>LLVM汇编则带有一个类型系统。它能避免不安全的数据操作，并且有助于优化算法。这个类型系统包括<strong>基础数据类型、函数类型和void类型。</strong></p><img src="https://static001.geekbang.org/resource/image/09/2e/090b2841d969debe803346460764242e.jpg" alt=""><p><strong>函数类型</strong>是包括对返回值和参数的定义，比如：i32 (i32)；</p><p><strong>void类型</strong>不代表任何值，也没有长度。</p><ul><li>全局变量和常量</li></ul><p>在LLVM汇编中可以声明全局变量。全局变量所定义的内存，是在编译时就分配好了的，而不是在运行时，例如下面这句定义了一个全局变量C：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@c = global i32 100, align 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你也可以声明常量，它的值在运行时不会被修改：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@c = constant i32 100, align 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>元数据</li></ul><p>在代码中你还看到以“!”开头的一些句子，这些是元数据。这些元数据定义了一些额外的信息，提供给优化器和代码生成器使用。</p><ul><li>基本块</li></ul><p>函数中的代码会分成一个个的基本块，可以用标签（Label）来标记一个基本块。下面这段代码有4个基本块，其中第一个块有一个缺省的名字“entry”，也就是作为入口的基本块，这个基本块你不给它标签也可以。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>define i32 @bb(i32) #0 {</span></span>
<span class="line"><span>  %2 = alloca i32, align 4</span></span>
<span class="line"><span>  %3 = alloca i32, align 4</span></span>
<span class="line"><span>  store i32 %0, i32* %3, align 4</span></span>
<span class="line"><span>  %4 = load i32, i32* %3, align 4</span></span>
<span class="line"><span>  %5 = icmp sgt i32 %4, 0</span></span>
<span class="line"><span>  br i1 %5, label %6, label %9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; &amp;lt;label&amp;gt;:6:                                      ; preds = %1</span></span>
<span class="line"><span>  %7 = load i32, i32* %3, align 4</span></span>
<span class="line"><span>  %8 = mul nsw i32 %7, 2</span></span>
<span class="line"><span>  store i32 %8, i32* %2, align 4</span></span>
<span class="line"><span>  br label %12</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; &amp;lt;label&amp;gt;:9:                                      ; preds = %1</span></span>
<span class="line"><span>  %10 = load i32, i32* %3, align 4</span></span>
<span class="line"><span>  %11 = add nsw i32 %10, 3</span></span>
<span class="line"><span>  store i32 %11, i32* %2, align 4</span></span>
<span class="line"><span>  br label %12</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; &amp;lt;label&amp;gt;:12:                                     ; preds = %9, %6</span></span>
<span class="line"><span>  %13 = load i32, i32* %2, align 4</span></span>
<span class="line"><span>  ret i32 %13</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码实际上相当于下面这段C语言的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int bb(int b){</span></span>
<span class="line"><span>    if (b &amp;gt; 0)</span></span>
<span class="line"><span>        return b * 2;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return b + 3;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个基本块是一系列的指令。我们分析一下标签为9的基本块，<strong>让你熟悉一下基本块和LLVM指令的特点：</strong></p><p>第一行（%10 = load i32, i32* %3, align 4）的含义是：把3号变量（32位整型）从内存加载到寄存器，叫做10号变量，其中，内存对齐是4字节。</p><p>**我在这里延伸一下，**我们在内存里存放数据的时候，有时会从2、4、8个字节的整数倍地址开始存。有些汇编指令要求必须从这样对齐的地址来取数据。另一些指令没做要求，但如果是不对齐的，比如是从0x03地址取数据，就要花费更多的时钟周期。但缺点是，内存对齐会浪费内存空间。</p><p>第一行是整个基本块的唯一入口，从其他基本块跳转过来的时候，只能跳转到这个入口行，不能跳转到基本块中的其他行。</p><p>第二行（%11 = add nsw i32 %10, 3）的含义是：把10号变量（32位整型）加上3，保存到11号变量，其中nsw是加法计算时没有符号环绕（No Signed Wrap）的意思。它的细节你可以查阅“<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener noreferrer">LLVM语言参考手册</a>”。</p><p>第三行（store i32 %11, i32* %2, align 4）的含义是：把11号变量（32位整型）存入内存中的2号变量，内存对齐4字节。</p><p>第四行（br label %12）的含义是：跳转到标签为12的代码块。其中，br指令是一条终结指令。终结指令要么是跳转到另一个基本块，要么是从函数中返回（ret指令），基本块的最后一行必须是一条终结指令。</p><p>最后我要强调，从其他基本块不可以跳转到入口基本块，也就是函数中的第一个基本块。这个规定也是有利于做数据优化。</p><p>以上就是对LLVM汇编码的概要介绍（更详细的信息了解可以参见“LLVM语言参考手册”）。</p><p>这样，你实际上就可以用LLVM汇编码来编写程序了，或者将AST翻译成LLVM汇编码。听上去有点让人犯怵，因为LLVM汇编码的细节也相当不少，好在，LLVM提供了一个IR生成的API（应用编程接口），可以让我们更高效、更准确地生成IR。</p><h2 id="课程小结" tabindex="-1"><a class="header-anchor" href="#课程小结"><span>课程小结</span></a></h2><p>IR是我们后续做代码优化、汇编代码生成的基础，在本节课中，我想让你明确的要点如下：</p><p>1.三地址代码是很常见的一种IR，包含一个目的地址、一个操作符和至多两个源地址。它等价于四元式。我们在27讲和28讲中的优化算法，会用三地址代码来讲解，这样比较易于阅读。</p><p>2.LLVM IR的第一个特点是静态单赋值（SSA），也就是每个变量（地址）最多被赋值一次，它这种特性有利于运行代码优化算法；第二个特点是带有比较多的细节，方便我们做优化和生成高质量的汇编代码。</p><p>通过本节课，你应该对于编译器后端中常常提到的IR建立了直观的认识，相信通过接下来的练习，你一定会消除对IR的陌生感，让它成为你得心应手的好工具！</p><h2 id="一课一思" tabindex="-1"><a class="header-anchor" href="#一课一思"><span>一课一思</span></a></h2><p>我们介绍了IR的特点和几种基本的IR，在你的领域，比如人工智能领域，你了解其他的IR吗？它带来了什么好处？欢迎分享你的经验和观点。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的人。</p>`,122)]))}const c=a(l,[["render",p]]),o=JSON.parse('{"path":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%20%C2%B7%20%E5%8E%9F%E7%90%86%E7%AF%87/24%20_%20%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AF%AD%E8%A8%80%E5%92%8C%E7%A1%AC%E4%BB%B6.html","title":"","lang":"zh-CN","frontmatter":{"description":"前几节课，我带你尝试不通过IR，直接生成汇编代码，这是为了帮你快速破冰，建立直觉。在这个过程中，你也遇到了一些挑战，比如： 你要对生成的代码进行优化，才有可能更好地使用寄存器和内存，同时也能减少代码量； 另外，针对不同的CPU和操作系统，你需要调整生成汇编代码的逻辑。 这些实际体验，都进一步验证了20讲中，IR的作用：我们能基于IR对接不同语言的前端，...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%20%C2%B7%20%E5%8E%9F%E7%90%86%E7%AF%87/24%20_%20%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AF%AD%E8%A8%80%E5%92%8C%E7%A1%AC%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"前几节课，我带你尝试不通过IR，直接生成汇编代码，这是为了帮你快速破冰，建立直觉。在这个过程中，你也遇到了一些挑战，比如： 你要对生成的代码进行优化，才有可能更好地使用寄存器和内存，同时也能减少代码量； 另外，针对不同的CPU和操作系统，你需要调整生成汇编代码的逻辑。 这些实际体验，都进一步验证了20讲中，IR的作用：我们能基于IR对接不同语言的前端，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":16.79,"words":5036},"filePathRelative":"posts/编译原理之美/实现一门编译型语言 · 原理篇/24 _ 中间代码：兼容不同的语言和硬件.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"24 | 中间代码：兼容不同的语言和硬件\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/9f/09/9f3b7c6de4ad431ce4e85c1119f35e09.mp3\\"></audio></p>\\n<p>前几节课，我带你尝试不通过IR，直接生成汇编代码，这是为了帮你快速破冰，建立直觉。在这个过程中，你也遇到了一些挑战，比如：</p>\\n<li>\\n你要对生成的代码进行优化，才有可能更好地使用寄存器和内存，同时也能减少代码量；\\n</li>","autoDesc":true}');export{c as comp,o as data};

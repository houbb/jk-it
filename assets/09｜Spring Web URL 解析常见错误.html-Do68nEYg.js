import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as n,b as l,d as e,e as t,w as r,r as d,o}from"./app-6Bz2fGO5.js";const c={};function m(u,a){const s=d("string");return o(),p("div",null,[a[2]||(a[2]=n(`<p><audio id="audio" title="09｜Spring Web URL 解析常见错误" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/f6/60/f6d5eb2743c77f06fb192f97ec0d9460.mp3"></audio></p><p>你好，我是傅健。</p><p>上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。</p><p>不言而喻，这里说的 Web 服务就是指使用 HTTP 协议的服务。而对于 HTTP 请求，首先要处理的就是 URL，所以今天我们就先来介绍下，在 URL 的处理上，Spring 都有哪些经典的案例。闲话少叙，下面我们直接开始演示吧。</p><h2 id="案例-1-当-pathvariable-遇到" tabindex="-1"><a class="header-anchor" href="#案例-1-当-pathvariable-遇到"><span>案例 1：当@PathVariable 遇到 /</span></a></h2><p>在解析一个 URL 时，我们经常会使用 @PathVariable 这个注解。例如我们会经常见到如下风格的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RestController</span></span>
<span class="line"><span>@Slf4j</span></span>
<span class="line"><span>public class HelloWorldController {</span></span>
<span class="line"><span>    @RequestMapping(path = &amp;quot;/hi1/{name}&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>    public String hello1(@PathVariable(&amp;quot;name&amp;quot;) String name){</span></span>
<span class="line"><span>        return name;</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>    };  </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们使用 <a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiaoming</a> 访问这个服务时，会返回&quot;xiaoming&quot;，即 Spring 会把 name 设置为 URL 中对应的值。</p><p>看起来顺风顺水，但是假设这个 name 中含有特殊字符/时（例如<a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiao/ming</a> ），会如何？如果我们不假思索，或许答案是&quot;xiao/ming&quot;？然而稍微敏锐点的程序员都会判定这个访问是会报错的，具体错误参考：</p><img src="https://static001.geekbang.org/resource/image/92/64/92a3c8894b88eec937139f3c858bf664.png" alt=""><p>如图所示，当 name 中含有/，这个接口不会为 name 获取任何值，而是直接报Not Found错误。当然这里的“找不到”并不是指name找不到，而是指服务于这个特殊请求的接口。</p><p>实际上，这里还存在另外一种错误，即当 name 的字符串以/结尾时，/会被自动去掉。例如我们访问 <a href="http://localhost:8080/hi1/xiaoming/" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiaoming/</a>，Spring 并不会报错，而是返回xiaoming。</p><p>针对这两种类型的错误，应该如何理解并修正呢？</p><h3 id="案例解析" tabindex="-1"><a class="header-anchor" href="#案例解析"><span>案例解析</span></a></h3><p>实际上，这两种错误都是 URL 匹配执行方法的相关问题，所以我们有必要先了解下 URL 匹配执行方法的大致过程。参考 AbstractHandlerMethodMapping#lookupHandlerMethod：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Nullable</span></span>
<span class="line"><span>protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {</span></span>
<span class="line"><span>   List&amp;lt;Match&amp;gt; matches = new ArrayList&amp;lt;&amp;gt;();</span></span>
<span class="line"><span>   //尝试按照 URL 进行精准匹配</span></span>
<span class="line"><span>   List&amp;lt;T&amp;gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);</span></span>
<span class="line"><span>   if (directPathMatches != null) {</span></span>
<span class="line"><span>      //精确匹配上，存储匹配结果</span></span>
<span class="line"><span>      addMatchingMappings(directPathMatches, matches, request);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   if (matches.isEmpty()) {</span></span>
<span class="line"><span>      //没有精确匹配上，尝试根据请求来匹配</span></span>
<span class="line"><span>      addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   if (!matches.isEmpty()) {</span></span>
<span class="line"><span>      Comparator&amp;lt;Match&amp;gt; comparator = new MatchComparator(getMappingComparator(request));</span></span>
<span class="line"><span>      matches.sort(comparator);</span></span>
<span class="line"><span>      Match bestMatch = matches.get(0);</span></span>
<span class="line"><span>      if (matches.size() &amp;gt; 1) {</span></span>
<span class="line"><span>         //处理多个匹配的情况</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      //省略其他非关键代码</span></span>
<span class="line"><span>      return bestMatch.handlerMethod;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   else {</span></span>
<span class="line"><span>      //匹配不上，直接报错</span></span>
<span class="line"><span>      return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);</span></span>
<span class="line"><span>   }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大体分为这样几个基本步骤。</p><p><strong>1. 根据 Path 进行精确匹配</strong></p><p>这个步骤执行的代码语句是&quot;this.mappingRegistry.getMappingsByUrl(lookupPath)&quot;，实际上，它是查询 MappingRegistry#urlLookup，它的值可以用调试视图查看，如下图所示：</p><img src="https://static001.geekbang.org/resource/image/d5/80/d579a4557a06ef8a0ba960ed05184b80.png" alt=""><p>查询 urlLookup 是一个精确匹配 Path 的过程。很明显，<a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiao/ming</a> 的 lookupPath 是&quot;/hi1/xiao/ming&quot;，并不能得到任何精确匹配。这里需要补充的是，&quot;/hi1/{name}&quot;这种定义本身也没有出现在 urlLookup 中。</p><p><strong>2. 假设 Path 没有精确匹配上，则执行模糊匹配</strong></p><p>在步骤 1 匹配失败时，会根据请求来尝试模糊匹配，待匹配的匹配方法可参考下图：</p><img src="https://static001.geekbang.org/resource/image/1d/2b/1da52225336ec68451471ac4de36db2b.png" alt=""><p>显然，&quot;/hi1/{name}&quot;这个匹配方法已经出现在待匹配候选中了。具体匹配过程可以参考方法 RequestMappingInfo#getMatchingCondition：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public RequestMappingInfo getMatchingCondition(HttpServletRequest request) {</span></span>
<span class="line"><span>   RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);</span></span>
<span class="line"><span>   if (methods == null) {</span></span>
<span class="line"><span>      return null;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);</span></span>
<span class="line"><span>   if (params == null) {</span></span>
<span class="line"><span>      return null;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   //省略其他匹配条件</span></span>
<span class="line"><span>   PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);</span></span>
<span class="line"><span>   if (patterns == null) {</span></span>
<span class="line"><span>      return null;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   //省略其他匹配条件</span></span>
<span class="line"><span>   return new RequestMappingInfo(this.name, patterns,</span></span>
<span class="line"><span>         methods, params, headers, consumes, produces, custom.getCondition());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们知道<strong>匹配会查询所有的信息</strong>，例如 Header、Body 类型以及URL 等。如果有一项不符合条件，则不匹配。</p><p>在我们的案例中，当使用 <a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiaoming</a> 访问时，其中 patternsCondition 是可以匹配上的。实际的匹配方法执行是通过 AntPathMatcher#match 来执行，判断的相关参数可参考以下调试视图：</p><img src="https://static001.geekbang.org/resource/image/f2/c6/f224047fd2d4ee0751229415a9ac87c6.png" alt=""><p>但是当我们使用 <a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiao/ming</a> 来访问时，AntPathMatcher 执行的结果是&quot;/hi1/xiao/ming&quot;匹配不上&quot;/hi1/{name}&quot;。</p><p><strong>3. 根据匹配情况返回结果</strong></p><p>如果找到匹配的方法，则返回方法；如果没有，则返回 null。</p><p>在本案例中，<a href="http://localhost:8080/hi1/xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiao/ming</a> 因为找不到匹配方法最终报 404 错误。追根溯源就是 AntPathMatcher 匹配不了&quot;/hi1/xiao/ming&quot;和&quot;/hi1/{name}&quot;。</p><p>另外，我们再回头思考 <a href="http://localhost:8080/hi1/xiaoming/" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi1/xiaoming/</a> 为什么没有报错而是直接去掉了/。这里我直接贴出了负责执行 AntPathMatcher 匹配的 PatternsRequestCondition#getMatchingPattern 方法的部分关键代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private String getMatchingPattern(String pattern, String lookupPath) {</span></span>
<span class="line"><span>   //省略其他非关键代码</span></span>
<span class="line"><span>   if (this.pathMatcher.match(pattern, lookupPath)) {</span></span>
<span class="line"><span>      return pattern;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   //尝试加一个/来匹配</span></span>
<span class="line"><span>   if (this.useTrailingSlashMatch) {</span></span>
<span class="line"><span>      if (!pattern.endsWith(&amp;quot;/&amp;quot;) &amp;amp;&amp;amp; this.pathMatcher.match(pattern + &amp;quot;/&amp;quot;, lookupPath)) {</span></span>
<span class="line"><span>         return pattern + &amp;quot;/&amp;quot;;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   return null;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，AntPathMatcher 匹配不了&quot;/hi1/xiaoming/&quot;和&quot;/hi1/{name}&quot;，所以不会直接返回。进而，在 useTrailingSlashMatch 这个参数启用时（默认启用），会把 Pattern 结尾加上/再尝试匹配一次。如果能匹配上，在最终返回 Pattern 时就隐式自动加/。</p><p>很明显，我们的案例符合这种情况，等于说我们最终是用了&quot;/hi1/{name}/&quot;这个 Pattern，而不再是&quot;/hi1/{name}&quot;。所以自然 URL 解析 name 结果是去掉/的。</p><h3 id="问题修正" tabindex="-1"><a class="header-anchor" href="#问题修正"><span>问题修正</span></a></h3><p>针对这个案例，有了源码的剖析，我们可能会想到可以先用&quot;**&quot;匹配上路径，等进入方法后再尝试去解析，这样就可以万无一失吧。具体修改代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi1/**&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi1(HttpServletRequest request){</span></span>
<span class="line"><span>    String requestURI = request.getRequestURI();</span></span>
<span class="line"><span>    return requestURI.split(&amp;quot;/hi1/&amp;quot;)[1];</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种修改方法还是存在漏洞，假设我们路径的 name 中刚好又含有&quot;/hi1/&quot;，则 split 后返回的值就并不是我们想要的。实际上，更合适的修订代码示例如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private AntPathMatcher antPathMatcher = new AntPathMatcher();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RequestMapping(path = &amp;quot;/hi1/**&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi1(HttpServletRequest request){</span></span>
<span class="line"><span>    String path = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);</span></span>
<span class="line"><span>    //matchPattern 即为&amp;quot;/hi1/**&amp;quot;</span></span>
<span class="line"><span>    String matchPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE); </span></span>
<span class="line"><span>    return antPathMatcher.extractPathWithinPattern(matchPattern, path); </span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过修改，两个错误都得以解决了。当然也存在一些其他的方案，例如对传递的参数进行 URL 编码以避免出现/，或者干脆直接把这个变量作为请求参数、Header 等，而不是作为 URL 的一部分。你完全可以根据具体情况来选择合适的方案。</p><h2 id="案例-2-错误使用-requestparam、-pathvarible-等注解" tabindex="-1"><a class="header-anchor" href="#案例-2-错误使用-requestparam、-pathvarible-等注解"><span>案例 2：错误使用@RequestParam、@PathVarible 等注解</span></a></h2><p>我们常常使用@RequestParam 和@PathVarible 来获取请求参数（request parameters）以及 path 中的部分。但是在频繁使用这些参数时，不知道你有没有觉得它们的使用方式并不友好，例如我们去获取一个请求参数 name，我们会定义如下：</p><blockquote></blockquote><p>@RequestParam(&quot;name&quot;) String name</p><p>此时，我们会发现变量名称大概率会被定义成 RequestParam值。所以我们是不是可以用下面这种方式来定义：</p><blockquote></blockquote><p>@RequestParam String name</p><p>这种方式确实是可以的，本地测试也能通过。这里我还给出了完整的代码，你可以感受下这两者的区别。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi1&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi1(@RequestParam(&amp;quot;name&amp;quot;) String name){</span></span>
<span class="line"><span>    return name;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@RequestMapping(path = &amp;quot;/hi2&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi2(@RequestParam String name){</span></span>
<span class="line"><span>    return name;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很明显，对于喜欢追究极致简洁的同学来说，这个酷炫的功能是一个福音。但当我们换一个项目时，有可能上线后就失效了，然后报错 500，提示匹配不上。</p><img src="https://static001.geekbang.org/resource/image/f3/7f/f377e98e0293e480c4ea249596ec4d7f.png" alt=""><h3 id="案例解析-1" tabindex="-1"><a class="header-anchor" href="#案例解析-1"><span>案例解析</span></a></h3><p>要理解这个问题出现的原因，首先我们需要把这个问题复现出来。例如我们可以修改下 pom.xml 来关掉两个选项：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;lt;plugin&amp;gt;</span></span>
<span class="line"><span>    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;</span></span>
<span class="line"><span>    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;</span></span>
<span class="line"><span>   &amp;lt;configuration&amp;gt;</span></span>
<span class="line"><span>        &amp;lt;debug&amp;gt;false&amp;lt;/debug&amp;gt;</span></span>
<span class="line"><span>        &amp;lt;parameters&amp;gt;false&amp;lt;/parameters&amp;gt;</span></span>
<span class="line"><span>    &amp;lt;/configuration&amp;gt;</span></span>
<span class="line"><span>&amp;lt;/plugin&amp;gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述配置显示关闭了 parameters 和 debug，这 2 个参数的作用你可以参考下面的表格：</p><img src="https://static001.geekbang.org/resource/image/c6/a0/c60cabd6a71f02db8663eae8224ddaa0.jpg" alt=""><p>通过上述描述，我们可以看出这 2 个参数控制了一些 debug 信息是否加进 class 文件中。我们可以开启这两个参数来编译，然后使用下面的命令来查看信息：</p><blockquote></blockquote><p>javap -verbose HelloWorldController.class</p><p>执行完命令后，我们会看到以下 class 信息：</p><img src="https://static001.geekbang.org/resource/image/1e/e4/1e7fee355e63528c97bbf47e8bdaa6e4.png" alt=""><p>debug 参数开启的部分信息就是 LocalVaribleTable，而 paramters 参数开启的信息就是 MethodParameters。观察它们的信息，你会发现它们都含有参数名name。</p><p>如果你关闭这两个参数，则 name 这个名称自然就没有了。而这个方法本身在 @RequestParam 中又没有指定名称，那么 Spring 此时还能找到解析的方法么？</p><p>答案是否定的，这里我们可以顺带说下 Spring 解析请求参数名称的过程，参考代码 AbstractNamedValueMethodArgumentResolver#updateNamedValueInfo：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {</span></span>
<span class="line"><span>   String name = info.name;</span></span>
<span class="line"><span>   if (info.name.isEmpty()) {</span></span>
<span class="line"><span>      name = parameter.getParameterName();</span></span>
<span class="line"><span>      if (name == null) {</span></span>
<span class="line"><span>         throw new IllegalArgumentException(</span></span>
<span class="line"><span>               &amp;quot;Name for argument type [&amp;quot; + parameter.getNestedParameterType().getName() +</span></span>
<span class="line"><span>               &amp;quot;] not available, and parameter name information not found in class file either.&amp;quot;);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);</span></span>
<span class="line"><span>   return new NamedValueInfo(name, info.required, defaultValue);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 NamedValueInfo 的 name 为 @RequestParam 指定的值。很明显，在本案例中，为 null。</p><p>所以这里我们就会尝试调用 parameter.getParameterName() 来获取参数名作为解析请求参数的名称。但是，很明显，关掉上面两个开关后，就不可能在 class 文件中找到参数名了，这点可以从下面的调试试图中得到验证：</p><img src="https://static001.geekbang.org/resource/image/8d/37/8dc41bf12f0075573bf6b6d13b2a2537.png" alt=""><p>当参数名不存在，@RequestParam 也没有指明，自然就无法决定到底要用什么名称去获取请求参数，所以就会报本案例的错误。</p><h3 id="问题修正-1" tabindex="-1"><a class="header-anchor" href="#问题修正-1"><span>问题修正</span></a></h3><p>模拟出了问题是如何发生的，我们自然可以通过开启这两个参数让其工作起来。但是思考这两个参数的作用，很明显，它可以让我们的程序体积更小，所以很多项目都会青睐去关闭这两个参数。</p><p>为了以不变应万变，正确的修正方式是<strong>必须显式在@RequestParam 中指定请求参数名</strong>。具体修改如下：</p><blockquote></blockquote><p>@RequestParam(&quot;name&quot;) String name</p><p>通过这个案例，我们可以看出：很多功能貌似可以永远工作，但是实际上，只是在特定的条件下而已。另外，这里再拓展下，IDE 都喜欢开启相关 debug 参数，所以 IDE 里运行的程序不见得对产线适应，例如针对 parameters 这个参数，IDEA 默认就开启了。</p><p>另外，本案例围绕的都是 @RequestParam，其实 @PathVarible 也有一样的问题。这里你要注意。</p><p>那么说到这里，我顺带提一个可能出现的小困惑：我们这里讨论的参数，和 @QueryParam、@PathParam 有什么区别？实际上，后者都是 JAX-RS 自身的注解，不需要额外导包。而 @RequestParam 和 @PathVariable 是 Spring 框架中的注解，需要额外导入依赖包。另外不同注解的参数也不完全一致。</p><h2 id="案例-3-未考虑参数是否可选" tabindex="-1"><a class="header-anchor" href="#案例-3-未考虑参数是否可选"><span>案例 3：未考虑参数是否可选</span></a></h2><p>在上面的案例中，我们提到了 @RequestParam 的使用。而对于它的使用，我们常常会遇到另外一个问题。当需要特别多的请求参数时，我们往往会忽略其中一些参数是否可选。例如存在类似这样的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi4&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi4(@RequestParam(&amp;quot;name&amp;quot;) String name, @RequestParam(&amp;quot;address&amp;quot;) String address){</span></span>
<span class="line"><span>    return name + &amp;quot;:&amp;quot; + address;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在访问 <a href="http://localhost:8080/hi2?name=xiaoming&amp;address=beijing" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi4?name=xiaoming&amp;address=beijing</a> 时并不会出问题，但是一旦用户仅仅使用 name 做请求（即 <a href="http://localhost:8080/hi4?name=xiaoming" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi4?name=xiaoming</a> ）时，则会直接报错如下：</p><img src="https://static001.geekbang.org/resource/image/92/09/9289ddbf7e1b39131662ab3fc1807709.png" alt=""><p>此时，返回错误码 400，提示请求格式错误：此处缺少 address 参数。</p><p>实际上，部分初学者即使面对这个错误，也会觉得惊讶，既然不存在 address，address 应该设置为 null，而不应该是直接报错不是么？接下来我们就分析下。</p><h3 id="案例解析-2" tabindex="-1"><a class="header-anchor" href="#案例解析-2"><span>案例解析</span></a></h3><p>要了解这个错误出现的根本原因，你就需要了解请求参数的发生位置。</p><p>实际上，这里我们也能按注解名（@RequestParam）来确定解析发生的位置是在 RequestParamMethodArgumentResolver 中。为什么是它？</p><p>追根溯源，针对当前案例，当根据 URL 匹配上要执行的方法是 hi4 后，要反射调用它，必须解析出方法参数 name 和 address 才可以。而它们被 @RequestParam 注解修饰，所以解析器借助 RequestParamMethodArgumentResolver 就成了很自然的事情。</p><p>接下来我们看下 RequestParamMethodArgumentResolver 对参数解析的一些关键操作，参考其父类方法 AbstractNamedValueMethodArgumentResolver#resolveArgument：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span>
<span class="line"><span>      NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {</span></span>
<span class="line"><span>   NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span></span>
<span class="line"><span>   MethodParameter nestedParameter = parameter.nestedIfOptional();</span></span>
<span class="line"><span>   //省略其他非关键代码</span></span>
<span class="line"><span>   //获取请求参数</span></span>
<span class="line"><span>   Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span></span>
<span class="line"><span>   if (arg == null) {</span></span>
<span class="line"><span>      if (namedValueInfo.defaultValue != null) {</span></span>
<span class="line"><span>         arg = resolveStringValue(namedValueInfo.defaultValue);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      else if (namedValueInfo.required &amp;amp;&amp;amp; !nestedParameter.isOptional()) {</span></span>
<span class="line"><span>         handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   //省略后续代码：类型转化等工作</span></span>
<span class="line"><span>   return arg;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如代码所示，当缺少请求参数的时候，通常我们会按照以下几个步骤进行处理。</p><p><strong>1. 查看 namedValueInfo 的默认值，如果存在则使用它</strong></p><p>这个变量实际是通过下面的方法来获取的，参考 RequestParamMethodArgumentResolver#createNamedValueInfo：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {</span></span>
<span class="line"><span>   RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);</span></span>
<span class="line"><span>   return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上就是 @RequestParam 的相关信息，我们调试下，就可以验证这个结论，具体如下图所示：</p><img src="https://static001.geekbang.org/resource/image/f5/5e/f56f4498bcd078c20e4320yy2353af5e.png" alt=""><p><strong>2. 在 @RequestParam 没有指明默认值时，会查看这个参数是否必须，如果必须，则按错误处理</strong></p><p>判断参数是否必须的代码即为下述关键代码行：</p><blockquote></blockquote><p>namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()</p><p>很明显，若要判定一个参数是否是必须的，需要同时满足两个条件：条件 1 是@RequestParam 指明了必须（即属性 required 为 true，实际上它也是默认值），条件 2 是要求 @RequestParam 标记的参数本身不是可选的。</p><p>我们可以通过 MethodParameter#isOptional 方法看下可选的具体含义：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public boolean isOptional() {</span></span>
<span class="line"><span>   return (getParameterType() == Optional.class || hasNullableAnnotation() ||</span></span>
<span class="line"><span>         (KotlinDetector.isKotlinReflectPresent() &amp;amp;&amp;amp;</span></span>
<span class="line"><span>               KotlinDetector.isKotlinType(getContainingClass()) &amp;amp;&amp;amp;</span></span>
<span class="line"><span>               KotlinDelegate.isOptional(this)));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在不使用 Kotlin 的情况下，所谓可选，就是参数的类型为 Optional，或者任何标记了注解名为 Nullable 且 RetentionPolicy 为 RUNTIM 的注解。</p><p><strong>3. 如果不是必须，则按 null 去做具体处理</strong></p><p>如果接受类型是 boolean，返回 false，如果是基本类型则直接报错，这里不做展开。</p><p>结合我们的案例，我们的参数符合步骤 2 中判定为必选的条件，所以最终会执行方法 AbstractNamedValueMethodArgumentResolver#handleMissingValue：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>protected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {</span></span>
<span class="line"><span>   throw new ServletRequestBindingException(&amp;quot;Missing argument &#39;&amp;quot; + name +</span></span>
<span class="line"><span>         &amp;quot;&#39; for method parameter of type &amp;quot; + parameter.getNestedParameterType().getSimpleName());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="问题修正-2" tabindex="-1"><a class="header-anchor" href="#问题修正-2"><span>问题修正</span></a></h3><p>通过案例解析，我们很容易就能修正这个问题，就是让参数有默认值或为非可选即可，具体方法包含以下几种。</p><p><strong>1. 设置 @RequestParam 的默认值</strong></p><p>修改代码如下：</p><blockquote></blockquote><p>@RequestParam(value = &quot;address&quot;, defaultValue = &quot;no address&quot;) String address</p><p><strong>2. 设置 @RequestParam 的 required 值</strong></p><p>修改代码如下：</p><blockquote></blockquote><p>@RequestParam(value = &quot;address&quot;, required = false) String address)</p><p><strong>3. 标记任何名为 Nullable 且 RetentionPolicy 为 RUNTIME 的注解</strong></p><p>修改代码如下：</p><blockquote></blockquote><p>[//org.springframework.lang.Nullable](//org.springframework.lang.Nullable) 可以<br> [//edu.umd.cs.findbugs.annotations.Nullable](//edu.umd.cs.findbugs.annotations.Nullable) 可以<br> @RequestParam(value = &quot;address&quot;) @Nullable String address</p><p><strong>4. 修改参数类型为 Optional</strong></p><p>修改代码如下：</p><blockquote></blockquote>`,128)),l("p",null,[a[1]||(a[1]=e('@RequestParam(value = "address") Optional')),t(s,null,{default:r(()=>a[0]||(a[0]=[e(" address")])),_:1})]),a[3]||(a[3]=n(`<p>从这些修正方法不难看出：假设你不学习源码，解决方法就可能只局限于一两种，但是深入源码后，解决方法就变得格外多了。这里要特别强调的是：<strong>在Spring Web 中，默认情况下，请求参数是必选项。</strong></p><h2 id="案例-4-请求参数格式错误" tabindex="-1"><a class="header-anchor" href="#案例-4-请求参数格式错误"><span>案例 4：请求参数格式错误</span></a></h2><p>当我们使用 Spring URL 相关的注解，会发现 Spring 是能够完成自动转化的。例如在下面的代码中，age 可以被直接定义为 int 这种基本类型（Integer 也可以），而不是必须是 String 类型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi5&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi5(@RequestParam(&amp;quot;name&amp;quot;) String name, @RequestParam(&amp;quot;age&amp;quot;) int age){</span></span>
<span class="line"><span>    return name + &amp;quot; is &amp;quot; + age + &amp;quot; years old&amp;quot;;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>鉴于 Spring 的强大转化功能，我们断定 Spring 也支持日期类型的转化（也确实如此），于是我们可能会写出类似下面这样的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi6&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi6(@RequestParam(&amp;quot;Date&amp;quot;) Date date){</span></span>
<span class="line"><span>    return &amp;quot;date is &amp;quot; + date ;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们使用一些看似明显符合日期格式的 URL 来访问，例如 <a href="http://localhost:8080/hi6?date=2021-5-1%2020:26:53" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi6?date=2021-5-1 20:26:53</a>，我们会发现 Spring 并不能完成转化，而是报错如下：</p><img src="https://static001.geekbang.org/resource/image/08/78/085931e6c4c8a01ae5f4f443c0393778.png" alt=""><p>此时，返回错误码 400，错误信息为&quot;Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.util.Date&quot;。</p><p>如何理解这个案例？如果实现自动转化，我们又需要做什么？</p><h3 id="案例解析-3" tabindex="-1"><a class="header-anchor" href="#案例解析-3"><span>案例解析</span></a></h3><p>不管是使用 @PathVarible 还是 @RequetParam，我们一般解析出的结果都是一个 String 或 String 数组。例如，使用 @RequetParam 解析的关键代码参考 RequestParamMethodArgumentResolver#resolveName 方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Nullable</span></span>
<span class="line"><span>protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {</span></span>
<span class="line"><span>   //省略其他非关键代码</span></span>
<span class="line"><span>   if (arg == null) {</span></span>
<span class="line"><span>      String[] paramValues = request.getParameterValues(name);</span></span>
<span class="line"><span>      if (paramValues != null) {</span></span>
<span class="line"><span>         arg = (paramValues.length == 1 ? paramValues[0] : paramValues);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   return arg;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们调用的&quot;request.getParameterValues(name)&quot;，返回的是一个 String 数组，最终给上层调用者返回的是单个 String（如果只有一个元素时）或者 String 数组。</p><p>所以很明显，在这个测试程序中，我们给上层返回的是一个 String，这个 String 的值最终是需要做转化才能赋值给其他类型。例如对于案例中的&quot;int age&quot;定义，是需要转化为 int 基本类型的。这个基本流程可以通过 AbstractNamedValueMethodArgumentResolver#resolveArgument 的关键代码来验证：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span>
<span class="line"><span>      NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {</span></span>
<span class="line"><span>   //省略其他非关键代码</span></span>
<span class="line"><span>   Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span></span>
<span class="line"><span>   //以此为界，前面代码为解析请求参数,后续代码为转化解析出的参数</span></span>
<span class="line"><span>   if (binderFactory != null) {</span></span>
<span class="line"><span>      WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);</span></span>
<span class="line"><span>      try {</span></span>
<span class="line"><span>         arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      //省略其他非关键代码</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   //省略其他非关键代码</span></span>
<span class="line"><span>   return arg;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上在前面我们曾经提到过这个转化的基本逻辑，所以这里不再详述它具体是如何发生的。</p><p>在这里你只需要回忆出它是需要<strong>根据源类型和目标类型寻找转化器来执行转化的</strong>。在这里，对于 age 而言，最终找出的转化器是 StringToNumberConverterFactory。而对于 Date 型的 Date 变量，在本案例中，最终找到的是 ObjectToObjectConverter。它的转化过程参考下面的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {</span></span>
<span class="line"><span>   if (source == null) {</span></span>
<span class="line"><span>      return null;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   Class&amp;lt;?&amp;gt; sourceClass = sourceType.getType();</span></span>
<span class="line"><span>   Class&amp;lt;?&amp;gt; targetClass = targetType.getType();</span></span>
<span class="line"><span>   //根据源类型去获取构建出目标类型的方法：可以是工厂方法（例如 valueOf、from 方法）也可以是构造器</span></span>
<span class="line"><span>   Member member = getValidatedMember(targetClass, sourceClass);</span></span>
<span class="line"><span>   try {</span></span>
<span class="line"><span>      if (member instanceof Method) {</span></span>
<span class="line"><span>         //如果是工厂方法，通过反射创建目标实例</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      else if (member instanceof Constructor) {</span></span>
<span class="line"><span>         //如果是构造器，通过反射创建实例</span></span>
<span class="line"><span>         Constructor&amp;lt;?&amp;gt; ctor = (Constructor&amp;lt;?&amp;gt;) member;</span></span>
<span class="line"><span>         ReflectionUtils.makeAccessible(ctor);</span></span>
<span class="line"><span>         return ctor.newInstance(source);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   catch (InvocationTargetException ex) {</span></span>
<span class="line"><span>      throw new ConversionFailedException(sourceType, targetType, source, ex.getTargetException());</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   catch (Throwable ex) {</span></span>
<span class="line"><span>      throw new ConversionFailedException(sourceType, targetType, source, ex);</span></span>
<span class="line"><span>   }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用 ObjectToObjectConverter 进行转化时，是根据反射机制带着源目标类型来查找可能的构造目标实例方法，例如构造器或者工厂方法，然后再次通过反射机制来创建一个目标对象。所以对于 Date 而言，最终调用的是下面的 Date 构造器：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public Date(String s) {</span></span>
<span class="line"><span>    this(parse(s));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，我们传入的 <a href="http://localhost:8080/hi6?date=2021-5-1%2020:26:53" target="_blank" rel="noopener noreferrer">2021-5-1 20:26:53</a> 虽然确实是一种日期格式，但用来作为 Date 构造器参数是不支持的，最终报错，并被上层捕获，转化为 ConversionFailedException 异常。这就是这个案例背后的故事了。</p><h3 id="问题修正-3" tabindex="-1"><a class="header-anchor" href="#问题修正-3"><span>问题修正</span></a></h3><p>那么怎么解决呢？提供两种方法。</p><p><strong>1. 使用 Date 支持的格式</strong></p><p>例如下面的测试 URL 就可以工作起来：</p><blockquote></blockquote><p><a href="http://localhost:8080/hi6?date=Sat" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi6?date=Sat</a>, 12 Aug 1995 13:30:00 GMT</p><p><strong>2. 使用好内置格式转化器</strong></p><p>实际上，在Spring中，要完成 String 对于 Date 的转化，ObjectToObjectConverter 并不是最好的转化器。我们可以使用更强大的AnnotationParserConverter。**在Spring 初始化时，会构建一些针对日期型的转化器，即相应的一些 AnnotationParserConverter 的实例。**但是为什么有时候用不上呢？</p><p>这是因为 AnnotationParserConverter 有目标类型的要求，这点我们可以通过调试角度来看下，参考 FormattingConversionService#addFormatterForFieldAnnotation 方法的调试试图：</p><img src="https://static001.geekbang.org/resource/image/0c/34/0c8bd3fc14081710cc411091c8bd4f34.png" alt=""><p>这是适应于 String 到 Date 类型的转化器 AnnotationParserConverter 实例的构造过程，其需要的 annototationType 参数为 DateTimeFormat。</p><p>annototationType 的作用正是为了帮助判断是否能用这个转化器，这一点可以参考代码 AnnotationParserConverter#matches：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {</span></span>
<span class="line"><span>   return targetType.hasAnnotation(this.annotationType);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终构建出来的转化器相关信息可以参考下图：</p><img src="https://static001.geekbang.org/resource/image/f0/b1/f068b39c4a3f81b8ccebbfd962e966b1.png" alt=""><p>图中构造出的转化器是可以用来转化 String 到 Date，但是它要求我们标记 @DateTimeFormat。很明显，我们的参数 Date 并没有标记这个注解，所以这里为了使用这个转化器，我们可以使用上它并提供合适的格式。这样就可以让原来不工作的 URL 工作起来，具体修改代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@DateTimeFormat(pattern=&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;) Date date</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以上即为本案例的解决方案。除此之外，我们完全可以制定一个转化器来帮助我们完成转化，这里不再赘述。另外，通过这个案例，我们可以看出：尽管 Spring 给我们提供了很多内置的转化功能，但是我们一定要注意，格式是否符合对应的要求，否则代码就可能会失效。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾"><span>重点回顾</span></a></h2><p>通过这一讲的学习，我们了解到了在Spring解析URL中的一些常见错误及其背后的深层原因。这里再次回顾下重点：</p><ol><li>当我们使用@PathVariable时，一定要注意传递的值是不是含有 / ;</li><li>当我们使用@RequestParam、@PathVarible等注解时，一定要意识到一个问题，虽然下面这两种方式（以@RequestParam使用示例）都可以，但是后者在一些项目中并不能正常工作，因为很多产线的编译配置会去掉不是必须的调试信息。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi1&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi1(@RequestParam(&amp;quot;name&amp;quot;) String name){</span></span>
<span class="line"><span>    return name;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>//方式2：没有显式指定RequestParam的“name”，这种方式有时候会不行</span></span>
<span class="line"><span>@RequestMapping(path = &amp;quot;/hi2&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi2(@RequestParam String name){</span></span>
<span class="line"><span>    return name;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>任何一个参数，我们都需要考虑它是可选的还是必须的。同时，你一定要想到参数类型的定义到底能不能从请求中自动转化而来。Spring本身给我们内置了很多转化器，但是我们要以合适的方式使用上它。另外，Spring对很多类型的转化设计都很贴心，例如使用下面的注解就能解决自定义日期格式参数转化问题。</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@DateTimeFormat(pattern=&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;) Date date</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>希望这些核心知识点，能帮助你高效解析URL。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>关于 URL 解析，其实还有许多让我们惊讶的地方，例如案例 2 的部分代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RequestMapping(path = &amp;quot;/hi2&amp;quot;, method = RequestMethod.GET)</span></span>
<span class="line"><span>public String hi2(@RequestParam(&amp;quot;name&amp;quot;) String name){</span></span>
<span class="line"><span>    return name;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码的应用中，我们可以使用 <a href="http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei" target="_blank" rel="noopener noreferrer">http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei</a> 来测试下，结果会返回什么呢？你猜会是<a href="http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei" target="_blank" rel="noopener noreferrer">xiaoming&amp;name=hanmeimei</a> 么？</p><p>我们留言区见！</p>`,52))])}const b=i(c,[["render",m]]),v=JSON.parse('{"path":"/posts/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/Spring%20Web%20%E7%AF%87/09%EF%BD%9CSpring%20Web%20URL%20%E8%A7%A3%E6%9E%90%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是傅健。 上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。 不言而喻，这里说的...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B/Spring%20Web%20%E7%AF%87/09%EF%BD%9CSpring%20Web%20URL%20%E8%A7%A3%E6%9E%90%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是傅健。 上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。 不言而喻，这里说的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":20.47,"words":6140},"filePathRelative":"posts/Spring编程常见错误50例/Spring Web 篇/09｜Spring Web URL 解析常见错误.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"09｜Spring Web URL 解析常见错误\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/f6/60/f6d5eb2743c77f06fb192f97ec0d9460.mp3\\"></audio></p>\\n<p>你好，我是傅健。</p>\\n<p>上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。</p>","autoDesc":true}');export{b as comp,v as data};

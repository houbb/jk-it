import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,n){return i(),a("div",null,n[0]||(n[0]=[e(`<p><audio id="audio" title="44 | 协程：更轻量级的线程" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/ba/06/ba6e712ec378d7a8a18ccaa81a4f5206.mp3"></audio></p><p>Java语言里解决并发问题靠的是多线程，但线程是个重量级的对象，不能频繁创建、销毁，而且线程切换的成本也很高，为了解决这些问题，Java SDK提供了线程池。然而用好线程池并不容易，Java围绕线程池提供了很多工具类，这些工具类学起来也不容易。那有没有更好的解决方案呢？Java语言里目前还没有，但是其他语言里有，这个方案就是<strong>协程</strong>（Coroutine）。</p><p>我们可以把<strong>协程</strong>简单地理解<strong>为一种轻量级的线程</strong>。从操作系统的角度来看，线程是在内核态中调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。协程虽然也有自己的栈，但是相比线程栈要小得多，典型的线程栈大小差不多有1M，而协程栈的大小往往只有几K或者几十K。所以，无论是从时间维度还是空间维度来看，协程都比线程轻量得多。</p><p>支持协程的语言还是挺多的，例如Golang、Python、Lua、Kotlin等都支持协程。下面我们就以Golang为代表，看看协程是如何在Golang中使用的。</p><h2 id="golang中的协程" tabindex="-1"><a class="header-anchor" href="#golang中的协程"><span>Golang中的协程</span></a></h2><p>在Golang中创建协程非常简单，在下面的示例代码中，要让hello()方法在一个新的协程中执行，只需要<code>go hello(&quot;World&quot;)</code> 这一行代码就搞定了。你可以对比着想想在Java里是如何“辛勤”地创建线程和线程池的吧，我的感觉一直都是：每次写完Golang的代码，就再也不想写Java代码了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import (</span></span>
<span class="line"><span>	&amp;quot;fmt&amp;quot;</span></span>
<span class="line"><span>	&amp;quot;time&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>func hello(msg string) {</span></span>
<span class="line"><span>	fmt.Println(&amp;quot;Hello &amp;quot; + msg)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>    //在新的协程中执行hello方法</span></span>
<span class="line"><span>	go hello(&amp;quot;World&amp;quot;)</span></span>
<span class="line"><span>    fmt.Println(&amp;quot;Run in main&amp;quot;)</span></span>
<span class="line"><span>    //等待100毫秒让协程执行结束</span></span>
<span class="line"><span>	time.Sleep(100 * time.Millisecond)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在<a href="https://time.geekbang.org/column/article/95098" target="_blank" rel="noopener noreferrer">《33 | Thread-Per-Message模式：最简单实用的分工方法》</a>中介绍过，利用协程能够很好地实现Thread-Per-Message模式。Thread-Per-Message模式非常简单，其实越是简单的模式，功能上就越稳定，可理解性也越好。</p><p>下面的示例代码是用Golang实现的echo程序的服务端，用的是Thread-Per-Message模式，为每个成功建立连接的socket分配一个协程，相比Java线程池的实现方案，Golang中协程的方案更简单。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import (</span></span>
<span class="line"><span>	&amp;quot;log&amp;quot;</span></span>
<span class="line"><span>	&amp;quot;net&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>    //监听本地9090端口</span></span>
<span class="line"><span>	socket, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:9090&amp;quot;)</span></span>
<span class="line"><span>	if err != nil {</span></span>
<span class="line"><span>		log.Panicln(err)</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	defer socket.Close()</span></span>
<span class="line"><span>	for {</span></span>
<span class="line"><span>        //处理连接请求  </span></span>
<span class="line"><span>		conn, err := socket.Accept()</span></span>
<span class="line"><span>		if err != nil {</span></span>
<span class="line"><span>			log.Panicln(err)</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>        //处理已经成功建立连接的请求</span></span>
<span class="line"><span>		go handleRequest(conn)</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//处理已经成功建立连接的请求</span></span>
<span class="line"><span>func handleRequest(conn net.Conn) {</span></span>
<span class="line"><span>	defer conn.Close()</span></span>
<span class="line"><span>	for {</span></span>
<span class="line"><span>		buf := make([]byte, 1024)</span></span>
<span class="line"><span>        //读取请求数据</span></span>
<span class="line"><span>		size, err := conn.Read(buf)</span></span>
<span class="line"><span>		if err != nil {</span></span>
<span class="line"><span>			return</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>        //回写相应数据  </span></span>
<span class="line"><span>		conn.Write(buf[:size])</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="利用协程实现同步" tabindex="-1"><a class="header-anchor" href="#利用协程实现同步"><span>利用协程实现同步</span></a></h2><p>其实协程并不仅限于实现Thread-Per-Message模式，它还可以将异步模式转换为同步模式。异步编程虽然近几年取得了长足发展，但是异步的思维模式对于普通人来讲毕竟是有难度的，只有线性的思维模式才是适合所有人的。而线性的思维模式反映到编程世界，就是同步。</p><p>在Java里使用多线程并发地处理I/O，基本上用的都是<strong>异步非阻塞模型</strong>，这种模型的异步主要是靠注册回调函数实现的，那能否都使用同步处理呢？显然是不能的。因为同步意味着等待，而线程等待，本质上就是一种严重的浪费。不过对于协程来说，等待的成本就没有那么高了，所以基于协程实现<strong>同步非阻塞</strong>是一个可行的方案。</p><p>OpenResty里实现的cosocket就是一种同步非阻塞方案，借助cosocket我们可以用线性的思维模式来编写非阻塞的程序。下面的示例代码是用cosocket实现的socket程序的客户端，建立连接、发送请求、读取响应所有的操作都是同步的，由于cosocket本身是非阻塞的，所以这些操作虽然是同步的，但是并不会阻塞。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-- 创建socket</span></span>
<span class="line"><span>local sock = ngx.socket.tcp()</span></span>
<span class="line"><span>-- 设置socket超时时间</span></span>
<span class="line"><span>sock:settimeouts(connect_timeout, send_timeout, read_timeout)</span></span>
<span class="line"><span>-- 连接到目标地址</span></span>
<span class="line"><span>local ok, err = sock:connect(host, port)</span></span>
<span class="line"><span>if not ok then</span></span>
<span class="line"><span>-  -- 省略异常处理</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span>-- 发送请求</span></span>
<span class="line"><span>local bytes, err = sock:send(request_data)</span></span>
<span class="line"><span>if not bytes then</span></span>
<span class="line"><span>  -- 省略异常处理</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span>-- 读取响应</span></span>
<span class="line"><span>local line, err = sock:receive()</span></span>
<span class="line"><span>if err then</span></span>
<span class="line"><span>  -- 省略异常处理</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span>-- 关闭socket</span></span>
<span class="line"><span>sock:close()   </span></span>
<span class="line"><span>-- 处理读取到的数据line</span></span>
<span class="line"><span>handle(line)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="结构化并发编程" tabindex="-1"><a class="header-anchor" href="#结构化并发编程"><span>结构化并发编程</span></a></h2><p>Golang中的 go 语句让协程用起来太简单了，但是这种简单也蕴藏着风险。要深入了解这个风险是什么，就需要先了解一下 goto 语句的前世今生。</p><p>在我上学的时候，各种各样的编程语言书籍中都会谈到不建议使用 goto 语句，原因是 goto 语句会让程序变得混乱，当时对于这个问题我也没有多想，不建议用那就不用了。那为什么 goto 语句会让程序变得混乱呢？混乱具体指的又是什么呢？多年之后，我才了解到所谓的混乱指的是代码的书写顺序和执行顺序不一致。代码的书写顺序，代表的是我们的思维过程，如果思维的过程与代码执行的顺序不一致，那就会干扰我们对代码的理解。我们的思维是线性的，傻傻地一条道儿跑到黑，而goto语句太灵活，随时可以穿越时空，实在是太“混乱”了。</p><p>首先发现 goto 语句是“毒药”的人是著名的计算机科学家艾兹格·迪科斯彻（Edsger Dijkstra），同时他还提出了结构化程序设计。在结构化程序设计中，可以使用三种基本控制结构来代替goto，这三种基本的控制结构就是今天我们广泛使用的<strong>顺序结构</strong>、<strong>选择结构</strong>和<strong>循环结构</strong>。</p><img src="https://static001.geekbang.org/resource/image/50/20/501db93634beff4776dd803eb4463920.png" alt=""><img src="https://static001.geekbang.org/resource/image/15/bd/1528f3026981910eef7624aed9c72dbd.png" alt=""><img src="https://static001.geekbang.org/resource/image/0d/fd/0d5fa62f62d1e999601ed7e2d52a1dfd.png" alt=""><img src="https://static001.geekbang.org/resource/image/c7/9d/c7814d5d1563ab38c312b75c953c4c9d.png" alt=""><p>这三种基本的控制结构奠定了今天高级语言的基础，如果仔细观察这三种结构，你会发现它们的入口和出口只有一个，这意味它们是可组合的，而且组合起来一定是线性的，整体来看，代码的书写顺序和执行顺序也是一致的。</p><p>我们以前写的并发程序，是否违背了结构化程序设计呢？这个问题以前并没有被关注，但是最近两年，随着并发编程的快速发展，已经开始有人关注了，而且剑指Golang中的 go 语句，指其为“毒药”，类比的是 goto 语句。详情可以参考<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/" target="_blank" rel="noopener noreferrer">相关的文章</a>。</p><p>Golang中的 go 语句不过是快速创建协程的方法而已，这篇文章本质上并不仅仅在批判Golang中的 go 语句，而是在批判开启新的线程（或者协程）异步执行这种粗糙的做法，违背了结构化程序设计，Java语言其实也在其列。</p><p>当开启一个新的线程时，程序会并行地出现两个分支，主线程一个分支，子线程一个分支，这两个分支很多情况下都是天各一方、永不相见。而结构化的程序，可以有分支，但是最终一定要汇聚，不能有多个出口，因为只有这样它们组合起来才是线性的。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>最近几年支持协程的开发语言越来越多了，Java OpenSDK中Loom项目的目标就是支持协程，相信不久的将来，Java程序员也可以使用协程来解决并发问题了。</p><p>计算机里很多面向开发人员的技术，大多数都是在解决一个问题：<strong>易用性</strong>。协程作为一项并发编程技术，本质上也不过是解决并发工具的易用性问题而已。对于易用性，我觉得最重要的就是<strong>要适应我们的思维模式</strong>，在工作的前几年，我并没有怎么关注它，但是最近几年思维模式已成为我重点关注的对象。因为思维模式对工作的很多方面都会产生影响，例如质量。</p><p>一个软件产品是否能够活下去，从质量的角度看，最核心的就是代码写得好。那什么样的代码是好代码呢？我觉得，最根本的是可读性好。可读性好的代码，意味着大家都可以上手，而且上手后不会大动干戈。那如何让代码的可读性好呢？很简单，换位思考，用大众、普通的思维模式去写代码，而不是炫耀自己的各种设计能力。我觉得好的代码，就像人民的艺术一样，应该是为人民群众服务的，只有根植于广大群众之中，才有生命力。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>`,32)]))}const o=s(p,[["render",l]]),d=JSON.parse('{"path":"/posts/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/44%20_%20%E5%8D%8F%E7%A8%8B%EF%BC%9A%E6%9B%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E7%BA%BF%E7%A8%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"Java语言里解决并发问题靠的是多线程，但线程是个重量级的对象，不能频繁创建、销毁，而且线程切换的成本也很高，为了解决这些问题，Java SDK提供了线程池。然而用好线程池并不容易，Java围绕线程池提供了很多工具类，这些工具类学起来也不容易。那有没有更好的解决方案呢？Java语言里目前还没有，但是其他语言里有，这个方案就是协程（Coroutine）。...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/44%20_%20%E5%8D%8F%E7%A8%8B%EF%BC%9A%E6%9B%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"Java语言里解决并发问题靠的是多线程，但线程是个重量级的对象，不能频繁创建、销毁，而且线程切换的成本也很高，为了解决这些问题，Java SDK提供了线程池。然而用好线程池并不容易，Java围绕线程池提供了很多工具类，这些工具类学起来也不容易。那有没有更好的解决方案呢？Java语言里目前还没有，但是其他语言里有，这个方案就是协程（Coroutine）。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":8.23,"words":2470},"filePathRelative":"posts/Java并发编程实战/第五部分：其他并发模型/44 _ 协程：更轻量级的线程.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"44 | 协程：更轻量级的线程\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/ba/06/ba6e712ec378d7a8a18ccaa81a4f5206.mp3\\"></audio></p>\\n<p>Java语言里解决并发问题靠的是多线程，但线程是个重量级的对象，不能频繁创建、销毁，而且线程切换的成本也很高，为了解决这些问题，Java SDK提供了线程池。然而用好线程池并不容易，Java围绕线程池提供了很多工具类，这些工具类学起来也不容易。那有没有更好的解决方案呢？Java语言里目前还没有，但是其他语言里有，这个方案就是<strong>协程</strong>（Coroutine）。</p>","autoDesc":true}');export{o as comp,d as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,s){return i(),e("div",null,s[0]||(s[0]=[a(`<p><audio id="audio" title="13 | 编译期能做些什么？一个完整的计算世界" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/81/00/81fcf04cc42e895037ddd0d01faab000.mp3"></audio></p><p>你好，我是吴咏炜。</p><p>上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。</p><h2 id="编译期计算" tabindex="-1"><a class="header-anchor" href="#编译期计算"><span>编译期计算</span></a></h2><p>首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 [1]。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。</p><p>当然，这只是理论上的结论。从实际的角度，我们并不<strong>想</strong>、也不可能在编译期完成所有的计算，更不用说编译期的编程是很容易让人看不懂的——因为这并不是语言设计的初衷。即便如此，我们也还是需要了解一下模板元编程的基本概念：它仍然有一些实用的场景，并且在实际的工程中你也可能会遇到这样的代码。虽然我们在开篇就说过不要炫技，但使用模板元编程写出的代码仍然是可理解的，尤其是如果你对递归不发怵的话。</p><p>好，闲话少叙，我们仍然拿代码说话：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;int n&amp;gt;</span></span>
<span class="line"><span>struct factorial {</span></span>
<span class="line"><span>  static const int value =</span></span>
<span class="line"><span>    n * factorial&amp;lt;n - 1&amp;gt;::value;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;&amp;gt;</span></span>
<span class="line"><span>struct factorial&amp;lt;0&amp;gt; {</span></span>
<span class="line"><span>  static const int value = 1;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义了一个递归的阶乘函数。可以看出，它完全符合阶乘的递归定义：</p><p>$$<br><br> \\begin{aligned}<br><br> 0! &amp;= 1 \\&lt;br/&gt;<br> n! &amp;= n \\times (n - 1)!<br><br> \\end{aligned}<br><br> $$</p><p>除了顺序有特定的要求——先定义，才能特化——再加语法有点特别，代码基本上就是这个数学定义的简单映射了。</p><p>那我们怎么知道这个计算是不是在编译时做的呢？我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（<code>printf(&quot;%d\\n&quot;, factorial&amp;lt;10&amp;gt;::value);</code>）在 x86-64 下的编译结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.LC0:</span></span>
<span class="line"><span>        .string &quot;%d\\n&quot;</span></span>
<span class="line"><span>main:</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        mov     esi, 3628800</span></span>
<span class="line"><span>        mov     edi, OFFSET FLAT:.LC0</span></span>
<span class="line"><span>        mov     eax, 0</span></span>
<span class="line"><span>        call    printf</span></span>
<span class="line"><span>        mov     eax, 0</span></span>
<span class="line"><span>        pop     rbp</span></span>
<span class="line"><span>        ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。上面那些递归什么的，完全都没有了踪影。</p><p>如果我们传递一个负数给 <code>factorial</code> 呢？这时的结果就应该是编译期间的递归溢出。如 GCC 会报告：</p><blockquote></blockquote><p>fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)</p><p>如果把 <code>int</code> 改成 <code>unsigned</code>，不同的编译器和不同的标准选项会导致不同的结果。有些情况下错误信息完全不变，有些情况下则会报负数不能转换到 <code>unsigned</code>。通用的解决方案是使用 <code>static_assert</code>，确保参数永远不会是负数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;int n&amp;gt;</span></span>
<span class="line"><span>struct factorial {</span></span>
<span class="line"><span>  static_assert(</span></span>
<span class="line"><span>    n &amp;gt;= 0,</span></span>
<span class="line"><span>    &quot;Arg must be non-negative&quot;);</span></span>
<span class="line"><span>  static const int value =</span></span>
<span class="line"><span>    n * factorial&amp;lt;n - 1&amp;gt;::value;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当 <code>factorial</code> 接收到一个负数作为参数时，就会得到一个干脆的错误信息：</p><blockquote></blockquote><p>error: static assertion failed: Arg must be non-negative</p><p>下面我们看一些更复杂的例子。这些例子不是为了让你真的去写这样的代码，而是帮助你充分理解编译期编程的强大威力。如果这些例子你都完全掌握了，那以后碰到小的模板问题，你一定可以轻松解决，完全不在话下。</p><p>回想上面的例子，我们可以看到，要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;bool cond,</span></span>
<span class="line"><span>          typename Then,</span></span>
<span class="line"><span>          typename Else&amp;gt;</span></span>
<span class="line"><span>struct If;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;typename Then,</span></span>
<span class="line"><span>          typename Else&amp;gt;</span></span>
<span class="line"><span>struct If&amp;lt;true, Then, Else&amp;gt; {</span></span>
<span class="line"><span>  typedef Then type;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;typename Then,</span></span>
<span class="line"><span>          typename Else&amp;gt;</span></span>
<span class="line"><span>struct If&amp;lt;false, Then, Else&amp;gt; {</span></span>
<span class="line"><span>  typedef Else type;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>If</code> 模板有三个参数，第一个是布尔值，后面两个则是代表不同分支计算的类型，这个类型可以是我们上面定义的任何一个模板实例，包括 <code>If</code> 和 <code>factorial</code>。第一个 struct 声明规定了模板的形式，然后我们不提供通用定义，而是提供了两个特化。第一个特化是真的情况，定义结果 <code>type</code> 为 <code>Then</code> 分支；第二个特化是假的情况，定义结果 <code>type</code> 为 <code>Else</code> 分支。</p><p>我们一般也需要循环：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;bool condition,</span></span>
<span class="line"><span>          typename Body&amp;gt;</span></span>
<span class="line"><span>struct WhileLoop;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;typename Body&amp;gt;</span></span>
<span class="line"><span>struct WhileLoop&amp;lt;true, Body&amp;gt; {</span></span>
<span class="line"><span>  typedef typename WhileLoop&amp;lt;</span></span>
<span class="line"><span>    Body::cond_value,</span></span>
<span class="line"><span>    typename Body::next_type&amp;gt;::type</span></span>
<span class="line"><span>    type;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;typename Body&amp;gt;</span></span>
<span class="line"><span>struct WhileLoop&amp;lt;false, Body&amp;gt; {</span></span>
<span class="line"><span>  typedef</span></span>
<span class="line"><span>    typename Body::res_type type;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;typename Body&amp;gt;</span></span>
<span class="line"><span>struct While {</span></span>
<span class="line"><span>  typedef typename WhileLoop&amp;lt;</span></span>
<span class="line"><span>    Body::cond_value, Body&amp;gt;::type</span></span>
<span class="line"><span>    type;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个循环的模板定义稍复杂点。首先，我们对循环体类型有一个约定，它必须提供一个静态数据成员，<code>cond_value</code>，及两个子类型定义，<code>res_type</code> 和 <code>next_type</code>：</p><ul><li><code>cond_value</code> 代表循环的条件（真或假）</li><li><code>res_type</code> 代表退出循环时的状态</li><li><code>next_type</code> 代表下面循环执行一次时的状态</li></ul><p>这里面比较绕的地方是用类型来代表执行状态。如果之前你没有接触过函数式编程的话，这个在初学时有困难是正常的。把例子多看两遍，自己编译、修改、把玩一下，就会渐渐理解的。</p><p>排除这个抽象性，模板的定义和 <code>If</code> 是类似的，虽然我们为方便使用，定义了两个模板。<code>WhileLoop</code> 模板有两个模板参数，同样用特化来决定走递归分支还是退出循环分支。<code>While</code> 模板则只需要循环体一个参数，方便使用。</p><p>如果你之前模板用得不多的话，还有一个需要了解的细节，就是用 <code>::</code> 取一个成员类型、并且 <code>::</code> 左边有模板参数的话，得额外加上 <code>typename</code> 关键字来标明结果是一个类型。上面循环模板的定义里就出现了多次这样的语法。MSVC 在这方面往往比较宽松，不写 <code>typename</code> 也不会报错，但这是不符合 C++ 标准的用法。</p><p>为了进行计算，我们还需要通用的代表数值的类型。下面这个模板可以通用地代表一个整数常数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;class T, T v&amp;gt;</span></span>
<span class="line"><span>struct integral_constant {</span></span>
<span class="line"><span>  static const T value = v;</span></span>
<span class="line"><span>  typedef T value_type;</span></span>
<span class="line"><span>  typedef integral_constant type;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>integral_constant</code> 模板同时包含了整数的类型和数值，而通过这个类型的 <code>value</code> 成员我们又可以重新取回这个数值。有了这个模板的帮忙，我们就可以进行一些更通用的计算了。下面这个模板展示了如何使用循环模板来完成从 1 加到 n 的计算：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;int result, int n&amp;gt;</span></span>
<span class="line"><span>struct SumLoop {</span></span>
<span class="line"><span>  static const bool cond_value =</span></span>
<span class="line"><span>    n != 0;</span></span>
<span class="line"><span>  static const int res_value =</span></span>
<span class="line"><span>    result;</span></span>
<span class="line"><span>  typedef integral_constant&amp;lt;</span></span>
<span class="line"><span>    int, res_value&amp;gt;</span></span>
<span class="line"><span>    res_type;</span></span>
<span class="line"><span>  typedef SumLoop&amp;lt;result + n, n - 1&amp;gt;</span></span>
<span class="line"><span>    next_type;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &amp;lt;int n&amp;gt;</span></span>
<span class="line"><span>struct Sum {</span></span>
<span class="line"><span>  typedef SumLoop&amp;lt;0, n&amp;gt; type;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你使用 <code>While&amp;lt;Sum&amp;lt;10&amp;gt;::type&amp;gt;::type::value</code> 就可以得到 1 加到 10 的结果。虽然有点绕，但代码实质就是在编译期间进行了以下的计算：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int result = 0;</span></span>
<span class="line"><span>while (n != 0) {</span></span>
<span class="line"><span>  result = result + n;</span></span>
<span class="line"><span>  n = n - 1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>估计现在你的头已经很晕了。但我保证，这一讲最难的部分已经过去了。实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。</p><h2 id="编译期类型推导" tabindex="-1"><a class="header-anchor" href="#编译期类型推导"><span>编译期类型推导</span></a></h2><p>C++ 标准库在 &lt;type_traits&gt; 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）[2]。和上一节给出的例子相似，这些特点既是类型，又是常值。</p><p>为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。上面描述的 <code>integral_constant</code> 就是其中一个（我的定义有所简化）。为了方便使用，针对布尔值有两个额外的类型定义：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef std::integral_constant&amp;lt;</span></span>
<span class="line"><span>  bool, true&amp;gt; true_type;</span></span>
<span class="line"><span>typedef std::integral_constant&amp;lt;</span></span>
<span class="line"><span>  bool, false&amp;gt; false_type;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个标准类型 <code>true_type</code> 和 <code>false_type</code> 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;typename T&amp;gt;</span></span>
<span class="line"><span>class SomeContainer {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>  …</span></span>
<span class="line"><span>  static void destroy(T* ptr)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    _destroy(ptr,</span></span>
<span class="line"><span>      is_trivially_destructible&amp;lt;</span></span>
<span class="line"><span>        T&amp;gt;());</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>  static void _destroy(T* ptr,</span></span>
<span class="line"><span>                       true_type)</span></span>
<span class="line"><span>  {}</span></span>
<span class="line"><span>  static void _destroy(T* ptr,</span></span>
<span class="line"><span>                       false_type)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    ptr-&amp;gt;~T();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似上面，很多容器类里会有一个 <code>destroy</code> 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 <code>is_trivially_destructible</code> 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 <code>true_type</code>，要么是 <code>false_type</code>。如果要得到布尔值的话，当然使用 <code>is_trivially_destructible&amp;lt;T&amp;gt;::value</code> 就可以，但此处不需要。我们需要的是，使用 <code>()</code> 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</p><p>像 <code>is_trivially_destructible</code> 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：</p><ul><li><code>is_array</code></li><li><code>is_enum</code></li><li><code>is_function</code></li><li><code>is_pointer</code></li><li><code>is_reference</code></li><li><code>is_const</code></li><li><code>has_virtual_destructor</code></li><li>…</li></ul><p>这些特殊行为判断可以是像上面这样用于决定不同的重载，也可以是直接用在模板参数甚至代码里（记得我们是可以直接得到布尔值的）。</p><p>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 <code>remove_const</code> 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;class T&amp;gt;</span></span>
<span class="line"><span>struct remove_const {</span></span>
<span class="line"><span>  typedef T type;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>template &amp;lt;class T&amp;gt;</span></span>
<span class="line"><span>struct remove_const&amp;lt;const T&amp;gt; {</span></span>
<span class="line"><span>  typedef T type;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对 <code>const string&amp;amp;</code> 应用 <code>remove_const</code>，就会得到 <code>string&amp;amp;</code>，即，<code>remove_const&amp;lt;const string&amp;amp;&amp;gt;::type</code> 等价于 <code>string&amp;amp;</code>。</p><p>这里有一个细节你要注意一下，如果对 <code>const char*</code> 应用 <code>remove_const</code> 的话，结果还是 <code>const char*</code>。原因是，<code>const char*</code> 是指向 <code>const char</code> 的指针，而不是指向 <code>char</code> 的 const 指针。如果我们对 <code>char * const</code> 应用 <code>remove_const</code> 的话，还是可以得到 <code>char*</code> 的。</p><h3 id="简易写法" tabindex="-1"><a class="header-anchor" href="#简易写法"><span>简易写法</span></a></h3><p>如果你觉得写 <code>is_trivially_destructible&amp;lt;T&amp;gt;::value</code> 和 <code>remove_const&amp;lt;T&amp;gt;::type</code> 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，前者有增加 <code>_v</code> 的编译时常量，后者有增加 <code>_t</code> 的类型别名：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;class T&amp;gt;</span></span>
<span class="line"><span>inline constexpr bool</span></span>
<span class="line"><span>  is_trivially_destructible_v =</span></span>
<span class="line"><span>    is_trivially_destructible&amp;lt;</span></span>
<span class="line"><span>      T&amp;gt;::value;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;class T&amp;gt;</span></span>
<span class="line"><span>using remove_const_t =</span></span>
<span class="line"><span>  typename remove_const&amp;lt;T&amp;gt;::type;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于什么是 <code>constexpr</code>，我们会单独讲。<code>using</code> 是现代 C++ 的新语法，功能大致与 <code>typedef</code> 相似，但 <code>typedef</code> 只能针对某个特定的类型，而 <code>using</code> 可以生成别名模板。目前我们只需要知道，在你需要 trait 模板的结果数值和类型时，使用带 <code>_v</code> 和 <code>_t</code> 后缀的模板可能会更方便，尤其是带 <code>_t</code> 后缀的类型转换模板。</p><h2 id="通用的-fmap-函数模板" tabindex="-1"><a class="header-anchor" href="#通用的-fmap-函数模板"><span>通用的 fmap 函数模板</span></a></h2><p>你应当多多少少听到过 map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map [3] 和 reduce [4] 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 <code>map</code> 了），其中用到了目前为止我们学到的多个知识点：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>template &amp;lt;</span></span>
<span class="line"><span>  template &amp;lt;typename, typename&amp;gt;</span></span>
<span class="line"><span>  class OutContainer = vector,</span></span>
<span class="line"><span>  typename F, class R&amp;gt;</span></span>
<span class="line"><span>auto fmap(F&amp;amp;&amp;amp; f, R&amp;amp;&amp;amp; inputs)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  typedef decay_t&amp;lt;decltype(</span></span>
<span class="line"><span>    f(*inputs.begin()))&amp;gt;</span></span>
<span class="line"><span>    result_type;</span></span>
<span class="line"><span>  OutContainer&amp;lt;</span></span>
<span class="line"><span>    result_type,</span></span>
<span class="line"><span>    allocator&amp;lt;result_type&amp;gt;&amp;gt;</span></span>
<span class="line"><span>    result;</span></span>
<span class="line"><span>  for (auto&amp;amp;&amp;amp; item : inputs) {</span></span>
<span class="line"><span>    result.push_back(f(item));</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们：</p><ul><li>用 <code>decltype</code> 来获得用 <code>f</code> 来调用 <code>inputs</code> 元素的类型（参考<a href="https://time.geekbang.org/column/article/176850" target="_blank" rel="noopener noreferrer">[第 8 讲]</a>）；</li><li>用 <code>decay_t</code> 来把获得的类型变成一个普通的值类型；</li><li>缺省使用 <code>vector</code> 作为返回值的容器，但可以通过模板参数改为其他容器；</li><li>使用基于范围的 for 循环来遍历 <code>inputs</code>，对其类型不作其他要求（参考<a href="https://time.geekbang.org/column/article/176842" target="_blank" rel="noopener noreferrer">[第 7 讲]</a>）；</li><li>存放结果的容器需要支持 <code>push_back</code> 成员函数（参考<a href="https://time.geekbang.org/column/article/173167" target="_blank" rel="noopener noreferrer">[第 4 讲]</a>）。</li></ul><p>下面的代码可以验证其功能：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>vector&amp;lt;int&amp;gt; v{1, 2, 3, 4, 5};</span></span>
<span class="line"><span>int add_1(int x)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    return x + 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>auto result = fmap(add_1, v);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>fmap</code> 执行之后，我们会在 <code>result</code> 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p><h2 id="内容小结" tabindex="-1"><a class="header-anchor" href="#内容小结"><span>内容小结</span></a></h2><p>本讲我们介绍了模板元编程的基本概念和例子，其本质是<strong>把计算过程用编译期的类型推导和类型匹配表达出来</strong>；然后介绍 type traits 及其基本用法；最后我们演示了一个简单的高阶函数 map，其实现中用到了我们目前已经讨论过的一些知识点。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考"><span>课后思考</span></a></h2><p>这一讲的内容可能有点烧脑，请你自行实验一下例子，并找一两个简单的算法用模板元编程的方法实现一下，看看能不能写出来。</p><p>如果有什么特别想法的话，欢迎留言和我分享交流。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>[1] Todd L. Veldhuizen, “C++ templates are Turing complete”. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670" target="_blank" rel="noopener noreferrer">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a></p><p>[2] <a href="http://cppreference.com" target="_blank" rel="noopener noreferrer">cppreference.com</a>, “Standard library header &lt;type_traits&gt;”. <a href="https://en.cppreference.com/w/cpp/header/type_traits" target="_blank" rel="noopener noreferrer">https://en.cppreference.com/w/cpp/header/type_traits</a></p><p>[2a] <a href="http://cppreference.com" target="_blank" rel="noopener noreferrer">cppreference.com</a>, “标准库头文件 &lt;type_traits&gt;”. <a href="https://zh.cppreference.com/w/cpp/header/type_traits" target="_blank" rel="noopener noreferrer">https://zh.cppreference.com/w/cpp/header/type_traits</a></p><p>[3] Wikipedia, “Map (higher-order function)”. <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Map_(higher-order_function)</a></p><p>[4] Wikipedia, “Fold (higher-order function)”. <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a></p>`,78)]))}const r=n(p,[["render",l]]),o=JSON.parse('{"path":"/posts/%E7%8E%B0%E4%BB%A3C__%E5%AE%9E%E6%88%9830%E8%AE%B2/%E6%8F%90%E9%AB%98%E7%AF%87/13%20_%20%E7%BC%96%E8%AF%91%E6%9C%9F%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%96%E7%95%8C.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是吴咏炜。 上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。 编译期计算 首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 [1]。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。 当然...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E7%8E%B0%E4%BB%A3C__%E5%AE%9E%E6%88%9830%E8%AE%B2/%E6%8F%90%E9%AB%98%E7%AF%87/13%20_%20%E7%BC%96%E8%AF%91%E6%9C%9F%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%A1%E7%AE%97%E4%B8%96%E7%95%8C.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是吴咏炜。 上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。 编译期计算 首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 [1]。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。 当然..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":11.65,"words":3494},"filePathRelative":"posts/现代C++实战30讲/提高篇/13 _ 编译期能做些什么？一个完整的计算世界.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"13 | 编译期能做些什么？一个完整的计算世界\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/81/00/81fcf04cc42e895037ddd0d01faab000.mp3\\"></audio></p>\\n<p>你好，我是吴咏炜。</p>\\n<p>上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。</p>\\n<h2>编译期计算</h2>","autoDesc":true}');export{r as comp,o as data};

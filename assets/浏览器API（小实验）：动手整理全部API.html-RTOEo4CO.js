import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a,o as n}from"./app-6Bz2fGO5.js";const i={};function s(r,e){return n(),o("div",null,e[0]||(e[0]=[a(`<p><audio id="audio" title="浏览器API（小实验）：动手整理全部API" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/4b/d9/4bb664d6fefed17357265cd64b824cd9.mp3"></audio></p><p>你好，我是winter。今天我们来讲讲浏览器API。</p><p>浏览器的API数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的DOM和CSSOM等等。但是，如果你留意过，会发现我们讲到的API仍然是标准中非常小的一部分。</p><p>这里，我们不可能把课程变成一本厚厚的API参考手册，所以这一节课，我设计了一个实验，我们一起来给API分分类。</p><p>我们按照每个API所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用JavaScript的filter方法来逐步过滤掉已知的属性。</p><p>接下来，我们整理API的方法如下：</p><ul><li>从Window的属性中，找到API名称；</li><li>查阅MDN或者Google，找到API所在的标准；</li><li>阅读标准，手工或者用代码整理出标准中包含的API；</li><li>用代码在Window的属性中过滤掉标准中涉及的API。</li></ul><p>重复这个过程，我们可以找到所有的API对应的标准。首先我们先把前面已经讲过的API过滤掉。</p><p>##JavaScript中规定的API</p><p>大部分的API属于Window对象（或者说全局对象），我们可以用反射来看一看现行浏览器中已经实现的API，我这里使用Mac下的Chrome 72.0.3626.121版本。</p><p>我们首先调用 Object.getOwnPropertyNames(window)。在我的环境中，可以看到，共有821个属性。</p><p>这里包含了JavaScript标准规定的属性，我们做一下过滤：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    let js = new Set();</span></span>
<span class="line"><span>    let objects = [&quot;BigInt&quot;, &quot;BigInt64Array&quot;, &quot;BigUint64Array&quot;, &quot;Infinity&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;eval&quot;, &quot;isFinite&quot;, &quot;isNaN&quot;, &quot;parseFloat&quot;, &quot;parseInt&quot;, &quot;decodeURI&quot;, &quot;decodeURIComponent&quot;, &quot;encodeURI&quot;, &quot;encodeURIComponent&quot;, &quot;Array&quot;, &quot;Date&quot;, &quot;RegExp&quot;, &quot;Promise&quot;, &quot;Proxy&quot;, &quot;Map&quot;, &quot;WeakMap&quot;, &quot;Set&quot;, &quot;WeakSet&quot;, &quot;Function&quot;, &quot;Boolean&quot;, &quot;String&quot;, &quot;Number&quot;, &quot;Symbol&quot;, &quot;Object&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;RangeError&quot;, &quot;ReferenceError&quot;, &quot;SyntaxError&quot;, &quot;TypeError&quot;, &quot;URIError&quot;, &quot;ArrayBuffer&quot;, &quot;SharedArrayBuffer&quot;, &quot;DataView&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;, &quot;Int8Array&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8ClampedArray&quot;, &quot;Atomics&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Reflect&quot;, &quot;escape&quot;, &quot;unescape&quot;];</span></span>
<span class="line"><span>    objects.forEach(o =&amp;gt; js.add(o));</span></span>
<span class="line"><span>    let names = Object.getOwnPropertyNames(window)</span></span>
<span class="line"><span>    names = names.filter(e =&amp;gt; !js.has(e));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一部分我们已经在JavaScript部分讲解过了（JavaScript对象：你知道全部的对象分类吗），所以这里我就采用手工的方式过滤出来。</p><h2 id="dom中的元素构造器" tabindex="-1"><a class="header-anchor" href="#dom中的元素构造器"><span>DOM中的元素构造器</span></a></h2><p>接下来我们看看已经讲过的DOM部分，DOM部分包含了document属性和一系列的构造器，我们可以用JavaScript的prototype来过滤构造器。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    names = names.filter( e =&amp;gt; {</span></span>
<span class="line"><span>        try { </span></span>
<span class="line"><span>            return !(window[e].prototype instanceof Node)</span></span>
<span class="line"><span>        } catch(err) {</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }).filter( e =&amp;gt; e != &quot;Node&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们把所有Node的子类都过滤掉，再把Node本身也过滤掉，这是非常大的一批了。</p><h2 id="window对象上的属性" tabindex="-1"><a class="header-anchor" href="#window对象上的属性"><span>Window对象上的属性</span></a></h2><p>接下来我们要找到Window对象的定义，我们在下面链接中可以找到。</p><ul><li><a href="https://html.spec.whatwg.org/#window" target="_blank" rel="noopener noreferrer">https://html.spec.whatwg.org/#window</a></li></ul><p>这里有一个Window接口，是使用WebIDL定义的，我们手工把其中的函数和属性整理出来，如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span> window,self,document,name,location,history,customElements,locationbar,menubar, personalbar,scrollbars,statusbar,toolbar,status,close,closed,stop,focus, blur,frames,length,top,opener,parent,frameElement,open,navigator,applicationCache,alert,confirm,prompt,print,postMessage</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们编写代码，把这些函数和属性，从浏览器Window对象的属性中去掉，JavaScript代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    let names = Object.getOwnPropertyNames(window)</span></span>
<span class="line"><span>    let js = new Set();</span></span>
<span class="line"><span>    let objects = [&quot;BigInt&quot;, &quot;BigInt64Array&quot;, &quot;BigUint64Array&quot;, &quot;Infinity&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;eval&quot;, &quot;isFinite&quot;, &quot;isNaN&quot;, &quot;parseFloat&quot;, &quot;parseInt&quot;, &quot;decodeURI&quot;, &quot;decodeURIComponent&quot;, &quot;encodeURI&quot;, &quot;encodeURIComponent&quot;, &quot;Array&quot;, &quot;Date&quot;, &quot;RegExp&quot;, &quot;Promise&quot;, &quot;Proxy&quot;, &quot;Map&quot;, &quot;WeakMap&quot;, &quot;Set&quot;, &quot;WeakSet&quot;, &quot;Function&quot;, &quot;Boolean&quot;, &quot;String&quot;, &quot;Number&quot;, &quot;Symbol&quot;, &quot;Object&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;RangeError&quot;, &quot;ReferenceError&quot;, &quot;SyntaxError&quot;, &quot;TypeError&quot;, &quot;URIError&quot;, &quot;ArrayBuffer&quot;, &quot;SharedArrayBuffer&quot;, &quot;DataView&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;, &quot;Int8Array&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8ClampedArray&quot;, &quot;Atomics&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Reflect&quot;, &quot;escape&quot;, &quot;unescape&quot;];</span></span>
<span class="line"><span>    objects.forEach(o =&amp;gt; js.add(o));</span></span>
<span class="line"><span>    names = names.filter(e =&amp;gt; !js.has(e));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    names = names.filter( e =&amp;gt; {</span></span>
<span class="line"><span>        try { </span></span>
<span class="line"><span>            return !(window[e].prototype instanceof Node)</span></span>
<span class="line"><span>        } catch(err) {</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }).filter( e =&amp;gt; e != &quot;Node&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let windowprops = new Set();</span></span>
<span class="line"><span>    objects = [&quot;window&quot;, &quot;self&quot;, &quot;document&quot;, &quot;name&quot;, &quot;location&quot;, &quot;history&quot;, &quot;customElements&quot;, &quot;locationbar&quot;, &quot;menubar&quot;, &quot; personalbar&quot;, &quot;scrollbars&quot;, &quot;statusbar&quot;, &quot;toolbar&quot;, &quot;status&quot;, &quot;close&quot;, &quot;closed&quot;, &quot;stop&quot;, &quot;focus&quot;, &quot; blur&quot;, &quot;frames&quot;, &quot;length&quot;, &quot;top&quot;, &quot;opener&quot;, &quot;parent&quot;, &quot;frameElement&quot;, &quot;open&quot;, &quot;navigator&quot;, &quot;applicationCache&quot;, &quot;alert&quot;, &quot;confirm&quot;, &quot;prompt&quot;, &quot;print&quot;, &quot;postMessage&quot;, &quot;console&quot;];</span></span>
<span class="line"><span>    objects.forEach(o =&amp;gt; windowprops.add(o));</span></span>
<span class="line"><span>    names = names.filter(e =&amp;gt; !windowprops.has(e));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还要过滤掉所有的事件，也就是on开头的属性。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = names.filter( e =&amp;gt; !e.match(/^on/))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>webkit前缀的私有属性我们也过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = names.filter( e =&amp;gt; !e.match(/^webkit/))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>除此之外，我们在HTML标准中还能找到所有的接口，这些我们也过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>    let interfaces = new Set();</span></span>
<span class="line"><span>    objects = [&quot;ApplicationCache&quot;, &quot;AudioTrack&quot;, &quot;AudioTrackList&quot;, &quot;BarProp&quot;, &quot;BeforeUnloadEvent&quot;, &quot;BroadcastChannel&quot;, &quot;CanvasGradient&quot;, &quot;CanvasPattern&quot;, &quot;CanvasRenderingContext2D&quot;, &quot;CloseEvent&quot;, &quot;CustomElementRegistry&quot;, &quot;DOMStringList&quot;, &quot;DOMStringMap&quot;, &quot;DataTransfer&quot;, &quot;DataTransferItem&quot;, &quot;DataTransferItemList&quot;, &quot;DedicatedWorkerGlobalScope&quot;, &quot;Document&quot;, &quot;DragEvent&quot;, &quot;ErrorEvent&quot;, &quot;EventSource&quot;, &quot;External&quot;, &quot;FormDataEvent&quot;, &quot;HTMLAllCollection&quot;, &quot;HashChangeEvent&quot;, &quot;History&quot;, &quot;ImageBitmap&quot;, &quot;ImageBitmapRenderingContext&quot;, &quot;ImageData&quot;, &quot;Location&quot;, &quot;MediaError&quot;, &quot;MessageChannel&quot;, &quot;MessageEvent&quot;, &quot;MessagePort&quot;, &quot;MimeType&quot;, &quot;MimeTypeArray&quot;, &quot;Navigator&quot;, &quot;OffscreenCanvas&quot;, &quot;OffscreenCanvasRenderingContext2D&quot;, &quot;PageTransitionEvent&quot;, &quot;Path2D&quot;, &quot;Plugin&quot;, &quot;PluginArray&quot;, &quot;PopStateEvent&quot;, &quot;PromiseRejectionEvent&quot;, &quot;RadioNodeList&quot;, &quot;SharedWorker&quot;, &quot;SharedWorkerGlobalScope&quot;, &quot;Storage&quot;, &quot;StorageEvent&quot;, &quot;TextMetrics&quot;, &quot;TextTrack&quot;, &quot;TextTrackCue&quot;, &quot;TextTrackCueList&quot;, &quot;TextTrackList&quot;, &quot;TimeRanges&quot;, &quot;TrackEvent&quot;, &quot;ValidityState&quot;, &quot;VideoTrack&quot;, &quot;VideoTrackList&quot;, &quot;WebSocket&quot;, &quot;Window&quot;, &quot;Worker&quot;, &quot;WorkerGlobalScope&quot;, &quot;WorkerLocation&quot;, &quot;WorkerNavigator&quot;];</span></span>
<span class="line"><span>    objects.forEach(o =&amp;gt; interfaces.add(o));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    names = names.filter(e =&amp;gt; !interfaces.has(e));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样过滤之后，我们已经过滤掉了所有的事件、Window对象、JavaScript全局对象和DOM相关的属性，但是，竟然还剩余了很多属性！你是不是很惊讶呢？好了，接下来我们才进入今天的正题。</p><h2 id="其它属性" tabindex="-1"><a class="header-anchor" href="#其它属性"><span>其它属性</span></a></h2><p>这些既不属于Window对象，又不属于JavaScript语言的Global对象的属性，它们究竟是什么呢？</p><p>我们可以一个一个来查看这些属性，来发现一些我们以前没有关注过的标准。</p><p>首先，我们要把过滤的代码做一下抽象，写成一个函数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function filterOut(names, props) {</span></span>
<span class="line"><span>    let set = new Set();</span></span>
<span class="line"><span>    props.forEach(o =&amp;gt; set.add(o));</span></span>
<span class="line"><span>    return names.filter(e =&amp;gt; !set.has(e));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每次执行完filter函数，都会剩下一些属性，接下来，我们找到剩下的属性来看一看。</p><h3 id="ecmascript-2018-internationalization-api" tabindex="-1"><a class="header-anchor" href="#ecmascript-2018-internationalization-api"><span>ECMAScript 2018 Internationalization API</span></a></h3><p>在我的浏览器环境中，第一个属性是：Intl。</p><p>查找这些属性来历的最佳文档是MDN，当然，你也可以使用Google。</p><p>总之，经过查阅，我发现，它属于ECMA402标准，这份标准是JavaScript的一个扩展，它包含了国际化相关的内容：</p><ul><li><a href="http://www.ecma-international.org/ecma-402/5.0/index.html#Title" target="_blank" rel="noopener noreferrer">http://www.ecma-international.org/ecma-402/5.0/index.html#Title</a></li></ul><p>ECMA402中，只有一个全局属性Intl，我们也把它过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = names.filter(e =&amp;gt; e != &quot;Intl&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>再来看看还有什么属性。</p><h3 id="streams标准" tabindex="-1"><a class="header-anchor" href="#streams标准"><span>Streams标准</span></a></h3><p>接下来我看到的属性是： ByteLengthQueuingStrategy。</p><p>同样经过查阅，它来自WHATWG的Streams标准：<br><br><a href="https://streams.spec.whatwg.org/#blqs-class" target="_blank" rel="noopener noreferrer">https://streams.spec.whatwg.org/#blqs-class</a></p><p>不过，跟ECMA402不同，Streams标准中还有一些其它属性，这里我手工查阅了这份标准，并做了整理。</p><p>接下来，我们用代码把它们跟 ByteLengthQueuingStrategy 一起过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = filterOut(names, [&quot;ReadableStream&quot;, &quot;ReadableStreamDefaultReader&quot;, &quot;ReadableStreamBYOBReader&quot;, &quot;ReadableStreamDefaultController&quot;, &quot;ReadableByteStreamController&quot;, &quot;ReadableStreamBYOBRequest&quot;, &quot;WritableStream&quot;, &quot;WritableStreamDefaultWriter&quot;, &quot;WritableStreamDefaultController&quot;, &quot;TransformStream&quot;, &quot;TransformStreamDefaultController&quot;, &quot;ByteLengthQueuingStrategy&quot;, &quot;CountQueuingStrategy&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>好了，过滤之后，又少了一些属性，我们继续往下看。</p><h3 id="webgl" tabindex="-1"><a class="header-anchor" href="#webgl"><span>WebGL</span></a></h3><p>接下来我看到的属性是：WebGLContext​Event。</p><p>显然，这个属性来自WebGL标准：</p><ul><li><a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15" target="_blank" rel="noopener noreferrer">https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15</a></li></ul><p>我们在这份标准中找到了一些别的属性，我们把它一起过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = filterOut(names, [&quot;WebGLContextEvent&quot;,&quot;WebGLObject&quot;, &quot;WebGLBuffer&quot;, &quot;WebGLFramebuffer&quot;, &quot;WebGLProgram&quot;, &quot;WebGLRenderbuffer&quot;, &quot;WebGLShader&quot;, &quot;WebGLTexture&quot;, &quot;WebGLUniformLocation&quot;, &quot;WebGLActiveInfo&quot;, &quot;WebGLShaderPrecisionFormat&quot;, &quot;WebGLRenderingContext&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>过滤掉WebGL，我们继续往下看。</p><h3 id="web-audio-api" tabindex="-1"><a class="header-anchor" href="#web-audio-api"><span>Web Audio API</span></a></h3><p>下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自W3C的Web Audio API标准。</p><p>我们来看一下标准：</p><ul><li><a href="https://www.w3.org/TR/webaudio/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/webaudio/</a></li></ul><p>Web Audio API中有大量的属性，这里我用代码做了过滤。得到了以下列表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&amp;quot;AudioContext&amp;quot;, &amp;quot;AudioNode&amp;quot;, &amp;quot;AnalyserNode&amp;quot;, &amp;quot;AudioBuffer&amp;quot;, &amp;quot;AudioBufferSourceNode&amp;quot;, &amp;quot;AudioDestinationNode&amp;quot;, &amp;quot;AudioParam&amp;quot;, &amp;quot;AudioListener&amp;quot;, &amp;quot;AudioWorklet&amp;quot;, &amp;quot;AudioWorkletGlobalScope&amp;quot;, &amp;quot;AudioWorkletNode&amp;quot;, &amp;quot;AudioWorkletProcessor&amp;quot;, &amp;quot;BiquadFilterNode&amp;quot;, &amp;quot;ChannelMergerNode&amp;quot;, &amp;quot;ChannelSplitterNode&amp;quot;, &amp;quot;ConstantSourceNode&amp;quot;, &amp;quot;ConvolverNode&amp;quot;, &amp;quot;DelayNode&amp;quot;, &amp;quot;DynamicsCompressorNode&amp;quot;, &amp;quot;GainNode&amp;quot;, &amp;quot;IIRFilterNode&amp;quot;, &amp;quot;MediaElementAudioSourceNode&amp;quot;, &amp;quot;MediaStreamAudioSourceNode&amp;quot;, &amp;quot;MediaStreamTrackAudioSourceNode&amp;quot;, &amp;quot;MediaStreamAudioDestinationNode&amp;quot;, &amp;quot;PannerNode&amp;quot;, &amp;quot;PeriodicWave&amp;quot;, &amp;quot;OscillatorNode&amp;quot;, &amp;quot;StereoPannerNode&amp;quot;, &amp;quot;WaveShaperNode&amp;quot;, &amp;quot;ScriptProcessorNode&amp;quot;, &amp;quot;AudioProcessingEvent&amp;quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>于是我们把它们也过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>names = filterOut(names, [&quot;AudioContext&quot;, &quot;AudioNode&quot;, &quot;AnalyserNode&quot;, &quot;AudioBuffer&quot;, &quot;AudioBufferSourceNode&quot;, &quot;AudioDestinationNode&quot;, &quot;AudioParam&quot;, &quot;AudioListener&quot;, &quot;AudioWorklet&quot;, &quot;AudioWorkletGlobalScope&quot;, &quot;AudioWorkletNode&quot;, &quot;AudioWorkletProcessor&quot;, &quot;BiquadFilterNode&quot;, &quot;ChannelMergerNode&quot;, &quot;ChannelSplitterNode&quot;, &quot;ConstantSourceNode&quot;, &quot;ConvolverNode&quot;, &quot;DelayNode&quot;, &quot;DynamicsCompressorNode&quot;, &quot;GainNode&quot;, &quot;IIRFilterNode&quot;, &quot;MediaElementAudioSourceNode&quot;, &quot;MediaStreamAudioSourceNode&quot;, &quot;MediaStreamTrackAudioSourceNode&quot;, &quot;MediaStreamAudioDestinationNode&quot;, &quot;PannerNode&quot;, &quot;PeriodicWave&quot;, &quot;OscillatorNode&quot;, &quot;StereoPannerNode&quot;, &quot;WaveShaperNode&quot;, &quot;ScriptProcessorNode&quot;, &quot;AudioProcessingEvent&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们继续看下一个属性。</p><h3 id="encoding标准" tabindex="-1"><a class="header-anchor" href="#encoding标准"><span>Encoding标准</span></a></h3><p>在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份WHATWG的标准，Encoding：</p><ul><li><a href="https://encoding.spec.whatwg.org/#dom-textencoder" target="_blank" rel="noopener noreferrer">https://encoding.spec.whatwg.org/#dom-textencoder</a></li></ul><p>这份标准仅仅包含四个接口，我们把它们过滤掉：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = filterOut(names, [&quot;TextDecoder&quot;, &quot;TextEncoder&quot;, &quot;TextDecoderStream&quot;, &quot;TextEncoderStream&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们继续来看下一个属性。</p><h3 id="web-background-synchronization" tabindex="-1"><a class="header-anchor" href="#web-background-synchronization"><span>Web Background Synchronization</span></a></h3><p>下一个属性是 SyncManager，这个属性比较特殊，它并没有被标准化，但是我们仍然可以找到它的来源文档：</p><ul><li><a href="https://wicg.github.io/BackgroundSync/spec/#sync-manager-interface" target="_blank" rel="noopener noreferrer">https://wicg.github.io/BackgroundSync/spec/#sync-manager-interface</a></li></ul><p>这个属性我们就不多说了，过滤掉就好了。</p><h3 id="web-cryptography-api" tabindex="-1"><a class="header-anchor" href="#web-cryptography-api"><span>Web Cryptography API</span></a></h3><p>我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自Web Cryptography API，也是W3C的标准。</p><ul><li><a href="https://www.w3.org/TR/WebCryptoAPI/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/WebCryptoAPI/</a></li></ul><p>这份标准中规定了三个Class和一个Window对象的扩展，给Window对象添加了一个属性crypto。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = filterOut(names, [&quot;CryptoKey&quot;, &quot;SubtleCrypto&quot;, &quot;Crypto&quot;, &quot;crypto&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们继续来看。</p><h3 id="media-source-extensions" tabindex="-1"><a class="header-anchor" href="#media-source-extensions"><span>Media Source Extensions</span></a></h3><p>下一个属性是 SourceBufferList，它来自于：</p><ul><li><a href="https://www.w3.org/TR/media-source/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/media-source/</a></li></ul><p>这份标准中包含了三个接口，这份标准还扩展了一些接口，但是没有扩展window。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>names = filterOut(names, [&quot;MediaSource&quot;, &quot;SourceBuffer&quot;, &quot;SourceBufferList&quot;]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们继续看下一个属性。</p><h3 id="the-screen-orientation-api" tabindex="-1"><a class="header-anchor" href="#the-screen-orientation-api"><span>The Screen Orientation API</span></a></h3><p>下一个属性是ScreenOrientation，它来自W3C的The Screen Orientation API标准：</p><ul><li><a href="https://www.w3.org/TR/screen-orientation/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/screen-orientation/</a></li></ul><p>它里面只有ScreenOrientation一个接口，也是可以过滤掉的。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>到 Screen Orientation API，我这里看到还剩300余个属性没有处理，剩余部分，我想把它留给大家自己来完成。</p><p>我们可以看到，在整理API的过程中，我们可以找到各种不同组织的标准，比如：</p><ul><li>ECMA402标准来自 ECMA；</li><li>Encoding标准来自WHATWG；</li><li>WebGL标准来自 Khronos；</li><li>Web Cryptography标准来自 W3C；</li><li>还有些API，根本没有被标准化。</li></ul><p>浏览器环境的API，正是这样复杂的环境。我们平时编程面对的环境也是这样的一个环境。</p><p>所以，面对如此繁复的API，我建议在系统掌握DOM、CSSOM的基础上，你可以仅仅做大概的浏览和记忆，根据实际工作需要，选择其中几个来深入学习。</p><p>做完这个实验，你对Web API的理解应该会有很大提升。</p><p>这一节课的问题就是完成所有的API到标准的归类，不同的浏览器环境应该略有不同，欢迎你把自己的结果留言一起讨论。</p>`,103)]))}const l=t(i,[["render",s]]),d=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAPI/%E6%B5%8F%E8%A7%88%E5%99%A8API%EF%BC%88%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%89%8B%E6%95%B4%E7%90%86%E5%85%A8%E9%83%A8API.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是winter。今天我们来讲讲浏览器API。 浏览器的API数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的DOM和CSSOM等等。但是，如果你留意过，会发现我们讲到的API仍然是标准中非常小的一部分。 这里，我们不可能把课程变成一本厚厚的API参考手册，所以这一节课，我设计了一个实验，我们一起来给API分...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAPI/%E6%B5%8F%E8%A7%88%E5%99%A8API%EF%BC%88%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%89%8B%E6%95%B4%E7%90%86%E5%85%A8%E9%83%A8API.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是winter。今天我们来讲讲浏览器API。 浏览器的API数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的DOM和CSSOM等等。但是，如果你留意过，会发现我们讲到的API仍然是标准中非常小的一部分。 这里，我们不可能把课程变成一本厚厚的API参考手册，所以这一节课，我设计了一个实验，我们一起来给API分..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":8.37,"words":2511},"filePathRelative":"posts/重学前端/模块三：浏览器实现原理与API/浏览器API（小实验）：动手整理全部API.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"浏览器API（小实验）：动手整理全部API\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/4b/d9/4bb664d6fefed17357265cd64b824cd9.mp3\\"></audio></p>\\n<p>你好，我是winter。今天我们来讲讲浏览器API。</p>\\n<p>浏览器的API数目繁多，我们在之前的课程中，已经一起学习了其中几个比较有体系的部分：比如之前讲到过的DOM和CSSOM等等。但是，如果你留意过，会发现我们讲到的API仍然是标准中非常小的一部分。</p>","autoDesc":true}');export{l as comp,d as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as e}from"./app-6Bz2fGO5.js";const p={};function l(d,s){return e(),a("div",null,s[0]||(s[0]=[i(`<p><audio id="audio" title="JavaScript执行（三）：你知道现在有多少种函数吗？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/00/18/0093381651a5e580a13209cc6d07c918.mp3"></audio></p><p>在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。</p><p>一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。</p><p>在JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。</p><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><p>在ES2018中，函数已经是一个很复杂的体系了，我在这里整理了一下。</p><p><strong>第一种，普通函数：用function关键字定义的函数。</strong></p><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function foo(){</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二种，箭头函数：用 =&gt; 运算符定义的函数。</strong></p><p>示例:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const foo = () =&amp;gt; {</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第三种，方法：在class中定义的函数。</strong></p><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class C {</span></span>
<span class="line"><span>    foo(){</span></span>
<span class="line"><span>        //code</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第四种，生成器函数：用function * 定义的函数。</strong></p><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function* foo(){</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第五种，类：用class定义的类，实际上也是函数。</strong></p><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Foo {</span></span>
<span class="line"><span>    constructor(){</span></span>
<span class="line"><span>        //code</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第六/七/八种，异步函数：普通函数、箭头函数和生成器函数加上async关键字。</strong></p><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>async function foo(){</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>const foo = async () =&amp;gt; {</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>async function foo*(){</span></span>
<span class="line"><span>    // code</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES6以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。</p><p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于this关键字。</p><p>那么，this关键字是什么呢，我们一起来看一看。</p><h2 id="this关键字的行为" tabindex="-1"><a class="header-anchor" href="#this关键字的行为"><span>this关键字的行为</span></a></h2><p>this是JavaScript中的一个关键字，它的使用方法类似于一个变量（但是this跟变量的行为有很多不同，上一节课我们讲了一些普通变量的行为和机制，也就是var声明和赋值、let的内容）。</p><p><strong>this是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的this值也不同</strong>，我们看一个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function showThis(){</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var o = {</span></span>
<span class="line"><span>    showThis: showThis</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>showThis(); // global</span></span>
<span class="line"><span>o.showThis(); // o</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了函数showThis，我们把它赋值给一个对象o的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的this值。</p><p>普通函数的this值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个Reference类型（记得我们在类型一章讲过七种标准类型吗，正是其中之一）。</p><p>Reference类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的Reference类型，即由对象o和属性“showThis”构成。</p><p>当做一些算术运算（或者其他运算时），Reference类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete等操作，都需要用到Reference类型中的对象。</p><p>在这个例子中，Reference类型中的对象被当作this值，传入了执行函数时的上下文当中。</p><p>至此，我们对this的解释已经非常清晰了：<strong>调用函数时使用的引用，决定了函数执行时刻的this值。</strong></p><p>实际上从运行时的角度来看，this跟面向对象毫无关联，它是与函数调用时使用的表达式相关。</p><p>这个设计来自JavaScript早年，通过这样的方式，巧妙地模仿了Java的语法，但是仍然保持了纯粹的“无类”运行时设施。</p><p>如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const showThis = () =&amp;gt; {</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var o = {</span></span>
<span class="line"><span>    showThis: showThis</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>showThis(); // global</span></span>
<span class="line"><span>o.showThis(); // global</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>我们看到，改为箭头函数后，不论用什么引用来调用它，都不影响它的this值。</strong></p><p>接下来我们看看“方法”，它的行为又不一样了：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class C {</span></span>
<span class="line"><span>    showThis() {</span></span>
<span class="line"><span>        console.log(this);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var o = new C();</span></span>
<span class="line"><span>var showThis = o.showThis;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>showThis(); // undefined</span></span>
<span class="line"><span>o.showThis(); // o</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们创建了一个类C，并且实例化出对象o，再把o的方法赋值给了变量showThis。</p><p>这时候，我们使用showThis这个引用去调用方法时，得到了undefined。</p><p>所以，在方法中，我们看到this的行为也不太一样，它得到了undefined的结果。</p><p>按照我们上面的方法，不难验证出：生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。</p><h2 id="this关键字的机制" tabindex="-1"><a class="header-anchor" href="#this关键字的机制"><span>this关键字的机制</span></a></h2><p>说完了this行为，我们再来简单谈谈在JavaScript内部，实现this这些行为的机制，让你对这部分知识有一个大概的认知。</p><p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的this，因此，函数内部必定有一个机制来保存这些信息。</p><p>在JavaScript标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。</p><p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p><p>这个动作就是<strong>切换上下文</strong>了，我们假设有这样的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var a = 1;</span></span>
<span class="line"><span>foo();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在别处定义了foo：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var b = 2;</span></span>
<span class="line"><span>function foo(){</span></span>
<span class="line"><span>    console.log(b); // 2</span></span>
<span class="line"><span>    console.log(a); // error</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的foo能够访问b（定义时词法环境），却不能访问a（执行时的词法环境），这就是执行上下文的切换机制了。</p><p>JavaScript用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：</p><img src="https://static001.geekbang.org/resource/image/e8/31/e8d8e96c983a832eb646d6c17ff3df31.jpg" alt=""><p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。</p><p>而this则是一个更为复杂的机制，JavaScript标准定义了 [[thisMode]] 私有属性。</p><p>[[thisMode]] 私有属性有三个取值。</p><ul><li>lexical：表示从上下文中找this，这对应了箭头函数。</li><li>global：表示当this为undefined时，取全局对象，对应了普通函数。</li><li>strict：当严格模式时使用，this严格按照调用时传入的值，可能为null或者undefined。</li></ul><p>非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为class设计成了默认按strict模式执行。</p><p>我们可以用strict达成与上一节中方法的例子一样的效果:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;quot;use strict&amp;quot;</span></span>
<span class="line"><span>function showThis(){</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var o = {</span></span>
<span class="line"><span>    showThis: showThis</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>showThis(); // undefined</span></span>
<span class="line"><span>o.showThis(); // o</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。</p><p>代码执行遇到this时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有this的环境记录时获取this的值。</p><p>这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层this，例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var o = {}</span></span>
<span class="line"><span>o.foo = function foo(){</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>    return () =&amp;gt; {</span></span>
<span class="line"><span>        console.log(this);</span></span>
<span class="line"><span>        return () =&amp;gt; console.log(this);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>o.foo()()(); // o, o, o</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。</p><p>这里调用三个函数，获得的this值是一致的，都是对象o。</p><p>JavaScript还提供了一系列函数的内置方法来操纵this值，下面我们来了解一下。</p><h2 id="操作this的内置函数" tabindex="-1"><a class="header-anchor" href="#操作this的内置函数"><span>操作this的内置函数</span></a></h2><p>Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的this值，示例如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function foo(a, b, c){</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>    console.log(a, b, c);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>foo.call({}, 1, 2, 3);</span></span>
<span class="line"><span>foo.apply({}, [1, 2, 3]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里call和apply作用是一样的，只是传参方式有区别。</p><p>此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的this值固定了参数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function foo(a, b, c){</span></span>
<span class="line"><span>    console.log(this);</span></span>
<span class="line"><span>    console.log(a, b, c);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>foo.bind({}, 1, 2, 3)();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有趣的是，call、bind和apply用于不接受this的函数类型如箭头、class都不会报错。</p><p>这时候，它们无法实现改变this的能力，但是可以实现传参。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>在这一节课程中，我们认识了ES2018中规定的各种函数，我一共简单介绍了8种函数。</p><p>我们围绕this这个中心，介绍了函数的执行上下文切换机制。同时我们还讲解了this中的一些相关知识。包括了操作this的内置函数。</p><p>最后，留给你一个问题，你在日常开发中用过哪些函数类型呢？欢迎给我留言，我们一起讨论。</p><h2 id="补充阅读-new与this" tabindex="-1"><a class="header-anchor" href="#补充阅读-new与this"><span>补充阅读：new与this</span></a></h2><p>我们在之前的对象部分已经讲过new的执行过程，我们再来看一下：</p><ul><li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li><li>将 this 和调用参数传给构造器，执行；</li><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li></ul><p>显然，通过new调用函数，跟直接调用的this取值有明显区别。那么我们今天讲的这些函数跟new搭配又会产生什么效果呢？</p><p>这里我整理了一张表：</p><img src="https://static001.geekbang.org/resource/image/6a/da/6a9f0525b713a903c6c94f52afaea3da.png" alt=""><p>我们可以看到，仅普通函数和类能够跟new搭配使用，这倒是给我们省去了不少麻烦。</p>`,91)]))}const r=n(p,[["render",l]]),o=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%8E%B0%E5%9C%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。 一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。 在JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。 函数 在ES2...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%8E%B0%E5%9C%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。 一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。 在JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。 函数 在ES2..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":8.28,"words":2484},"filePathRelative":"posts/重学前端/模块一：JavaScript/JavaScript执行（三）：你知道现在有多少种函数吗？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"JavaScript执行（三）：你知道现在有多少种函数吗？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/00/18/0093381651a5e580a13209cc6d07c918.mp3\\"></audio></p>\\n<p>在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。</p>\\n<p>一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。</p>","autoDesc":true}');export{r as comp,o as data};

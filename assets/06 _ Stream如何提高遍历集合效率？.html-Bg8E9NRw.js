import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,a){return i(),n("div",null,a[0]||(a[0]=[e(`<p><audio id="audio" title="06 | Stream如何提高遍历集合效率？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/69/4a/6930c5ea8503c9740ca43e84fa38574a.mp3"></audio></p><p>你好，我是刘超。</p><p>上一讲中，我在讲List集合类，那我想你一定也知道集合的顶端接口Collection。在Java8中，Collection新增了两个流方法，分别是Stream()和parallelStream()。</p><p>通过英文名不难猜测，这两个方法肯定和Stream有关，那进一步猜测，是不是和我们熟悉的InputStream和OutputStream也有关系呢？集合类中新增的两个Stream方法到底有什么作用？今天，我们就来深入了解下Stream。</p><h2 id="什么是stream" tabindex="-1"><a class="header-anchor" href="#什么是stream"><span>什么是Stream？</span></a></h2><p>现在很多大数据量系统中都存在分表分库的情况。</p><p>例如，电商系统中的订单表，常常使用用户ID的Hash值来实现分表分库，这样是为了减少单个表的数据量，优化用户查询订单的速度。</p><p>但在后台管理员审核订单时，他们需要将各个数据源的数据查询到应用层之后进行合并操作。</p><p>例如，当我们需要查询出过滤条件下的所有订单，并按照订单的某个条件进行排序，单个数据源查询出来的数据是可以按照某个条件进行排序的，但多个数据源查询出来已经排序好的数据，并不代表合并后是正确的排序，所以我们需要在应用层对合并数据集合重新进行排序。</p><p>在Java8之前，我们通常是通过for循环或者Iterator迭代来重新排序合并数据，又或者通过重新定义Collections.sorts的Comparator方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。</p><p>Java8中添加了一个新的接口类Stream，他和我们之前接触的字节流概念不太一样，Java8集合中的Stream相当于高级版的Iterator，他可以通过Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。</p><p>Stream的聚合操作与数据库SQL的聚合操作sorted、filter、map等类似。我们在应用层就可以高效地实现类似数据库SQL的聚合操作了，而在数据操作方面，Stream不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。</p><p><strong>接下来我们就用一个简单的例子来体验下Stream的简洁与强大。</strong></p><p>这个Demo的需求是过滤分组一所中学里身高在160cm以上的男女同学，我们先用传统的迭代方式来实现，代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = new HashMap&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt;();</span></span>
<span class="line"><span>        for (Student stu: studentsList) {</span></span>
<span class="line"><span>            if (stu.getHeight() &amp;gt; 160) { //如果身高大于160</span></span>
<span class="line"><span>                if (stuMap.get(stu.getSex()) == null) { //该性别还没分类</span></span>
<span class="line"><span>                    List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;Student&amp;gt;(); //新建该性别学生的列表</span></span>
<span class="line"><span>                    list.add(stu);//将学生放进去列表</span></span>
<span class="line"><span>                    stuMap.put(stu.getSex(), list);//将列表放到map中</span></span>
<span class="line"><span>                } else { //该性别分类已存在</span></span>
<span class="line"><span>                    stuMap.get(stu.getSex()).add(stu);//该性别分类已存在，则直接放进去即可</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再使用Java8中的Stream API进行实现：</p><p>1.串行实现</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = stuList.stream().filter((Student s) -&amp;gt; s.getHeight() &amp;gt; 160) .collect(Collectors.groupingBy(Student ::getSex));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>2.并行实现</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = stuList.parallelStream().filter((Student s) -&amp;gt; s.getHeight() &amp;gt; 160) .collect(Collectors.groupingBy(Student ::getSex));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>通过上面两个简单的例子，我们可以发现，Stream结合Lambda表达式实现遍历筛选功能非常得简洁和便捷。</p><h2 id="stream如何优化遍历" tabindex="-1"><a class="header-anchor" href="#stream如何优化遍历"><span>Stream如何优化遍历？</span></a></h2><p>上面我们初步了解了Java8中的Stream API，那Stream是如何做到优化迭代的呢？并行又是如何实现的？下面我们就透过Stream源码剖析Stream的实现原理。</p><h3 id="_1-stream操作分类" tabindex="-1"><a class="header-anchor" href="#_1-stream操作分类"><span>1.Stream操作分类</span></a></h3><p>在了解Stream的实现原理之前，我们先来了解下Stream的操作分类，因为他的操作分类其实是实现高效迭代大数据集合的重要原因之一。为什么这样说，分析完你就清楚了。</p><p>官方将Stream中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。</p><p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p><p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。操作分类详情如下图所示：</p><img src="https://static001.geekbang.org/resource/image/ea/94/ea8dfeebeae8f05ae809ee61b3bf3094.jpg" alt=""><p>我们通常还会将中间操作称为懒操作，也正是由这种懒操作结合终结操作、数据源构成的处理管道（Pipeline），实现了Stream的高效。</p><h3 id="_2-stream源码实现" tabindex="-1"><a class="header-anchor" href="#_2-stream源码实现"><span>2.Stream源码实现</span></a></h3><p>在了解Stream如何工作之前，我们先来了解下Stream包是由哪些主要结构类组合而成的，各个类的职责是什么。参照下图：</p><img src="https://static001.geekbang.org/resource/image/fc/00/fc256f9f8f9e3224aac10b2ee8940e00.jpg" alt=""><p>BaseStream和Stream为最顶端的接口类。BaseStream主要定义了流的基本接口方法，例如，spliterator、isParallel等；Stream则定义了一些流的常用操作方法，例如，map、filter等。</p><p>ReferencePipeline是一个结构类，他通过定义内部类组装了各种操作流。他定义了Head、StatelessOp、StatefulOp三个内部类，实现了BaseStream与Stream的接口方法。</p><p>Sink接口是定义每个Stream操作之间关系的协议，他包含begin()、end()、cancellationRequested()、accpt()四个方法。ReferencePipeline最终会将整个Stream流操作组装成一个调用链，而这条调用链上的各个Stream操作的上下关系就是通过Sink接口协议来定义实现的。</p><h3 id="_3-stream操作叠加" tabindex="-1"><a class="header-anchor" href="#_3-stream操作叠加"><span>3.Stream操作叠加</span></a></h3><p>我们知道，一个Stream的各个操作是由处理管道组装，并统一完成数据处理的。在JDK中每次的中断操作会以使用阶段（Stage）命名。</p><p>管道结构通常是由ReferencePipeline类实现的，前面讲解Stream包结构时，我提到过ReferencePipeline包含了Head、StatelessOp、StatefulOp三种内部类。</p><p>Head类主要用来定义数据源操作，在我们初次调用names.stream()方法时，会初次加载Head对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作StatelessOp对象和有状态操作StatefulOp对象，此时的Stage并没有执行，而是通过AbstractPipeline生成了一个中间操作Stage链表；当我们调用终结操作时，会生成一个最终的Stage，通过这个Stage触发之前的中间操作，从最后一个Stage开始，递归产生一个Sink链。如下图所示：</p><img src="https://static001.geekbang.org/resource/image/f5/19/f548ce93fef2d41b03274295aa0a0419.jpg" alt=""><p><strong>下面我们再通过一个例子来感受下Stream的操作分类是如何实现高效迭代大数据集合的。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;, &amp;quot;王老五&amp;quot;, &amp;quot;李三&amp;quot;, &amp;quot;刘老四&amp;quot;, &amp;quot;王小二&amp;quot;, &amp;quot;张四&amp;quot;, &amp;quot;张五六七&amp;quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>String maxLenStartWithZ = names.stream()</span></span>
<span class="line"><span>    	            .filter(name -&amp;gt; name.startsWith(&amp;quot;张&amp;quot;))</span></span>
<span class="line"><span>    	            .mapToInt(String::length)</span></span>
<span class="line"><span>    	            .max()</span></span>
<span class="line"><span>    	            .toString();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的需求是查找出一个长度最长，并且以张为姓氏的名字。从代码角度来看，你可能会认为是这样的操作流程：首先遍历一次集合，得到以“张”开头的所有名字；然后遍历一次filter得到的集合，将名字转换成数字长度；最后再从长度集合中找到最长的那个名字并且返回。</p><p>这里我要很明确地告诉你，实际情况并非如此。我们来逐步分析下这个方法里所有的操作是如何执行的。</p><p>首先 ，因为names是ArrayList集合，所以names.stream()方法将会调用集合类基础接口Collection的Stream方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    default Stream&amp;lt;E&amp;gt; stream() {</span></span>
<span class="line"><span>        return StreamSupport.stream(spliterator(), false);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，Stream方法就会调用StreamSupport类的Stream方法，方法中初始化了一个ReferencePipeline的Head内部类对象：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(Spliterator&amp;lt;T&amp;gt; spliterator, boolean parallel) {</span></span>
<span class="line"><span>        Objects.requireNonNull(spliterator);</span></span>
<span class="line"><span>        return new ReferencePipeline.Head&amp;lt;&amp;gt;(spliterator,</span></span>
<span class="line"><span>                                            StreamOpFlag.fromCharacteristics(spliterator),</span></span>
<span class="line"><span>                                            parallel);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再调用filter和map方法，这两个方法都是无状态的中间操作，所以执行filter和map操作时，并没有进行任何的操作，而是分别创建了一个Stage来标识用户的每一次操作。</p><p>而通常情况下Stream的操作又需要一个回调函数，所以一个完整的Stage是由数据来源、操作、回调函数组成的三元组来表示。如下图所示，分别是ReferencePipeline的filter方法和map方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  @Override</span></span>
<span class="line"><span>    public final Stream&amp;lt;P_OUT&amp;gt; filter(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {</span></span>
<span class="line"><span>        Objects.requireNonNull(predicate);</span></span>
<span class="line"><span>        return new StatelessOp&amp;lt;P_OUT, P_OUT&amp;gt;(this, StreamShape.REFERENCE,</span></span>
<span class="line"><span>                                     StreamOpFlag.NOT_SIZED) {</span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;P_OUT&amp;gt; sink) {</span></span>
<span class="line"><span>                return new Sink.ChainedReference&amp;lt;P_OUT, P_OUT&amp;gt;(sink) {</span></span>
<span class="line"><span>                    @Override</span></span>
<span class="line"><span>                    public void begin(long size) {</span></span>
<span class="line"><span>                        downstream.begin(-1);</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                    @Override</span></span>
<span class="line"><span>                    public void accept(P_OUT u) {</span></span>
<span class="line"><span>                        if (predicate.test(u))</span></span>
<span class="line"><span>                            downstream.accept(u);</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                };</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   @Override</span></span>
<span class="line"><span>    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)</span></span>
<span class="line"><span>    public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super P_OUT, ? extends R&amp;gt; mapper) {</span></span>
<span class="line"><span>        Objects.requireNonNull(mapper);</span></span>
<span class="line"><span>        return new StatelessOp&amp;lt;P_OUT, R&amp;gt;(this, StreamShape.REFERENCE,</span></span>
<span class="line"><span>                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {</span></span>
<span class="line"><span>            @Override</span></span>
<span class="line"><span>            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {</span></span>
<span class="line"><span>                return new Sink.ChainedReference&amp;lt;P_OUT, R&amp;gt;(sink) {</span></span>
<span class="line"><span>                    @Override</span></span>
<span class="line"><span>                    public void accept(P_OUT u) {</span></span>
<span class="line"><span>                        downstream.accept(mapper.apply(u));</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                };</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>new StatelessOp将会调用父类AbstractPipeline的构造函数，这个构造函数将前后的Stage联系起来，生成一个Stage链表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> AbstractPipeline(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; previousStage, int opFlags) {</span></span>
<span class="line"><span>        if (previousStage.linkedOrConsumed)</span></span>
<span class="line"><span>            throw new IllegalStateException(MSG_STREAM_LINKED);</span></span>
<span class="line"><span>        previousStage.linkedOrConsumed = true;</span></span>
<span class="line"><span>        previousStage.nextStage = this;//将当前的stage的next指针指向之前的stage</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        this.previousStage = previousStage;//赋值当前stage当全局变量previousStage </span></span>
<span class="line"><span>        this.sourceOrOpFlags = opFlags &amp;amp; StreamOpFlag.OP_MASK;</span></span>
<span class="line"><span>        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span></span>
<span class="line"><span>        this.sourceStage = previousStage.sourceStage;</span></span>
<span class="line"><span>        if (opIsStateful())</span></span>
<span class="line"><span>            sourceStage.sourceAnyStateful = true;</span></span>
<span class="line"><span>        this.depth = previousStage.depth + 1;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为在创建每一个Stage时，都会包含一个opWrapSink()方法，该方法会把一个操作的具体实现封装在Sink类中，Sink采用（处理-&gt;转发）的模式来叠加操作。</p><p>当执行max方法时，会调用ReferencePipeline的max方法，此时由于max方法是终结操作，所以会创建一个TerminalOp操作，同时创建一个ReducingSink，并且将操作封装在Sink类中。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> @Override</span></span>
<span class="line"><span>    public final Optional&amp;lt;P_OUT&amp;gt; max(Comparator&amp;lt;? super P_OUT&amp;gt; comparator) {</span></span>
<span class="line"><span>        return reduce(BinaryOperator.maxBy(comparator));</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，调用AbstractPipeline的wrapSink方法，该方法会调用opWrapSink生成一个Sink链表，Sink链表中的每一个Sink都封装了一个操作的具体实现。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  @Override</span></span>
<span class="line"><span>    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)</span></span>
<span class="line"><span>    final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {</span></span>
<span class="line"><span>        Objects.requireNonNull(sink);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        for ( @SuppressWarnings(&amp;quot;rawtypes&amp;quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {</span></span>
<span class="line"><span>            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return (Sink&amp;lt;P_IN&amp;gt;) sink;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当Sink链表生成完成后，Stream开始执行，通过spliterator迭代集合，执行Sink链表中的具体操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> @Override</span></span>
<span class="line"><span>    final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {</span></span>
<span class="line"><span>        Objects.requireNonNull(wrappedSink);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {</span></span>
<span class="line"><span>            wrappedSink.begin(spliterator.getExactSizeIfKnown());</span></span>
<span class="line"><span>            spliterator.forEachRemaining(wrappedSink);</span></span>
<span class="line"><span>            wrappedSink.end();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            copyIntoWithCancel(wrappedSink, spliterator);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java8中的Spliterator的forEachRemaining会迭代集合，每迭代一次，都会执行一次filter操作，如果filter操作通过，就会触发map操作，然后将结果放入到临时数组object中，再进行下一次的迭代。完成中间操作后，就会触发终结操作max。</p><p>这就是串行处理方式了，那么Stream的另一种处理数据的方式又是怎么操作的呢？</p><h3 id="_4-stream并行处理" tabindex="-1"><a class="header-anchor" href="#_4-stream并行处理"><span>4.Stream并行处理</span></a></h3><p>Stream处理数据的方式有两种，串行处理和并行处理。要实现并行处理，我们只需要在例子的代码中新增一个Parallel()方法，代码如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;, &amp;quot;王老五&amp;quot;, &amp;quot;李三&amp;quot;, &amp;quot;刘老四&amp;quot;, &amp;quot;王小二&amp;quot;, &amp;quot;张四&amp;quot;, &amp;quot;张五六七&amp;quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>String maxLenStartWithZ = names.stream()</span></span>
<span class="line"><span>                    .parallel()</span></span>
<span class="line"><span>    	            .filter(name -&amp;gt; name.startsWith(&amp;quot;张&amp;quot;))</span></span>
<span class="line"><span>    	            .mapToInt(String::length)</span></span>
<span class="line"><span>    	            .max()</span></span>
<span class="line"><span>    	            .toString();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Stream的并行处理在执行终结操作之前，跟串行处理的实现是一样的。而在调用终结方法之后，实现的方式就有点不太一样，会调用TerminalOp的evaluateParallel方法进行并行处理。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {</span></span>
<span class="line"><span>        assert getOutputShape() == terminalOp.inputShape();</span></span>
<span class="line"><span>        if (linkedOrConsumed)</span></span>
<span class="line"><span>            throw new IllegalStateException(MSG_STREAM_LINKED);</span></span>
<span class="line"><span>        linkedOrConsumed = true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return isParallel()</span></span>
<span class="line"><span>               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))</span></span>
<span class="line"><span>               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的并行处理指的是，Stream结合了ForkJoin框架，对Stream 处理进行了分片，Splititerator中的estimateSize方法会估算出分片的数据量。</p><p>ForkJoin框架和估算算法，在这里我就不具体讲解了，如果感兴趣，你可以深入源码分析下该算法的实现。</p><p>通过预估的数据量获取最小处理单元的阈值，如果当前分片大小大于最小处理单元的阈值，就继续切分集合。每个分片将会生成一个Sink链表，当所有的分片操作完成后，ForkJoin框架将会合并分片任何结果集。</p><h2 id="合理使用stream" tabindex="-1"><a class="header-anchor" href="#合理使用stream"><span>合理使用Stream</span></a></h2><p>看到这里，你应该对Stream API是如何优化集合遍历有个清晰的认知了。Stream API用起来简洁，还能并行处理，那是不是使用Stream API，系统性能就更好呢？通过一组测试，我们一探究竟。</p><p>我们将对常规的迭代、Stream串行迭代以及Stream并行迭代进行性能测试对比，迭代循环中，我们将对数据进行过滤、分组等操作。分别进行以下几组测试：</p><ul><li>多核CPU服务器配置环境下，对比长度100的int数组的性能；</li><li>多核CPU服务器配置环境下，对比长度1.00E+8的int数组的性能；</li><li>多核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组的性能；</li><li>单核CPU服务器配置环境下，对比长度1.00E+8对象数组过滤分组的性能。</li></ul><p>由于篇幅有限，我这里直接给出统计结果，你也可以自己去验证一下，具体的测试代码可以在<a href="https://github.com/nickliuchao/stream" target="_blank" rel="noopener noreferrer">Github</a>上查看。通过以上测试，我统计出的测试结果如下（迭代使用时间）：</p><ul><li>常规的迭代&lt;Stream并行迭代&lt;Stream串行迭代</li><li>Stream并行迭代&lt;常规的迭代&lt;Stream串行迭代</li><li>Stream并行迭代&lt;常规的迭代&lt;Stream串行迭代</li><li>常规的迭代&lt;Stream串行迭代&lt;Stream并行迭代</li></ul><p>通过以上测试结果，我们可以看到：在循环迭代次数较少的情况下，常规的迭代方式性能反而更好；在单核CPU服务器配置环境中，也是常规迭代方式更有优势；而在大数据循环迭代中，如果服务器是多核CPU的情况下，Stream的并行迭代优势明显。所以我们在平时处理大数据的集合时，应该尽量考虑将应用部署在多核CPU环境下，并且使用Stream的并行迭代方式进行处理。</p><p>用事实说话，我们看到其实使用Stream未必可以使系统性能更佳，还是要结合应用场景进行选择，也就是合理地使用Stream。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>纵观Stream的设计实现，非常值得我们学习。从大的设计方向上来说，Stream将整个操作分解为了链式结构，不仅简化了遍历操作，还为实现了并行计算打下了基础。</p><p>从小的分类方向上来说，Stream将遍历元素的操作和对元素的计算分为中间操作和终结操作，而中间操作又根据元素之间状态有无干扰分为有状态和无状态操作，实现了链结构中的不同阶段。</p><p>**在串行处理操作中，**Stream在执行每一步中间操作时，并不会做实际的数据操作处理，而是将这些中间操作串联起来，最终由终结操作触发，生成一个数据处理链表，通过Java8中的Spliterator迭代器进行数据处理；此时，每执行一次迭代，就对所有的无状态的中间操作进行数据处理，而对有状态的中间操作，就需要迭代处理完所有的数据，再进行处理操作；最后就是进行终结操作的数据处理。</p><p>**在并行处理操作中，**Stream对中间操作基本跟串行处理方式是一样的，但在终结操作中，Stream将结合ForkJoin框架对集合进行切片处理，ForkJoin框架将每个切片的处理结果Join合并起来。最后就是要注意Stream的使用场景。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>这里有一个简单的并行处理案例，请你找出其中存在的问题。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//使用一个容器装载100个数字，通过Stream并行处理的方式将容器中为单数的数字转移到容器parallelList</span></span>
<span class="line"><span>List&amp;lt;Integer&amp;gt; integerList= new ArrayList&amp;lt;Integer&amp;gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (int i = 0; i &amp;lt;100; i++) {</span></span>
<span class="line"><span>      integerList.add(i);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>List&amp;lt;Integer&amp;gt; parallelList = new ArrayList&amp;lt;Integer&amp;gt;() ;</span></span>
<span class="line"><span>integerList.stream()</span></span>
<span class="line"><span>           .parallel()</span></span>
<span class="line"><span>           .filter(i-&amp;gt;i%2==1)</span></span>
<span class="line"><span>           .forEach(i-&amp;gt;parallelList.add(i));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p>`,89)]))}const m=s(p,[["render",l]]),c=JSON.parse('{"path":"/posts/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/%E6%A8%A1%E5%9D%97%E4%BA%8C%20%C2%B7%20Java%E7%BC%96%E7%A8%8B%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/06%20_%20Stream%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E6%95%88%E7%8E%87%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是刘超。 上一讲中，我在讲List集合类，那我想你一定也知道集合的顶端接口Collection。在Java8中，Collection新增了两个流方法，分别是Stream()和parallelStream()。 通过英文名不难猜测，这两个方法肯定和Stream有关，那进一步猜测，是不是和我们熟悉的InputStream和OutputStream也...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/%E6%A8%A1%E5%9D%97%E4%BA%8C%20%C2%B7%20Java%E7%BC%96%E7%A8%8B%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/06%20_%20Stream%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E6%95%88%E7%8E%87%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是刘超。 上一讲中，我在讲List集合类，那我想你一定也知道集合的顶端接口Collection。在Java8中，Collection新增了两个流方法，分别是Stream()和parallelStream()。 通过英文名不难猜测，这两个方法肯定和Stream有关，那进一步猜测，是不是和我们熟悉的InputStream和OutputStream也..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":14.6,"words":4381},"filePathRelative":"posts/Java性能调优实战/模块二 · Java编程性能调优/06 _ Stream如何提高遍历集合效率？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"06 | Stream如何提高遍历集合效率？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/69/4a/6930c5ea8503c9740ca43e84fa38574a.mp3\\"></audio></p>\\n<p>你好，我是刘超。</p>\\n<p>上一讲中，我在讲List集合类，那我想你一定也知道集合的顶端接口Collection。在Java8中，Collection新增了两个流方法，分别是Stream()和parallelStream()。</p>","autoDesc":true}');export{m as comp,c as data};

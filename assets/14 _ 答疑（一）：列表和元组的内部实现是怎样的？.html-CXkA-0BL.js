import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as i}from"./app-6Bz2fGO5.js";const l={};function p(d,s){return i(),n("div",null,s[0]||(s[0]=[a(`<p><audio id="audio" title="14 | 答疑（一）：列表和元组的内部实现是怎样的？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/4e/02/4ebb5414c2c5e6a15be30d87509e2602.mp3"></audio></p><p>你好，我是景霄。</p><p>转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。</p><p>大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。</p><h2 id="问题一-列表和元组的内部实现" tabindex="-1"><a class="header-anchor" href="#问题一-列表和元组的内部实现"><span>问题一：列表和元组的内部实现</span></a></h2><p>第一个问题，是胡峣同学提出的，有关列表（list）和元组（tuple）的内部实现，想知道里边是linked list 或array，还是把array linked一下这样的方式？</p><img src="https://static001.geekbang.org/resource/image/8f/a2/8fb9cf6bf14357104c88454eefaaeca2.png" alt=""><p>关于这个问题，我们可以分别从源码来看。</p><p>先来看 Python 3.7 的list源码。你可以先自己阅读下面两个链接里的内容。</p><p>listobject.h：<a href="https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23" target="_blank" rel="noopener noreferrer">https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23</a></p><p>listobject.c: <a href="https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33" target="_blank" rel="noopener noreferrer">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33</a></p><p>我把 list的具体结构放在了下面：</p><img src="https://static001.geekbang.org/resource/image/99/e0/99e356ee9b00e645004879b9837c3ee0.png" alt=""><p>可以看到，list本质上是一个over-allocate的array。其中，ob_item是一个指针列表，里面的每一个指针都指向列表的元素。而 allocated则存储了这个列表已经被分配的空间大小。</p><p>需要注意的是，allocated 与列表实际空间大小的区别。列表实际空间大小，是指len(list)返回的结果，即上述代码注释中的ob_size，表示这个列表总共存储了多少个元素。实际情况下，为了优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间allocated往往会大于ob_size（详见正文中的例子）。</p><p>所以，它们的关系为：<code>allocated &amp;gt;= len(list) = ob_size</code>。</p><p>如果当前列表分配的空间已满（即allocated == len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。列表每次分配空间的大小，遵循下面的模式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们再来分析元组。下面是Python 3.7 的tuple源码，同样的，你可以先自己阅读一下。</p><p>tupleobject.h： <a href="https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Include/tupleobject.h#L25" target="_blank" rel="noopener noreferrer">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Include/tupleobject.h#L25</a></p><p>tupleobject.c：<a href="https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/tupleobject.c#L16" target="_blank" rel="noopener noreferrer">https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/tupleobject.c#L16</a></p><p>同样的，下面为tuple的具体结构：</p><img src="https://static001.geekbang.org/resource/image/5b/d2/5b038b1819ee122b6309b5c5bae456d2.png" alt=""><p>你可以看到，它和list相似，本质也是一个array，但是空间大小固定。不同于一般array，Python的tuple做了许多优化，来提升在程序中的效率。</p><p>举个例子，当tuple的大小不超过20时，Python就会把它缓存在内部的一个free list中。这样，如果你以后需要再去创建同样的tuple，Python就可以直接从缓存中载入，提高了程序运行效率。</p><h2 id="问题二-为什么在旧哈希表中-元素会越来越稀疏" tabindex="-1"><a class="header-anchor" href="#问题二-为什么在旧哈希表中-元素会越来越稀疏"><span>问题二：为什么在旧哈希表中，元素会越来越稀疏？</span></a></h2><p>第二个问题，是Hoo同学提出的，为什么在旧哈希表中，元素会越来越稀疏？</p><img src="https://static001.geekbang.org/resource/image/cf/6b/cf241621f373b0e3712f3e0fcc71896b.png" alt=""><p>我们可以先来看旧哈希表的示意图：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>--+-------------------------------+</span></span>
<span class="line"><span>  | 哈希值 (hash)  键 (key)  值 (value)</span></span>
<span class="line"><span>--+-------------------------------+</span></span>
<span class="line"><span>0 |    hash0      key0    value0</span></span>
<span class="line"><span>--+-------------------------------+</span></span>
<span class="line"><span>1 |    hash1      key1    value1</span></span>
<span class="line"><span>--+-------------------------------+</span></span>
<span class="line"><span>2 |    hash2      key2    value2</span></span>
<span class="line"><span>--+-------------------------------+</span></span>
<span class="line"><span>. |           ...</span></span>
<span class="line"><span>__+_______________________________+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现，它是一个over-allocate的array，根据元素键（key）的哈希值，来计算其应该被插入位置的索引。</p><p>因此，假设我有下面这样一个字典：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{&#39;name&#39;: &#39;mike&#39;, &#39;dob&#39;: &#39;1999-01-01&#39;, &#39;gender&#39;: &#39;male&#39;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么这个字典便会存储为类似下面的形式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>entries = [</span></span>
<span class="line"><span>[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;]</span></span>
<span class="line"><span>[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span></span>
<span class="line"><span>[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span></span>
<span class="line"><span>[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span></span>
<span class="line"><span>[1231236123, &#39;name&#39;, &#39;mike&#39;],</span></span>
<span class="line"><span>[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span></span>
<span class="line"><span>[9371539127, &#39;gender&#39;, &#39;male&#39;]</span></span>
<span class="line"><span>]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>’---‘</code>，表示这个位置没有元素，但是已经分配了内存。</p><p>我们知道，当哈希表剩余空间小于1/3时，为了保证相关操作的高效性并避免哈希冲突，就会重新分配更大的内存。所以，当哈希表中的元素越来越多时，分配了内存但里面没有元素的位置，也会变得越来越多。这样一来，哈希表便会越来越稀疏。</p><p>而新哈希表的结构，改变了这一点，也大大提高了空间的利用率。新哈希表的结构如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Indices</span></span>
<span class="line"><span>----------------------------------------------------</span></span>
<span class="line"><span>None | index | None | None | index | None | index ...</span></span>
<span class="line"><span>----------------------------------------------------</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>Entries</span></span>
<span class="line"><span>--------------------</span></span>
<span class="line"><span>hash0   key0  value0</span></span>
<span class="line"><span>---------------------</span></span>
<span class="line"><span>hash1   key1  value1</span></span>
<span class="line"><span>---------------------</span></span>
<span class="line"><span>hash2   key2  value2</span></span>
<span class="line"><span>---------------------</span></span>
<span class="line"><span>        ...</span></span>
<span class="line"><span>---------------------</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以看到，它把存储结构分成了Indices和Entries这两个array，而<code>’None‘</code>代表这个位置分配了内存但没有元素。</p><p>我们同样还用上面这个例子，它在新哈希表中的存储模式，就会变为下面这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>indices = [None, 1, None, None, 0, None, 2]</span></span>
<span class="line"><span>entries = [</span></span>
<span class="line"><span>[1231236123, &#39;name&#39;, &#39;mike&#39;],</span></span>
<span class="line"><span>[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span></span>
<span class="line"><span>[9371539127, &#39;gender&#39;, &#39;male&#39;]</span></span>
<span class="line"><span>]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，Indices中元素的值，对应entries中相应的索引。比如<code>indices</code>中的<code>1</code>，就对应着<code>entries[1]</code>，即<code>’&#39;dob&#39;: &#39;1999-01-01&#39;‘</code>。</p><p>对比之下，我们会清晰感受到，新哈希表中的空间利用率，相比于旧哈希表有大大的提升。</p><h2 id="问题三-有关异常的困扰" tabindex="-1"><a class="header-anchor" href="#问题三-有关异常的困扰"><span>问题三：有关异常的困扰</span></a></h2><p>第三个问题，是“不瘦到140不改名”同学提出的，对“NameError”异常的困惑。这是很常见的一个错误，我在这里也解释一下。</p><img src="https://static001.geekbang.org/resource/image/48/6e/48c46d4a66e5c002ce392d79deee436e.png" alt=""><p>这个问题其实有点tricky，如果你查阅<a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement" target="_blank" rel="noopener noreferrer">官方文档</a>，会看到这么一句话”When an exception has been assigned using as target, it is cleared at the end of the except clause. ”</p><p>这句话意思是，如果你在异常处理的except block中，把异常赋予了一个变量，那么这个变量会在except block执行结束时被删除，相当于下面这样的表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>e = 1</span></span>
<span class="line"><span>try:</span></span>
<span class="line"><span>    1 / 0</span></span>
<span class="line"><span>except ZeroDivisionError as e:</span></span>
<span class="line"><span>    try:</span></span>
<span class="line"><span>        pass</span></span>
<span class="line"><span>    finally:</span></span>
<span class="line"><span>        del e</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的e一开始指向整数1，但是在except block结束时被删除了（del e），所以程序执行就会抛出“NameError”的异常。</p><p>因此，这里提醒我们，在平时写代码时，一定要保证except中异常赋予的变量，在之后的语句中不再被用到。</p><h2 id="问题四-关于多态和全局变量的修改" tabindex="-1"><a class="header-anchor" href="#问题四-关于多态和全局变量的修改"><span>问题四：关于多态和全局变量的修改</span></a></h2><p>最后的问题来自于farFlight同学，他提了两个问题：</p><ol><li>Python自己判断类型的多态和子类继承的多态Polymorphism是否相同？</li><li>函数内部不能直接用+=等修改全局变量，但是对于list全局变量，却可以使用append、extend之类修改，这是为什么呢?</li></ol><img src="https://static001.geekbang.org/resource/image/aa/0c/aa20a535ce703ef0fe0f1291877f960c.png" alt=""><p>我们分别来看这两个问题。对于第一个问题，要搞清楚多态的概念，多态是指有多种不同的形式。因此，判断类型的多态和子类继承的多态，在本质上都是一样的，只不过你可以把它们理解为多态的两种不同表现。</p><p>再来看第二个问题。当全局变量指向的对象不可变时，比如是整型、字符串等等，如果你尝试在函数内部改变它的值，却不加关键字global，就会抛出异常：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>x = 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def func():</span></span>
<span class="line"><span>    x += 1</span></span>
<span class="line"><span>func()</span></span>
<span class="line"><span>x</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 输出</span></span>
<span class="line"><span>UnboundLocalError: local variable &#39;x&#39; referenced before assignment</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为，程序默认函数内部的x是局部变量，而你没有为其赋值就直接引用，显然是不可行。</p><p>不过，如果全局变量指向的对象是可变的，比如是列表、字典等等，你就可以在函数内部修改它了：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>x = [1]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def func():</span></span>
<span class="line"><span>    x.append(2)</span></span>
<span class="line"><span>func()</span></span>
<span class="line"><span>x</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 输出</span></span>
<span class="line"><span>[1, 2]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，需要注意的是，这里的<code>x.append(2)</code>，并没有改变变量x，x依然指向原来的列表。事实上，这句话的意思是，访问x指向的列表，并在这个列表的末尾增加2。</p><p>今天主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值。</p>`,64)]))}const r=e(l,[["render",p]]),o=JSON.parse('{"path":"/posts/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%9F%BA%E7%A1%80%E7%AF%87/14%20_%20%E7%AD%94%E7%96%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是景霄。 转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。 大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%9F%BA%E7%A1%80%E7%AF%87/14%20_%20%E7%AD%94%E7%96%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是景霄。 转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。 大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.87,"words":2062},"filePathRelative":"posts/Python核心技术与实战/基础篇/14 _ 答疑（一）：列表和元组的内部实现是怎样的？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"14 | 答疑（一）：列表和元组的内部实现是怎样的？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/4e/02/4ebb5414c2c5e6a15be30d87509e2602.mp3\\"></audio></p>\\n<p>你好，我是景霄。</p>\\n<p>转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。</p>","autoDesc":true}');export{r as comp,o as data};

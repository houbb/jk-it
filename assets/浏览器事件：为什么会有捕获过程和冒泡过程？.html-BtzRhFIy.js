import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as i}from"./app-CrA-f6So.js";const p={};function t(l,e){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="浏览器事件-为什么会有捕获过程和冒泡过程" tabindex="-1"><a class="header-anchor" href="#浏览器事件-为什么会有捕获过程和冒泡过程"><span>浏览器事件：为什么会有捕获过程和冒泡过程？</span></a></h1><p><audio id="audio" title="浏览器事件：为什么会有捕获过程和冒泡过程？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/3d/a1/3d74436115f82450711614b8fe564fa1.mp3"></audio></p><p>你好，我是winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。</p><h2 id="事件概述" tabindex="-1"><a class="header-anchor" href="#事件概述"><span>事件概述</span></a></h2><p>在开始接触具体的API之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种：</p><ul><li>键盘；</li><li>鼠标；</li><li>触摸屏。</li></ul><p>**这其中，触摸屏和鼠标又有一定的共性，它们被称作pointer设备，所谓pointer设备，是指它的输入最终会被抽象成屏幕上面的一个点。**但是触摸屏和鼠标又有一定区别，它们的精度、反应时间和支持的点的数量都不一样。</p><p>我们现代的UI系统，都源自WIMP系统。WIMP即Window Icon Menu Pointer四个要素，它最初由施乐公司研发，后来被微软和苹果两家公司应用在了自己的操作系统上（关于这个还有一段有趣的故事，我附在文末了）。</p><p>WIMP是如此成功，以至于今天很多的前端工程师会有一个观点，认为我们能够“点击一个按钮”，实际上并非如此，我们只能够点击鼠标上的按钮或者触摸屏，是操作系统和浏览器把这个信息对应到了一个逻辑上的按钮，再使得它的视图对点击事件有反应。这就引出了我们第一个要讲解的机制：捕获与冒泡。</p><h2 id="捕获与冒泡" tabindex="-1"><a class="header-anchor" href="#捕获与冒泡"><span>捕获与冒泡</span></a></h2><p>很多文章会讲到捕获过程是从外向内，冒泡过程是从内向外，但是这里我希望讲清楚，为什么会有捕获过程和冒泡过程。</p><p>我们刚提到，实际上点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏一样，提供一个坐标给浏览器。</p><p>那么，把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你也按到了电视机。</p><p>所以我们可以认为，捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑。</p><p>以下代码展示了事件传播顺序：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;lt;body&amp;gt;</span></span>
<span class="line"><span>  &amp;lt;input id=&quot;i&quot;/&amp;gt;</span></span>
<span class="line"><span>&amp;lt;/body&amp;gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>document.body.addEventListener(&quot;mousedown&quot;, () =&amp;gt; {</span></span>
<span class="line"><span>  console.log(&quot;key1&quot;)</span></span>
<span class="line"><span>}, true)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>document.getElementById(&quot;i&quot;).addEventListener(&quot;mousedown&quot;, () =&amp;gt; {</span></span>
<span class="line"><span>  console.log(&quot;key2&quot;)</span></span>
<span class="line"><span>}, true)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>document.body.addEventListener(&quot;mousedown&quot;, () =&amp;gt; {</span></span>
<span class="line"><span>  console.log(&quot;key11&quot;)</span></span>
<span class="line"><span>}, false)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>document.getElementById(&quot;i&quot;).addEventListener(&quot;mousedown&quot;, () =&amp;gt; {</span></span>
<span class="line"><span>  console.log(&quot;key22&quot;)</span></span>
<span class="line"><span>}, false)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们监听了body和一个body的子元素上的鼠标按下事件，捕获和冒泡分别监听，可以看到，最终产生的顺序是：</p><ul><li>“key1”</li><li>“key2”</li><li>“key22”</li><li>“key11”</li></ul><p>这是捕获和冒泡发生的完整顺序。</p><p>在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。</p><p>在我们实际监听事件时，我建议这样使用冒泡和捕获机制：默认使用冒泡模式，当开发组件时，遇到需要父元素控制子元素的行为，可以使用捕获机制。</p><p>理解了冒泡和捕获的过程，我们再看监听事件的API，就非常容易理解了。</p><p>addEventListener有三个参数：</p><ul><li>事件名称；</li><li>事件处理函数；</li><li>捕获还是冒泡。</li></ul><p>事件处理函数不一定是函数，也可以是个JavaScript具有handleEvent方法的对象，看下例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var o = {</span></span>
<span class="line"><span>  handleEvent: event =&amp;gt; console.log(event)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>document.body.addEventListener(&quot;keydown&quot;, o, false);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三个参数不一定是bool值，也可以是个对象，它提供了更多选项。</p><ul><li>once：只执行一次。</li><li>passive：承诺此事件监听不会调用preventDefault，这有助于性能。</li><li>useCapture：是否捕获（否则冒泡）。</li></ul><p>实际使用，在现代浏览器中，还可以不传第三个参数，我建议默认不传第三个参数，因为我认为冒泡是符合正常的人类心智模型的，大部分业务开发者不需要关心捕获过程。除非你是组件或者库的使用者，那就总是需要关心冒泡和捕获了。</p><h2 id="焦点" tabindex="-1"><a class="header-anchor" href="#焦点"><span>焦点</span></a></h2><p>我们讲完了pointer事件是由坐标控制，而我们还没有讲到键盘事件。</p><p>键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点系统。</p><p>焦点系统也是视障用户访问的重要入口，所以设计合理的焦点系统是非常重要的产品需求，尤其是不少国家对可访问性有明确的法律要求。</p><p>在旧时代，有一个经典的问题是如何去掉输入框上的虚线框，这个虚线框就是Windows焦点系统附带的UI表现。</p><p>现在Windows的焦点已经不是用虚线框表示了，但是焦点系统的设计几十年间没有太大变化。</p><p>焦点系统认为整个UI系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。</p><p>Tab键被用来切换到下一个可聚焦的元素，焦点系统占用了Tab键，但是可以用JavaScript来阻止这个行为。</p><p>浏览器API还提供了API来操作焦点，如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>document.body.focus();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>document.body.blur();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实原本键盘事件不需要捕获过程，但是为了跟pointer设备保持一致，也规定了从外向内传播的捕获过程。</p><h2 id="自定义事件" tabindex="-1"><a class="header-anchor" href="#自定义事件"><span>自定义事件</span></a></h2><p>除了来自输入设备的事件，还可以自定义事件，实际上事件也是一种非常好的代码架构，但是DOM API中的事件并不能用于普通对象，所以很遗憾，我们只能在DOM元素上使用自定义事件。</p><p>自定义事件的代码示例如下（来自MDN）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var evt = new Event(&quot;look&quot;, {&quot;bubbles&quot;:true, &quot;cancelable&quot;:false});</span></span>
<span class="line"><span>document.dispatchEvent(evt);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里使用Event构造器来创造了一个新的事件，然后调用dispatchEvent来在特定元素上触发。<br><br> 我们可以给这个Event添加自定义属性、方法。</p><p>注意，这里旧的自定义事件方法（使用document.createEvent和initEvent）已经被废弃。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>今天这一节课，我们讲了浏览器中的事件。</p><p>我们分别介绍了事件的捕获与冒泡机制、焦点机制和自定义事件。</p><p>捕获与冒泡机制来自pointer设备输入的处理，捕获是计算机处理输入的逻辑，冒泡是人类理解事件的思维，捕获总是在冒泡之前发生。</p><p>焦点机制则来自操作系统的思路，用于处理键盘事件。除了我们讲到的这些，随着输入设备的不断丰富，还有很多新的事件加入，如Geolocation和陀螺仪等。</p><p>最后给你留个小问题。请你找出你所知道的所有事件类型，和它们的目标元素类型。</p><h2 id="wimp的小故事" tabindex="-1"><a class="header-anchor" href="#wimp的小故事"><span>WIMP的小故事</span></a></h2><p>WIMP是由Alan Kay主导设计的，这位巨匠，同时也是面向对象之父和Smalltalk语言之父。</p><p>乔布斯曾经受邀参观施乐，他见到当时的WIMP界面，认为非常惊艳，不久后就领导苹果研究了新一代麦金塔系统。</p><p>后来，在某次当面对话中，乔布斯指责比尔盖茨抄袭了WIMP的设计，盖茨淡定地回答：“史蒂夫，我觉得应该用另一种方式看待这个问题。这就像我们有个叫施乐的有钱邻居，当我闯进去想偷走电视时，却发现你已经这么干了。”</p><p>但是不论如何，苹果和微软的数十代操作系统，极大地发展了这个体系，才有了我们今天的UI界面。</p>`,58)]))}const r=n(p,[["render",t]]),c=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAPI/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%8D%95%E8%8E%B7%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%92%E6%B3%A1%E8%BF%87%E7%A8%8B%EF%BC%9F.html","title":"浏览器事件：为什么会有捕获过程和冒泡过程？","lang":"zh-CN","frontmatter":{"description":"浏览器事件：为什么会有捕获过程和冒泡过程？ 你好，我是winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。 事件概述 在开始接触具体的API之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种： 键盘； 鼠标； 触摸屏。 **这其中，触摸屏和鼠标又有一定的共性，它们被称作pointer设备，所谓p...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EAPI/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%8D%95%E8%8E%B7%E8%BF%87%E7%A8%8B%E5%92%8C%E5%86%92%E6%B3%A1%E8%BF%87%E7%A8%8B%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"浏览器事件：为什么会有捕获过程和冒泡过程？"}],["meta",{"property":"og:description","content":"浏览器事件：为什么会有捕获过程和冒泡过程？ 你好，我是winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。 事件概述 在开始接触具体的API之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种： 键盘； 鼠标； 触摸屏。 **这其中，触摸屏和鼠标又有一定的共性，它们被称作pointer设备，所谓p..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器事件：为什么会有捕获过程和冒泡过程？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":6.82,"words":2046},"filePathRelative":"posts/重学前端/模块三：浏览器实现原理与API/浏览器事件：为什么会有捕获过程和冒泡过程？.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"浏览器事件：为什么会有捕获过程和冒泡过程？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/3d/a1/3d74436115f82450711614b8fe564fa1.mp3\\"></audio></p>\\n<p>你好，我是winter。这一节课，我们进入了浏览器的部分，一起来学习一下事件。</p>\\n<h2>事件概述</h2>\\n<p>在开始接触具体的API之前，我们要先了解一下事件。一般来说，事件来自输入设备，我们平时的个人设备上，输入设备有三种：</p>","autoDesc":true}');export{r as comp,c as data};

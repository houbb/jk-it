import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as e}from"./app-CrA-f6So.js";const l={};function p(d,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h1 id="javascript语法-二-你知道哪些javascript语句" tabindex="-1"><a class="header-anchor" href="#javascript语法-二-你知道哪些javascript语句"><span>JavaScript语法（二）：你知道哪些JavaScript语句？</span></a></h1><p><audio id="audio" title="JavaScript语法（二）：你知道哪些JavaScript语句？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/b9/36/b98805c10ae51f49492bce8a7103b936.mp3"></audio></p><p>你好，我是winter。</p><p>我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。</p><p>JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起了解一下语句。</p><p>在JavaScript标准中，把语句分成了两种：声明和语句，不过，这里的区分逻辑比较奇怪，所以，这里我还是按照自己的思路给你整理一下。</p><p>普通语句：</p><img src="https://static001.geekbang.org/resource/image/81/55/8186219674547691cf59e5c095304d55.png" alt=""><p>声明型语句：</p><img src="https://static001.geekbang.org/resource/image/0e/38/0e5327528df12d1eaad52c4005efff38.jpg" alt=""><p>我们根据上面的分类，来遍历学习一下这些语句。</p><h2 id="语句块" tabindex="-1"><a class="header-anchor" href="#语句块"><span>语句块</span></a></h2><p>我们可以这样去简单理解，语句块就是一对大括号。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    var x, y;</span></span>
<span class="line"><span>    x = 10;</span></span>
<span class="line"><span>    y = 20;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，这样，if、for等语句定义起来就比较简单了。不过，我们需要注意的是，语句块会产生作用域，我们看一个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    let x = 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>console.log(x); // 报错</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们的let声明，仅仅对语句块作用域生效，于是我们在语句块外试图访问语句块内的变量x就会报错。</p><h2 id="空语句" tabindex="-1"><a class="header-anchor" href="#空语句"><span>空语句</span></a></h2><p>空语句就是一个独立的分号，实际上没什么大用。我们来看一下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>空语句的存在仅仅是从语言设计完备性的角度考虑，允许插入多个分号而不抛出错误。</p><h2 id="if语句" tabindex="-1"><a class="header-anchor" href="#if语句"><span>if语句</span></a></h2><p>if语句是条件语句。我想，对多数人来说，if语句都是熟悉的老朋友了，也没有什么特别需要注意的用法，但是为了我们课程的完备性，这里还是要讲一下。</p><p>if语句示例如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>if(a &amp;lt; b)</span></span>
<span class="line"><span>    console.log(a);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>if语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块，这样就可以实现有条件地执行多个语句了。</p><p>if语句还有else结构，用于不满足条件时执行，一种常见的用法是，利用语句的嵌套能力，把if和else连写成多分支条件判断：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>if(a &amp;lt; 10) {</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>} else if(a &amp;lt; 20) {</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>} else if(a &amp;lt; 30) {</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码表示四个互斥的分支，分别在满足a&lt;10、a&lt;20、a&lt;30和其它情况时执行。</p><h2 id="switch语句" tabindex="-1"><a class="header-anchor" href="#switch语句"><span>switch语句</span></a></h2><p>switch语句继承自Java，Java中的switch语句继承自C和C++，原本switch语句是跳转的变形，所以我们如果要用它来实现分支，必须要加上break。</p><p>其实switch原本的设计是类似goto的思维。我们看一个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>switch(num) {</span></span>
<span class="line"><span>case 1:</span></span>
<span class="line"><span>    print(1);</span></span>
<span class="line"><span>case 2:</span></span>
<span class="line"><span>    print 2;</span></span>
<span class="line"><span>case 3:</span></span>
<span class="line"><span>    print 3;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码当num为1时输出1 2 3，当num为2时输出2 3，当num为3时输出3。如果我们要把它变成分支型，则需要在每个case后加上break。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>switch(num) {</span></span>
<span class="line"><span>case 1:</span></span>
<span class="line"><span>    print 1;</span></span>
<span class="line"><span>    break;</span></span>
<span class="line"><span>case 2:</span></span>
<span class="line"><span>    print 2;</span></span>
<span class="line"><span>    break;</span></span>
<span class="line"><span>case 3:</span></span>
<span class="line"><span>    print 3;</span></span>
<span class="line"><span>    break;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在C时代，switch生成的汇编代码性能是略优于if else的，但是对JavaScript来说，则无本质区别。我个人的看法是，现在switch已经完全没有必要使用了，应该用if else结构代替。</p><h2 id="循环语句" tabindex="-1"><a class="header-anchor" href="#循环语句"><span>循环语句</span></a></h2><p>循环语句应该也是你所熟悉的语句了，这里我们把重点放在一些新用法上。</p><h3 id="while循环和do-while循环" tabindex="-1"><a class="header-anchor" href="#while循环和do-while循环"><span>while循环和do while循环</span></a></h3><p>这两个都是历史悠久的JavaScript语法了，示例大概如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let a = 100</span></span>
<span class="line"><span>while(a--) {</span></span>
<span class="line"><span>    console.log(&quot;*&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let a = 101;</span></span>
<span class="line"><span>do {</span></span>
<span class="line"><span>    console.log(a);</span></span>
<span class="line"><span>} while(a &amp;lt; 100)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，这里do while循环无论如何至少会执行一次。</p><h3 id="普通for循环" tabindex="-1"><a class="header-anchor" href="#普通for循环"><span>普通for循环</span></a></h3><p>首先我们来看看普通的for循环。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>for(i = 0; i &amp;lt; 100; i++)</span></span>
<span class="line"><span>    console.log(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(var i = 0; i &amp;lt; 100; i++)</span></span>
<span class="line"><span>    console.log(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(let i = 0; i &amp;lt; 100; i++)</span></span>
<span class="line"><span>    console.log(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var j = 0;</span></span>
<span class="line"><span>for(const i = 0; j &amp;lt; 100; j++)</span></span>
<span class="line"><span>    console.log(i);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里为了配合新语法，加入了允许let和const，实际上，const在这里是非常奇葩的东西，因为这里声明和初始化的变量，按惯例是用于控制循环的，但是它如果是const就没法改了。</p><p>我想，这一点可能是从保持let和const一致性的角度考虑的吧。</p><h3 id="for-in循环" tabindex="-1"><a class="header-anchor" href="#for-in循环"><span>for in循环</span></a></h3><p>for in 循环枚举对象的属性，这里体现了属性的enumerable特征。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let o = { a: 10, b: 20}</span></span>
<span class="line"><span>Object.defineProperty(o, &quot;c&quot;, {enumerable:false, value:30})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(let p in o)</span></span>
<span class="line"><span>    console.log(p);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，我们定义了一个对象o，给它添加了不可枚举的属性c，之后我们用for in循环枚举它的属性，我们会发现，输出时得到的只有a和b。</p><p>如果我们定义c这个属性时，enumerable为true，则for in循环中也能枚举到它。</p><h3 id="for-of循环和for-await-of循环" tabindex="-1"><a class="header-anchor" href="#for-of循环和for-await-of循环"><span>for of循环和for await of循环</span></a></h3><p>for of循环是非常棒的语法特性。</p><p>我们先看下基本用法，它可以用于数组：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>for(let e of [1, 2, 3, 4, 5])</span></span>
<span class="line"><span>    console.log(e);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是实际上，它背后的机制是iterator机制。</p><p>我们可以给任何一个对象添加iterator，使它可以用于for of语句，看下示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let o = {  </span></span>
<span class="line"><span>    [Symbol.iterator]:() =&amp;gt; ({</span></span>
<span class="line"><span>        _value: 0,</span></span>
<span class="line"><span>        next(){</span></span>
<span class="line"><span>            if(this._value == 10)</span></span>
<span class="line"><span>                return {</span></span>
<span class="line"><span>                    done: true</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            else return {</span></span>
<span class="line"><span>                value: this._value++,</span></span>
<span class="line"><span>                done: false</span></span>
<span class="line"><span>            };</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>for(let e of o)</span></span>
<span class="line"><span>    console.log(e);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码展示了如何为一个对象添加iterator。但是，在实际操作中，我们一般不需要这样定义iterator，我们可以使用generator function。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function* foo(){</span></span>
<span class="line"><span>    yield 0;</span></span>
<span class="line"><span>    yield 1;</span></span>
<span class="line"><span>    yield 2;</span></span>
<span class="line"><span>    yield 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>for(let e of foo())</span></span>
<span class="line"><span>    console.log(e);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码展示了generator function和foo的配合。</p><p>此外，JavaScript还为异步生成器函数配备了异步的for of，我们来看一个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function sleep(duration) {</span></span>
<span class="line"><span>    return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span>        setTimeout(resolve,duration);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>async function* foo(){</span></span>
<span class="line"><span>    i = 0;</span></span>
<span class="line"><span>    while(true) {</span></span>
<span class="line"><span>        await sleep(1000);</span></span>
<span class="line"><span>        yield i++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>for await(let e of foo())</span></span>
<span class="line"><span>    console.log(e);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码定义了一个异步生成器函数，异步生成器函数每隔一秒生成一个数字，这是一个无限的生成器。</p><p>接下来，我们使用for await of来访问这个异步生成器函数的结果，我们可以看到，这形成了一个每隔一秒打印一个数字的无限循环。</p><p>但是因为我们这个循环是异步的，并且有时间延迟，所以，这个无限循环的代码可以用于显示时钟等有意义的操作。</p><h2 id="return" tabindex="-1"><a class="header-anchor" href="#return"><span>return</span></a></h2><p>return语句用于函数中，它终止函数的执行，并且指定函数的返回值，这是大家非常熟悉语句了，也没有什么特殊之处。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function squre(x){</span></span>
<span class="line"><span>    return x * x;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码展示了return的基本用法。它后面可以跟一个表达式，计算结果就是函数返回值。</p><h2 id="break语句和continue语句" tabindex="-1"><a class="header-anchor" href="#break语句和continue语句"><span>break语句和continue语句</span></a></h2><p>break语句用于跳出循环语句或者switch语句，continue语句用于结束本次循环并继续循环。</p><p>这两个语句都属于控制型语句，用法也比较相似，所以我们就一起讲了。需要注意的是，它们都有带标签的用法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>outer:for(let i = 0; i &amp;lt; 100; i++)</span></span>
<span class="line"><span>    inner:for(let j = 0; j &amp;lt; 100; j++)</span></span>
<span class="line"><span>        if( i == 50 &amp;amp;&amp;amp; j == 50)</span></span>
<span class="line"><span>            break outer;</span></span>
<span class="line"><span>outer:for(let i = 0; i &amp;lt; 100; i++)</span></span>
<span class="line"><span>    inner:for(let j = 0; j &amp;lt; 100; j++)</span></span>
<span class="line"><span>        if( i &amp;gt;= 50 &amp;amp;&amp;amp; j == 50)</span></span>
<span class="line"><span>            continue outer;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>带标签的break和continue可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。</p><h2 id="with语句" tabindex="-1"><a class="header-anchor" href="#with语句"><span>with语句</span></a></h2><p>with语句是个非常巧妙的设计，但它把JavaScript的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕。</p><p>但是历史无法改写，现在已经无法去除with了。我们来了解一下它的基本用法即可。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let o = {a:1, b:2}</span></span>
<span class="line"><span>with(o){</span></span>
<span class="line"><span>    console.log(a, b);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>with语句把对象的属性在它内部的作用域内变成变量。</p><h2 id="try语句和throw语句" tabindex="-1"><a class="header-anchor" href="#try语句和throw语句"><span>try语句和throw语句</span></a></h2><p>try语句和throw语句用于处理异常。它们是配合使用的，所以我们就放在一起讲了。在大型应用中，异常机制非常重要。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>try {</span></span>
<span class="line"><span>    throw new Error(&quot;error&quot;);</span></span>
<span class="line"><span>} catch(e) {</span></span>
<span class="line"><span>    console.log(e);</span></span>
<span class="line"><span>} finally {</span></span>
<span class="line"><span>    console.log(&quot;finally&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，throw用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用throw表达任何非异常逻辑。</p><p>try语句用于捕获异常，用throw抛出的异常，可以在try语句的结构中被处理掉：try部分用于标识捕获异常的代码段，catch部分则用于捕获异常后做一些处理，而finally则是用于执行后做一些必须执行的清理工作。</p><p>catch结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量e了，否则会出错。</p><p>在catch中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。</p><p>finally语句一般用于释放资源，它一定会被执行，我们在前面的课程中已经讨论过一些finally的特征，即使在try中出现了return，finally中的语句也一定要被执行。</p><h2 id="debugger语句" tabindex="-1"><a class="header-anchor" href="#debugger语句"><span>debugger语句</span></a></h2><p>debugger语句的作用是：通知调试器在此断点。在没有调试器挂载时，它不产生任何效果。</p><p>介绍完普通语句，我们再来看看声明型语句。声明型语句跟普通语句最大区别就是声明型语句响应预处理过程，普通语句只有执行过程。</p><h2 id="var" tabindex="-1"><a class="header-anchor" href="#var"><span>var</span></a></h2><p>var声明语句是古典的JavaScript中声明变量的方式。而现在，在绝大多数情况下，let和const都是更好的选择。</p><p>我们在上一节课已经讲解了var声明对全局作用域的影响，它是一种预处理机制。</p><p>如果我们仍然想要使用var，我的个人建议是，把它当做一种“保障变量是局部”的逻辑，遵循以下三条规则：</p><ul><li>声明同时必定初始化；</li><li>尽可能在离使用的位置近处声明；</li><li>不要在意重复声明。</li></ul><p>例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var x = 1, y = 2;</span></span>
<span class="line"><span>doSth(x, y);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(var x = 0; x &amp;lt; 10; x++)</span></span>
<span class="line"><span>    doSth2(x);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中，两次声明了变量x，完成了两段逻辑，这两个x意义上可能不一定相关，这样，不论我们把代码复制粘贴在哪里，都不会出错。</p><p>当然，更好的办法是使用let改造，我们看看如何改造：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    let x = 1, y = 2;</span></span>
<span class="line"><span>    doSth(x, y);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(let x = 0; x &amp;lt; 10; x++)</span></span>
<span class="line"><span>    doSth2(x);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我用代码块限制了第一个x的作用域，这样就更难发生变量命名冲突引起的错误了。</p><h2 id="let和const" tabindex="-1"><a class="header-anchor" href="#let和const"><span>let和const</span></a></h2><p>let和const是都是变量的声明，它们的特性非常相似，所以我们放在一起讲了。let和const是新设计的语法，所以没有什么硬伤，非常地符合直觉。let和const的作用范围是if、for等结构型语句。</p><p>我们看下基本用法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const a = 2;</span></span>
<span class="line"><span>if(true){</span></span>
<span class="line"><span>    const a = 1;</span></span>
<span class="line"><span>    console.log(a);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>console.log(a);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的代码先在全局声明了变量a，接下来又在if内声明了a，if内构成了一个独立的作用域。</p><p>const和let语句在重复声明时会抛错，这能够有效地避免变量名无意中冲突：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let a = 2</span></span>
<span class="line"><span>const a = 1;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，先用let声明了a，接下来又试图使用const声明变量a，这时，就会产生错误。</p><p>let和const声明虽然看上去是执行到了才会生效，但是实际上，它们还是会被预处理。如果当前作用域内有声明，就无法访问到外部的变量。我们来看这段代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const a = 2;</span></span>
<span class="line"><span>if(true){</span></span>
<span class="line"><span>    console.log(a); //抛错</span></span>
<span class="line"><span>    const a = 1;   </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里在if的作用域中，变量a声明执行到之前，我们访问了变量a，这时会抛出一个错误，这说明const声明仍然是有预处理机制的。</p><p>在执行到const语句前，我们的JavaScript引擎就已经知道后面的代码将会声明变量a，从而不允许我们访问外层作用域中的a。</p><h2 id="class声明" tabindex="-1"><a class="header-anchor" href="#class声明"><span>class声明</span></a></h2><p>我们在之前的课程中，已经了解过class相关的用法。这里我们再从语法的角度来看一遍：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class a {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>class最基本的用法只需要class关键字、名称和一对大括号。它的声明特征跟const和let类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const a = 2;</span></span>
<span class="line"><span>if(true){</span></span>
<span class="line"><span>    console.log(a); //抛错</span></span>
<span class="line"><span>    class a {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>class内部，可以使用constructor关键字来定义构造函数。还能定义getter/setter和方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Rectangle {</span></span>
<span class="line"><span>  constructor(height, width) {</span></span>
<span class="line"><span>    this.height = height;</span></span>
<span class="line"><span>    this.width = width;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // Getter</span></span>
<span class="line"><span>  get area() {</span></span>
<span class="line"><span>    return this.calcArea();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // Method</span></span>
<span class="line"><span>  calcArea() {</span></span>
<span class="line"><span>    return this.height * this.width;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子来自MDN，它展示了构造函数、getter和方法的定义。</p><p>以目前的兼容性，class中的属性只能写在构造函数中，相关标准正在TC39讨论。</p><p>需要注意，class默认内部的函数定义都是strict模式的。</p><h2 id="函数声明" tabindex="-1"><a class="header-anchor" href="#函数声明"><span>函数声明</span></a></h2><p>函数声明使用 function 关键字。</p><p>在上一节课中，我们已经讨论过函数声明对全局作用域的影响了。这一节课，我们来看看函数声明具体的内容，我们先看一下函数声明的几种类型。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>function foo(){</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function* foo(){</span></span>
<span class="line"><span>    yield 1;</span></span>
<span class="line"><span>    yield 2;</span></span>
<span class="line"><span>    yield 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>async function foo(){</span></span>
<span class="line"><span>    await sleep(3000);</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>async function* foo(){</span></span>
<span class="line"><span>    await sleep(3000);</span></span>
<span class="line"><span>    yield 1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>带*的函数是generator，我们在前面的部分已经见过它了。生成器函数可以理解为返回一个序列的函数，它的底层是iterator机制。</p><p>async函数是可以暂停执行，等待异步操作的函数，它的底层是Promise机制。异步生成器函数则是二者的结合。</p><p>函数的参数，可以只写形参名，现在还可以写默认参数和指定多个参数，看下例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>function foo(a = 1, ...other) {</span></span>
<span class="line"><span>    console.log(a, other)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个形式可以代替一些对参数的处理代码，表意会更加清楚。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>今天我们一起学习了语句家族，语句分成了普通语句和声明型语句。</p><p>普通语句部分，建议你把重点放在循环语句上面。声明型语句我觉得都很重要，尤其是它们的行为。熟练掌握了它们，我们就可以在工作中去综合运用它们，从而减少代码中的错误。新特性大多可以帮助我们发现代码中的错误。</p><p>最后留一个小作业，请你找出所有具有Symbol.iterator的原生对象，并且看看它们的for of遍历行为。</p>`,139)]))}const t=n(l,[["render",p]]),h=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BJavaScript%E8%AF%AD%E5%8F%A5%EF%BC%9F.html","title":"JavaScript语法（二）：你知道哪些JavaScript语句？","lang":"zh-CN","frontmatter":{"description":"JavaScript语法（二）：你知道哪些JavaScript语句？ 你好，我是winter。 我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。 JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BJavaScript%E8%AF%AD%E5%8F%A5%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"JavaScript语法（二）：你知道哪些JavaScript语句？"}],["meta",{"property":"og:description","content":"JavaScript语法（二）：你知道哪些JavaScript语句？ 你好，我是winter。 我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。 JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript语法（二）：你知道哪些JavaScript语句？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":12.79,"words":3838},"filePathRelative":"posts/重学前端/模块一：JavaScript/JavaScript语法（二）：你知道哪些JavaScript语句？.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"JavaScript语法（二）：你知道哪些JavaScript语句？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/b9/36/b98805c10ae51f49492bce8a7103b936.mp3\\"></audio></p>\\n<p>你好，我是winter。</p>\\n<p>我们在上一节课中已经讲过了JavaScript语法的顶层设计，接下来我们进入到更具体的内容。</p>\\n<p>JavaScript遵循了一般编程语言的“语句-表达式”结构，多数编程语言都是这样设计的。我们在上节课讲的脚本，或者模块都是由语句列表构成的，这一节课，我们就来一起了解一下语句。</p>","autoDesc":true}');export{t as comp,h as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-6Bz2fGO5.js";const l={};function p(d,a){return i(),n("div",null,a[0]||(a[0]=[e(`<p><audio id="audio" title="30 | Java虚拟机的监控及诊断工具（命令行篇）" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/43/ca/43dd5d504bd989b429810514b702e4ca.mp3"></audio></p><p>今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。</p><h2 id="jps" tabindex="-1"><a class="header-anchor" href="#jps"><span>jps</span></a></h2><p>你可能用过<code>ps</code>命令，打印所有正在运行的进程的相关信息。JDK中的<code>jps</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html" target="_blank" rel="noopener noreferrer">帮助文档</a>）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。</p><p>在默认情况下，<code>jps</code>的输出信息包括Java进程的进程ID以及主类名。我们还可以通过追加参数，来打印额外的信息。例如，<code>-l</code>将打印模块名以及包名；<code>-v</code>将打印传递给Java虚拟机的参数（如<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>）；<code>-m</code>将打印传递给主类的参数。</p><p>具体的示例如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jps -mlv</span></span>
<span class="line"><span>18331 org.example.Foo Hello World</span></span>
<span class="line"><span>18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，如果某Java进程关闭了默认开启的<code>UsePerfData</code>参数（即使用参数<code>-XX:-UsePerfData</code>），那么<code>jps</code>命令（以及下面介绍的<code>jstat</code>）将无法探知该Java进程。</p><p>当获得Java进程的进程ID之后，我们便可以调用接下来介绍的各项监控及诊断工具了。</p><h2 id="jstat" tabindex="-1"><a class="header-anchor" href="#jstat"><span>jstat</span></a></h2><p><code>jstat</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html" target="_blank" rel="noopener noreferrer">帮助文档</a>）可用来打印目标Java进程的性能数据。它包括多条子命令，如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jstat -options</span></span>
<span class="line"><span>-class</span></span>
<span class="line"><span>-compiler</span></span>
<span class="line"><span>-gc</span></span>
<span class="line"><span>-gccapacity</span></span>
<span class="line"><span>-gccause</span></span>
<span class="line"><span>-gcmetacapacity</span></span>
<span class="line"><span>-gcnew</span></span>
<span class="line"><span>-gcnewcapacity</span></span>
<span class="line"><span>-gcold</span></span>
<span class="line"><span>-gcoldcapacity</span></span>
<span class="line"><span>-gcutil</span></span>
<span class="line"><span>-printcompilation</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这些子命令中，<code>-class</code>将打印类加载相关的数据，<code>-compiler</code>和<code>-printcompilation</code>将打印即时编译相关的数据。剩下的都是以<code>-gc</code>为前缀的子命令，它们将打印垃圾回收相关的数据。</p><p>默认情况下，<code>jstat</code>只会打印一次性能数据。我们可以将它配置为每隔一段时间打印一次，直至目标Java进程终止，或者达到我们所配置的最大打印次数。具体示例如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]</span></span>
<span class="line"><span>$ jstat -gc 22126 1s 4</span></span>
<span class="line"><span>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span></span>
<span class="line"><span>17472,0 17472,0  0,0    0,0   139904,0 47146,4   349568,0   21321,0   30020,0 28001,8 4864,0 4673,4     22    0,080   3      0,270   0      0,000    0,350</span></span>
<span class="line"><span>17472,0 17472,0 420,6   0,0   139904,0 11178,4   349568,0   21321,0   30020,0 28090,1 4864,0 4674,2     28    0,084   3      0,270   0      0,000    0,354</span></span>
<span class="line"><span>17472,0 17472,0  0,0   403,9  139904,0 139538,4  349568,0   21323,4   30020,0 28137,2 4864,0 4674,2     34    0,088   4      0,359   0      0,000    0,446</span></span>
<span class="line"><span>17472,0 17472,0  0,0    0,0   139904,0   0,0     349568,0   21326,1   30020,0 28093,6 4864,0 4673,4     38    0,091   5      0,445   0      0,000    0,536</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote></blockquote><p>当监控本地环境的Java进程时，VMID可以简单理解为PID。如果需要监控远程环境的Java进程，你可以参考jstat的帮助文档。</p><p>在上面这个示例中，22126进程是一个使用了CMS垃圾回收器的Java进程。我们利用<code>jstat</code>的<code>-gc</code>子命令，来打印该进程垃圾回收相关的数据。命令最后的<code>1s 4</code>表示每隔1秒打印一次，共打印4次。</p><p>在<code>-gc</code>子命令的输出中，前四列分别为两个Survivor区的容量（Capacity）和已使用量（Utility）。我们可以看到，这两个Survivor区的容量相等，而且始终有一个Survivor区的内存使用量为0。</p><p>当使用默认的G1 GC时，输出结果则有另一些特征：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jstat -gc 22208 1s</span></span>
<span class="line"><span>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span></span>
<span class="line"><span>0,0   16384,0  0,0   16384,0 210944,0 192512,0  133120,0    5332,5   28848,0 26886,4 4864,0 4620,5     19    0,067   1      0,016   2      0,002    0,084</span></span>
<span class="line"><span>0,0   16384,0  0,0   16384,0 210944,0 83968,0   133120,0    5749,9   29104,0 27132,8 4864,0 4621,0     21    0,078   1      0,016   2      0,002    0,095</span></span>
<span class="line"><span>0,0    0,0    0,0    0,0   71680,0  18432,0   45056,0    20285,1   29872,0 27952,4 4864,0 4671,6     23    0,089   2      0,063   2      0,002    0,153</span></span>
<span class="line"><span>0,0   2048,0  0,0   2048,0 69632,0  28672,0   45056,0    18608,1   30128,0 28030,4 4864,0 4672,4     32    0,093   2      0,063   2      0,002    0,158</span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这个示例中，<code>jstat</code>每隔1s便会打印垃圾回收的信息，并且不断重复下去。</p><p>你可能已经留意到，<code>S0C</code>和<code>S0U</code>始终为0，而且另一个Survivor区的容量（S1C）可能会下降至0。</p><p>这是因为，当使用G1 GC时，Java虚拟机不再设置Eden区、Survivor区，老年代区的内存边界，而是将堆划分为若干个等长内存区域。</p><p>每个内存区域都可以作为Eden区、Survivor区以及老年代区中的任一种，并且可以在不同区域类型之间来回切换。（<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener noreferrer">参考链接</a>）</p><p>换句话说，逻辑上我们只有一个Survivor区。当需要迁移Survivor区中的数据时（即Copying GC），我们只需另外申请一个或多个内存区域，作为新的Survivor区。</p><p>因此，Java虚拟机决定在使用G1 GC时，将所有Survivor内存区域的总容量以及已使用量存放至S1C和S1U中，而S0C和S0U则被设置为0。</p><p>当发生垃圾回收时，Java虚拟机可能出现Survivor内存区域内的对象<strong>全</strong>被回收或晋升的现象。</p><p>在这种情况下，Java虚拟机会将这块内存区域回收，并标记为可分配的状态。这样子做的结果是，堆中可能完全没有Survivor内存区域，因而相应的S1C和S1U将会是0。</p><p><code>jstat</code>还有一个非常有用的参数<code>-t</code>，它将在每行数据之前打印目标Java进程的启动时间。例如，在下面这个示例中，第一列代表该Java进程已经启动了10.7秒。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jstat -gc -t 22407</span></span>
<span class="line"><span>Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   </span></span>
<span class="line"><span>           10,7  0,0    0,0    0,0    0,0   55296,0  45056,0   34816,0    20267,8   30128,0 27975,3 4864,0 4671,6     33    0,086   3      0,111   2      0,001    0,198</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以比较Java进程的启动时间以及总GC时间（GCT列），或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p><p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。</p><p><code>jstat</code>还可以用来判断是否出现内存泄漏。在长时间运行的Java程序中，我们可以运行<code>jstat</code>命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值。</p><p>然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p><blockquote></blockquote><p>上面没有涉及的列（或者其他子命令的输出），你可以查阅帮助文档了解具体含义。至于文档中漏掉的CGC和CGCT，它们分别代表并发GC Stop-The-World的次数和时间。</p><h2 id="jmap" tabindex="-1"><a class="header-anchor" href="#jmap"><span>jmap</span></a></h2><p>在这种情况下，我们便可以请<code>jmap</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html" target="_blank" rel="noopener noreferrer">帮助文档</a>）出马，分析Java虚拟机堆中的对象。</p><p><code>jmap</code>同样包括多条子命令。</p><ol><li><code>-clstats</code>，该子命令将打印被加载类的信息。</li><li><code>-finalizerinfo</code>，该子命令将打印所有待finalize的对象。</li><li><code>-histo</code>，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，<code>-histo:live</code>只统计堆中的存活对象。</li><li><code>-dump</code>，该子命令将导出Java虚拟机堆的快照。同样，<code>-dump:live</code>只保存堆中的存活对象。</li></ol><p>我们通常会利用<code>jmap -dump:live,format=b,file=filename.bin</code>命令，将堆中所有存活对象导出至一个文件之中。</p><p>这里<code>format=b</code>将使<code>jmap</code>导出与<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr008.html" target="_blank" rel="noopener noreferrer">hprof</a>（在Java 9中已被移除）、<code>-XX:+HeapDumpAfterFullGC</code>、<code>-XX:+HeapDumpOnOutOfMemoryError</code>格式一致的文件。这种格式的文件可以被其他GUI工具查看，具体我会在下一篇中进行演示。</p><p>下面我贴了一段<code>-histo</code>子命令的输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jmap -histo 22574</span></span>
<span class="line"><span> num     #instances         #bytes  class name (module)</span></span>
<span class="line"><span>-------------------------------------------------------</span></span>
<span class="line"><span>   1:        500004       20000160  org.python.core.PyComplex</span></span>
<span class="line"><span>   2:        570866       18267712  org.python.core.PyFloat</span></span>
<span class="line"><span>   3:        360295       18027024  [B (java.base@11)</span></span>
<span class="line"><span>   4:        339394       11429680  [Lorg.python.core.PyObject;</span></span>
<span class="line"><span>   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)</span></span>
<span class="line"><span>   6:        301378        9291664  [I (java.base@11)</span></span>
<span class="line"><span>   7:        225103        9004120  java.math.BigInteger (java.base@11)</span></span>
<span class="line"><span>   8:        507362        8117792  org.python.core.PySequence$1</span></span>
<span class="line"><span>   9:        285009        6840216  org.python.core.PyLong</span></span>
<span class="line"><span>  10:        282908        6789792  java.lang.String (java.base@11)</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>2281:             1             16  traceback$py</span></span>
<span class="line"><span>2282:             1             16  unicodedata$py</span></span>
<span class="line"><span>Total       5151277      167944400</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于<code>jmap</code>将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<code>jmap</code>需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。</p><p>也就是说，由<code>jmap</code>导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>:live</code>选项将无法探知到这些对象。</p><p>另外，如果某个线程长时间无法跑到安全点，<code>jmap</code>将一直等下去。上一小节的<code>jstat</code>则不同。这是因为垃圾回收器会主动将<code>jstat</code>所需要的摘要数据保存至固定位置之中，而<code>jstat</code>只需直接读取即可。</p><p>关于这种长时间等待的情况，你可以通过下面这段程序来复现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 暂停时间较长，约为二三十秒，可酌情调整。</span></span>
<span class="line"><span>// CTRL+C的SIGINT信号无法停止，需要SIGKILL。</span></span>
<span class="line"><span>static double sum = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public static void main(String[] args) {</span></span>
<span class="line"><span>  for (int i = 0; i &amp;lt; 0x77777777; i++) { // counted loop</span></span>
<span class="line"><span>    sum += Math.log(i); // Math.log is an intrinsic</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>jmap</code>（以及接下来的<code>jinfo</code>、<code>jstack</code>和<code>jcmd</code>）依赖于Java虚拟机的<a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/com/sun/tools/attach/package-summary.html" target="_blank" rel="noopener noreferrer">Attach API</a>，因此只能监控本地Java进程。</p><p>一旦开启Java虚拟机参数<code>DisableAttachMechanism</code>（即使用参数<code>-XX:+DisableAttachMechanism</code>），基于Attach API的命令将无法执行。反过来说，如果你不想被其他进程监控，那么你需要开启该参数。</p><h2 id="jinfo" tabindex="-1"><a class="header-anchor" href="#jinfo"><span>jinfo</span></a></h2><p><code>jinfo</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html" target="_blank" rel="noopener noreferrer">帮助文档</a>）可用来查看目标Java进程的参数，如传递给Java虚拟机的<code>-X</code>（即输出中的jvm_args）、<code>-XX</code>参数（即输出中的VM Flags），以及可在Java层面通过<code>System.getProperty</code>获取的<code>-D</code>参数（即输出中的System Properties）。</p><p>具体的示例如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jinfo 31185</span></span>
<span class="line"><span>Java System Properties:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>gopherProxySet=false</span></span>
<span class="line"><span>awt.toolkit=sun.lwawt.macosx.LWCToolkit</span></span>
<span class="line"><span>java.specification.version=11</span></span>
<span class="line"><span>sun.cpu.isalist=</span></span>
<span class="line"><span>sun.jnu.encoding=UTF-8</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VM Flags:</span></span>
<span class="line"><span>-XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=2097152 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=536870912 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=5152702464 -XX:MinHeapDeltaBytes=2097152 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VM Arguments:</span></span>
<span class="line"><span>jvm_args: -Xlog:gc -Xmx1024m</span></span>
<span class="line"><span>java_command: org.example.Foo</span></span>
<span class="line"><span>java_class_path (initial): .</span></span>
<span class="line"><span>Launcher Type: SUN_STANDARD</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>jinfo</code>还可以用来修改目标Java进程的“manageable”虚拟机参数。</p><p>举个例子，我们可以使用<code>jinfo -flag +HeapDumpAfterFullGC &amp;lt;PID&amp;gt;</code>命令，开启<code>&amp;lt;PID&amp;gt;</code>所指定的Java进程的<code>HeapDumpAfterFullGC</code>参数。</p><p>你可以通过下述命令查看其他&quot;manageable&quot;虚拟机参数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ java -XX:+PrintFlagsFinal -version | grep manageable   </span></span>
<span class="line"><span>     intx CMSAbortablePrecleanWaitMillis           = 100                                    {manageable} {default}</span></span>
<span class="line"><span>     intx CMSTriggerInterval                       = -1                                     {manageable} {default}</span></span>
<span class="line"><span>     intx CMSWaitDuration                          = 2000                                   {manageable} {default}</span></span>
<span class="line"><span>     bool HeapDumpAfterFullGC                      = false                                  {manageable} {default}</span></span>
<span class="line"><span>     bool HeapDumpBeforeFullGC                     = false                                  {manageable} {default}</span></span>
<span class="line"><span>     bool HeapDumpOnOutOfMemoryError               = false                                  {manageable} {default}</span></span>
<span class="line"><span>    ccstr HeapDumpPath                             =                                        {manageable} {default}</span></span>
<span class="line"><span>    uintx MaxHeapFreeRatio                         = 70                                     {manageable} {default}</span></span>
<span class="line"><span>    uintx MinHeapFreeRatio                         = 40                                     {manageable} {default}</span></span>
<span class="line"><span>     bool PrintClassHistogram                      = false                                  {manageable} {default}</span></span>
<span class="line"><span>     bool PrintConcurrentLocks                     = false                                  {manageable} {default}</span></span>
<span class="line"><span>java version &amp;quot;11&amp;quot; 2018-09-25</span></span>
<span class="line"><span>Java(TM) SE Runtime Environment 18.9 (build 11+28)</span></span>
<span class="line"><span>Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jstack" tabindex="-1"><a class="header-anchor" href="#jstack"><span>jstack</span></a></h2><p><code>jstack</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html" target="_blank" rel="noopener noreferrer">帮助文档</a>）可以用来打印目标Java进程中各个线程的栈轨迹，以及这些线程所持有的锁。</p><p><code>jstack</code>的其中一个应用场景便是死锁检测。这里我用<code>jstack</code>获取一个已经死锁了的Java程序的栈信息。具体输出如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$ jstack 31634</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&amp;quot;Thread-0&amp;quot; #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]</span></span>
<span class="line"><span>   java.lang.Thread.State: BLOCKED (on object monitor)</span></span>
<span class="line"><span> at DeadLock.foo(DeadLock.java:18)</span></span>
<span class="line"><span> - waiting to lock &amp;lt;0x000000061ff904c0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> - locked &amp;lt;0x000000061ff904b0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)</span></span>
<span class="line"><span> at java.lang.Thread.run(java.base@11/Thread.java:834)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&amp;quot;Thread-1&amp;quot; #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]</span></span>
<span class="line"><span>   java.lang.Thread.State: BLOCKED (on object monitor)</span></span>
<span class="line"><span> at DeadLock.bar(DeadLock.java:33)</span></span>
<span class="line"><span> - waiting to lock &amp;lt;0x000000061ff904b0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> - locked &amp;lt;0x000000061ff904c0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)</span></span>
<span class="line"><span> at java.lang.Thread.run(java.base@11/Thread.java:834)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>JNI global refs: 6, weak refs: 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>Found one Java-level deadlock:</span></span>
<span class="line"><span>=============================</span></span>
<span class="line"><span>&amp;quot;Thread-0&amp;quot;:</span></span>
<span class="line"><span>  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),</span></span>
<span class="line"><span>  which is held by &amp;quot;Thread-1&amp;quot;</span></span>
<span class="line"><span>&amp;quot;Thread-1&amp;quot;:</span></span>
<span class="line"><span>  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),</span></span>
<span class="line"><span>  which is held by &amp;quot;Thread-0&amp;quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Java stack information for the threads listed above:</span></span>
<span class="line"><span>===================================================</span></span>
<span class="line"><span>&amp;quot;Thread-0&amp;quot;:</span></span>
<span class="line"><span> at DeadLock.foo(DeadLock.java:18)</span></span>
<span class="line"><span> - waiting to lock &amp;lt;0x000000061ff904c0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> - locked &amp;lt;0x000000061ff904b0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)</span></span>
<span class="line"><span> at java.lang.Thread.run(java.base@11/Thread.java:834)</span></span>
<span class="line"><span>&amp;quot;Thread-1&amp;quot;:</span></span>
<span class="line"><span> at DeadLock.bar(DeadLock.java:33)</span></span>
<span class="line"><span> - waiting to lock &amp;lt;0x000000061ff904b0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> - locked &amp;lt;0x000000061ff904c0&amp;gt; (a java.lang.Object)</span></span>
<span class="line"><span> at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)</span></span>
<span class="line"><span> at java.lang.Thread.run(java.base@11/Thread.java:834)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Found 1 deadlock.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，<code>jstack</code>不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。</p><h2 id="jcmd" tabindex="-1"><a class="header-anchor" href="#jcmd"><span>jcmd</span></a></h2><p>你还可以直接使用<code>jcmd</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html" target="_blank" rel="noopener noreferrer">帮助文档</a>），来替代前面除了<code>jstat</code>之外的所有命令。具体的替换规则你可以参考下表。</p><p>至于<code>jstat</code>的功能，虽然<code>jcmd</code>复制了<code>jstat</code>的部分代码，并支持通过<code>PerfCounter.print</code>子命令来打印所有的Performance Counter，但是它没有保留<code>jstat</code>的输出格式，也没有重复打印的功能。因此，感兴趣的同学可以自行整理。</p><p>另外，我们将在下一篇中介绍<code>jcmd</code>中Java Flight Recorder相关的子命令。</p><h2 id="总结与实践" tabindex="-1"><a class="header-anchor" href="#总结与实践"><span>总结与实践</span></a></h2><p>今天我介绍了JDK中用于监控及诊断的命令行工具。我们再来回顾一下。</p><ol><li><code>jps</code>将打印所有正在运行的Java进程。</li><li><code>jstat</code>允许用户查看目标Java进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</li><li><code>jmap</code>允许用户统计目标Java进程的堆中存放的Java对象，并将它们导出成二进制文件。</li><li><code>jinfo</code>将打印目标Java进程的配置参数，并能够改动其中manageabe的参数。</li><li><code>jstack</code>将打印目标Java进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。</li><li><code>jcmd</code>则是一把瑞士军刀，可以用来实现前面除了<code>jstat</code>之外所有命令的功能。</li></ol><p>今天的实践环节，你可以探索<code>jcmd</code>中的下述功能，看看有没有适合你项目的监控项：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Compiler.CodeHeap_Analytics</span></span>
<span class="line"><span>Compiler.codecache</span></span>
<span class="line"><span>Compiler.codelist</span></span>
<span class="line"><span>Compiler.directives_add</span></span>
<span class="line"><span>Compiler.directives_clear</span></span>
<span class="line"><span>Compiler.directives_print</span></span>
<span class="line"><span>Compiler.directives_remove</span></span>
<span class="line"><span>Compiler.queue</span></span>
<span class="line"><span>GC.class_histogram</span></span>
<span class="line"><span>GC.class_stats</span></span>
<span class="line"><span>GC.finalizer_info</span></span>
<span class="line"><span>GC.heap_dump</span></span>
<span class="line"><span>GC.heap_info</span></span>
<span class="line"><span>GC.run</span></span>
<span class="line"><span>GC.run_finalization</span></span>
<span class="line"><span>VM.class_hierarchy</span></span>
<span class="line"><span>VM.classloader_stats</span></span>
<span class="line"><span>VM.classloaders</span></span>
<span class="line"><span>VM.command_line</span></span>
<span class="line"><span>VM.dynlibs</span></span>
<span class="line"><span>VM.flags</span></span>
<span class="line"><span>VM.info</span></span>
<span class="line"><span>VM.log</span></span>
<span class="line"><span>VM.metaspace</span></span>
<span class="line"><span>VM.native_memory</span></span>
<span class="line"><span>VM.print_touched_methods</span></span>
<span class="line"><span>VM.set_flag</span></span>
<span class="line"><span>VM.stringtable</span></span>
<span class="line"><span>VM.symboltable</span></span>
<span class="line"><span>VM.system_properties</span></span>
<span class="line"><span>VM.systemdictionary</span></span>
<span class="line"><span>VM.unlock_commercial_features</span></span>
<span class="line"><span>VM.uptime</span></span>
<span class="line"><span>VM.version</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,74)]))}const r=s(l,[["render",p]]),t=JSON.parse('{"path":"/posts/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/30%20_%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89.html","title":"","lang":"zh-CN","frontmatter":{"description":"今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。 jps 你可能用过ps命令，打印所有正在运行的进程的相关信息。JDK中的jps命令（帮助文档）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。 在默认情况下，jps的输出信息包括Java进程的进程ID以及主类名。我们还可以通过...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/30%20_%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。 jps 你可能用过ps命令，打印所有正在运行的进程的相关信息。JDK中的jps命令（帮助文档）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。 在默认情况下，jps的输出信息包括Java进程的进程ID以及主类名。我们还可以通过..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":12.52,"words":3757},"filePathRelative":"posts/深入拆解Java虚拟机/模块三：代码优化/30 _ Java虚拟机的监控及诊断工具（命令行篇）.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"30 | Java虚拟机的监控及诊断工具（命令行篇）\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/43/ca/43dd5d504bd989b429810514b702e4ca.mp3\\"></audio></p>\\n<p>今天，我们来一起了解一下JDK中用于监控及诊断工具。本篇中我将使用刚刚发布的Java 11版本的工具进行示范。</p>\\n<h2>jps</h2>\\n<p>你可能用过<code>ps</code>命令，打印所有正在运行的进程的相关信息。JDK中的<code>jps</code>命令（<a href=\\"https://docs.oracle.com/en/java/javase/11/tools/jps.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">帮助文档</a>）沿用了同样的概念：它将打印所有正在运行的Java进程的相关信息。</p>","autoDesc":true}');export{r as comp,t as data};

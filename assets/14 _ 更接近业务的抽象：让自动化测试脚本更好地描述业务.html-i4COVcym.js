import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as n}from"./app-CrA-f6So.js";const i={};function t(l,e){return n(),a("div",null,e[0]||(e[0]=[s(`<h1 id="_14-更接近业务的抽象-让自动化测试脚本更好地描述业务" tabindex="-1"><a class="header-anchor" href="#_14-更接近业务的抽象-让自动化测试脚本更好地描述业务"><span>14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务</span></a></h1><p><audio id="audio" title="14 | 更接近业务的抽象：让自动化测试脚本更好地描述业务" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/ae/9d/aec932e7db396dc15fe0b595549f549d.mp3"></audio></p><p>在上一篇文章中，我介绍了GUI自动化测试中的两个主要的概念“脚本与数据的解耦 ”以及“ 页面对象模型”。在引入“操作函数”封装时，我提到操作函数在改善测试脚本可读性问题的同时，也引入了两个新的问题，即： 如何把控操作函数的粒度，以及如何衔接两个操作函数之间的页面。</p><p>现在，我就以这两个问题作为引子，为你介绍GUI自动化测试中“业务流程（business flow）”的概念、核心思想以及应用场景。</p><h2 id="如何把控操作函数的粒度" tabindex="-1"><a class="header-anchor" href="#如何把控操作函数的粒度"><span>如何把控操作函数的粒度？</span></a></h2><p><strong>操作函数的粒度是指，一个操作函数到底应该包含多少操作步骤才是最合适的。</strong></p><ul><li>如果粒度太大，就会降低操作函数的可重用性。极端的例子就是，前面文章中涉及的百度搜索的案例，把“登录”“搜索”“登出”的操作作为一个操作函数。</li><li>如果粒度太小，也就失去了操作函数封装的意义。极端的例子就是，把每一个步骤都作为一个操作函数。</li><li>更糟糕的是，在企业实际自动化测试开发中，每个测试工程师对操作函数的粒度理解也不完全相同，很有可能出现同一个项目中脚本粒度差异过大，以及某些操作函数的可重用性低的问题。</li></ul><p><strong>那么，操作函数的粒度到底应该如何控制呢？其实这个问题，在很大程度上取决于项目的实际情况，以及测试用例步骤的设计，并没有一个放之四海而皆准的绝对标准。</strong></p><p>但是，脚本粒度的控制还是有设计依据可以遵循的，即往往以完成一个业务流程（business flow）为主线，抽象出其中的“高内聚低耦合”的操作步骤集合，操作函数就由这些操作步骤集合构成。</p><p>比如，对于“用户注册”这个业务流程，其中的“信用卡绑定”操作就会涉及多个操作步骤，而这些操作在逻辑上又是相对独立的，所以就可以包装成一个操作函数。也就是说，业务流程会依次调用各个操作函数，来完成具体的业务操作。</p><h2 id="如何衔接两个操作函数之间的页面" tabindex="-1"><a class="header-anchor" href="#如何衔接两个操作函数之间的页面"><span>如何衔接两个操作函数之间的页面？</span></a></h2><p>完成一个业务流程操作，往往会需要依次调用多个操作函数，但是操作函数和操作函数之间会有页面衔接的问题，即前序操作函数完成后的最后一个页面，必须是后续操作函数的第一个页面。</p><p>如果连续的两个操作函数之间无法用页面衔接，那就需要在两个操作函数之间加入额外的页面跳转代码，或者是在操作函数内部加入特定的页面跳转代码。</p><h2 id="业务流程抽象" tabindex="-1"><a class="header-anchor" href="#业务流程抽象"><span>业务流程抽象</span></a></h2><p>在解决如何把控操作函数的粒度，以及如何衔接两个操作函数之间的页面这两个问题的过程中，我引入了业务流程的概念。那么，接下来我就跟你详细说说什么是业务流程。</p><p><strong>业务流程抽象是，基于操作函数的更接近于实际业务的更高层次的抽象方式。基于业务流程抽象实现的测试用例往往灵活性会非常好，你可以很方便地组装出各种测试用例。</strong></p><p>这个概念有点拗口，难以理解。但是，没关系，我举个例子，你就豁然开朗了。</p><p>假设，某个具体的业务流程是：已注册的用户登录电商平台购买指定的书籍。那么，基于业务流程抽象的测试用例伪代码，如图1所示。</p><img src="https://static001.geekbang.org/resource/image/a7/46/a7b02e628552dd97070c90058b755a46.png" alt=""><p>这段伪代码的信息量很大，但是理解了这段代码的设计思想，你也就掌握了业务流程抽象的精髓。</p><p><strong>首先，从整体结构上看，段伪代码顺序调用了4个业务流程，</strong> 依次是完成用户登录的LoginFlow、完成书籍查询的SearchBookFlow、完成书籍购买的CheckoutBookFlow、完成用户登出的LogoutFlow。</p><p>这4个业务流程都是作为独立的类封装的，可以被很方便的重用并灵活组合，类的内部实现通常是调用操作函数。而操作函数内部，则是基于页面对象模型完成具体的页面控件操作。</p><p><strong>然后，对于每一个业务流程类，都会有相应的业务流程输入参数类与之一一对应。具体的步骤通常有这么几步：</strong></p><li> 初始化一个业务流程输入参数类的实例； </li><li> 给这个实例赋值； </li><li> 用这个输入参数实例来初始化业务流程类的实例； </li><li> 执行这个业务流程实例。 </li><p><strong>执行业务流程实例的过程，其实就是调用操作函数来完成具体的页面对象操作的过程。</strong></p><p>为了让你更好地理解业务流程抽象提供了哪些功能，接下来我会为你逐行解读这段伪代码。</p><p><strong>伪代码的第2-6行，调用的是LoginFlow，完成了用户登录的操作。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>2: LoginFlowParameters loginFlowParameters = new LoginFlowParameters();</span></span>
<span class="line"><span>3: loginFlowParameters.setUserName(&amp;quot;username&amp;quot;);</span></span>
<span class="line"><span>4: loginFlowParameters.setPassword(&amp;quot;password&amp;quot;);</span></span>
<span class="line"><span>5: LoginFlow loginFlow = new LoginFlow(loginFlowParameters);</span></span>
<span class="line"><span>6: loginFlow.execute();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第2行，初始化了LoginFlow对应的LoginFlowParameters的实例。</p><p>第3-4行，通过setUserName和setPassword方法将用户名和密码传入该参数实例。</p><p>第5行，用这个已经赋值的参数实例来初始化LoginFlow。</p><p>第6行，通过execute方法发起执行。执行之后，LoginFlow会调用内部的操作函数，或者直接调用页面对象方法，完成用户登录的操作。</p><p><strong>伪代码的第9-12行，用和2-6行类似的方式调用了SearchBookFlow，完成了书籍搜索的操作。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>9: SearchBookFlowParameters searchBookFlowParameters = new SearchBookFlowParameters();</span></span>
<span class="line"><span>10: searchBookFlowParameters.setBookName(&amp;quot;bookname&amp;quot;);</span></span>
<span class="line"><span>11: SearchBookFlow searchBookFlow = new SearchBookFlow(searchBookFlowParameters);</span></span>
<span class="line"><span>12: searchBookFlow.withStartPage(loginFlow.getEndPage()).execute();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要特别注意的是，第12行中withStartPage(loginFlow.getEndPage())的含义是，SearchBookFlow的起始页面将会使用之前loginFlow的结束页面。显然，通过这种方式可以很方便地完成两个业务流程之间的页面衔接。</p><p>同时，从中还可以看出，其实每个业务流程都可以接受不同的起始页面。以SearchBookFlow为例，它的起始页面既可以是书籍首页，也可以是其他页面，但是需要在它的内部对不同的初始页面做出相应的处理，以保证这个业务流程真正开始的页面是在书籍搜索页面。</p><p>同样，由于业务流程存在分支的可能性，每个业务流程执行完成的最终页面也不是唯一的，你可以使用getEndPage方法拿到这个业务流程执行结束后的最后页面。</p><p>通过这段代码的解读，你可以很清楚地理解，业务流程之间的页面衔接是如何实现的。</p><p><strong>伪代码的第15-18行，调用了CheckoutBookFlow，完成了书籍购买操作。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>15: CheckoutBookFlowParameters checkoutBookFlowParameters = new CheckoutBookFlowParameters();</span></span>
<span class="line"><span>16: checkoutBookFlowParameters.setBookID(searchBookFlow.getOutPut().getBookID());</span></span>
<span class="line"><span>17: CheckoutBookFlow checkoutBookFlow = new CheckoutBookFlow(checkoutBookFlowParameters);</span></span>
<span class="line"><span>18: checkoutBookFlow.withStartPage(searchBookFlow.getEndPage()).execute();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第15行，初始化了CheckoutBookFlow对应的checkoutBookFlowParameters的实例。</p><p>第16行，通过setBookID(searchBookFlow.getOutPut().getBookID())，将上一个业务流程searchBookFlow的输出参数，作为了当前业务流程的输入参数。这是典型的业务流程之间如何传递参数的示例，也是很多测试场景中都要用到的。</p><p>第17行，用checkoutBookFlowParameters参数实例来初始化checkoutBookFlow。</p><p>第18行，通过execute方法发起执行。这里需要注意的是，checkoutBookFlow的起始页面将会使用之前searchBookFlow的结束页面。开始执行后，checkoutBookFlow会调用内部的操作函数，或者直接调用页面对象方法，完成书籍的购买操作。</p><p><strong>伪代码的第21-22行，调用LogoutFlow，完成了用户登出操作。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>21: LogoutFlow logoutFlow = new LogoutFlow();</span></span>
<span class="line"><span>22: logoutFlow.withStartPage(checkoutBookFlow.getEndPage()).execute();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>第21行，由于LogoutFlow不带参数，所以直接初始化了LogoutFlow。</p><p>第22行，通过execute方法发起执行。这里LogoutFlow的起始页面将会使用之前CheckoutBookFlow的结束页面。开始执行后，LogoutFlow会调用内部的操作函数，或者直接调用页面对象方法，完成用户登出操作。</p><p>通过对这些代码的解读，我解释了业务流程是什么，并从使用者的角度分析了它的主要特点。比如，如何实现不同业务流程间的页面衔接，如何在不同的业务流程间传递参数等。</p><p>为了加深印象，我再来总结一下业务流程的优点：</p><li> 业务流程（Business Flow）的封装更接近实际业务； </li><li> 基于业务流程的测试用例非常标准化，遵循“参数准备”、“实例化Flow”和“执行Flow”这三个大步骤，非常适用于测试代码的自动生成； </li><li> 由于更接近实际业务，所以可以很方便地和BDD结合。BDD就是Behavior Driven Development，即行为驱动开发，我会在后续文章中详细讲解。 </li><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>我以如何把控操作函数的粒度，和如何衔接两个操作函数之间的页面，这两个问题为引子，为你介绍了业务流程的概念、核心思想和适用的场景。</p><p>业务流程抽象是，基于操作函数的更接近于实际业务的更高层次的抽象方式。基于业务流程抽象实现的测试用例往往具有较好的灵活性，可以根据实际测试需求方便地组装出各种测试用例。</p><p>业务流程的核心思想是，从业务的维度来指导测试业务流程的封装。由于业务流程封装通常很贴近实际业务，所以特别适用于组装面向终端用户的端到端（E2E）的系统功能测试用例，尤其适用于业务功能非常多，并且存在各种组合的E2E测试场景。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>你所在公司的GUI自动化测试是否已经运用了业务流程级别的封装？在使用过程中，你是否遇到什么瓶颈，是如何解决的？</p><p>欢迎你给我留言。</p>`,63)]))}const c=o(i,[["render",t]]),d=JSON.parse('{"path":"/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9552%E8%AE%B2/GUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%AF%87/14%20_%20%E6%9B%B4%E6%8E%A5%E8%BF%91%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%8F%8F%E8%BF%B0%E4%B8%9A%E5%8A%A1.html","title":"14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务","lang":"zh-CN","frontmatter":{"description":"14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务 在上一篇文章中，我介绍了GUI自动化测试中的两个主要的概念“脚本与数据的解耦 ”以及“ 页面对象模型”。在引入“操作函数”封装时，我提到操作函数在改善测试脚本可读性问题的同时，也引入了两个新的问题，即： 如何把控操作函数的粒度，以及如何衔接两个操作函数之间的页面。 现在，我就以这两个问题作为引...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9552%E8%AE%B2/GUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%AF%87/14%20_%20%E6%9B%B4%E6%8E%A5%E8%BF%91%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%8F%8F%E8%BF%B0%E4%B8%9A%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务"}],["meta",{"property":"og:description","content":"14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务 在上一篇文章中，我介绍了GUI自动化测试中的两个主要的概念“脚本与数据的解耦 ”以及“ 页面对象模型”。在引入“操作函数”封装时，我提到操作函数在改善测试脚本可读性问题的同时，也引入了两个新的问题，即： 如何把控操作函数的粒度，以及如何衔接两个操作函数之间的页面。 现在，我就以这两个问题作为引..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":9.14,"words":2741},"filePathRelative":"posts/软件测试52讲/GUI自动化测试篇/14 _ 更接近业务的抽象：让自动化测试脚本更好地描述业务.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"14 | 更接近业务的抽象：让自动化测试脚本更好地描述业务\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/ae/9d/aec932e7db396dc15fe0b595549f549d.mp3\\"></audio></p>\\n<p>在上一篇文章中，我介绍了GUI自动化测试中的两个主要的概念“脚本与数据的解耦 ”以及“ 页面对象模型”。在引入“操作函数”封装时，我提到操作函数在改善测试脚本可读性问题的同时，也引入了两个新的问题，即： 如何把控操作函数的粒度，以及如何衔接两个操作函数之间的页面。</p>","autoDesc":true}');export{c as comp,d as data};

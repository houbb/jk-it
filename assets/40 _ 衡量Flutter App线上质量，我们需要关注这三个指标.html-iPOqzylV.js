import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-CrA-f6So.js";const p={};function l(r,n){return i(),a("div",null,n[0]||(n[0]=[e(`<h1 id="_40-衡量flutter-app线上质量-我们需要关注这三个指标" tabindex="-1"><a class="header-anchor" href="#_40-衡量flutter-app线上质量-我们需要关注这三个指标"><span>40 _ 衡量Flutter App线上质量，我们需要关注这三个指标</span></a></h1><p><audio id="audio" title="40 | 衡量Flutter App线上质量，我们需要关注这三个指标" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/64/13/64f57505dd24028f093afc9f00a7f313.mp3"></audio></p><p>你好，我是陈航。</p><p>在上一篇文章中，我与你分享了如何捕获Flutter应用的未处理异常。所谓异常，指的是Dart代码在运行时意外发生的错误事件。对于单一异常来说，我们可以使用try-catch，或是catchError去处理；而如果我们想对异常进行集中的拦截治理，则需要使用Zone，并结合FlutterError进行统一管理。异常一旦被抓取，我们就可以利用第三方数据上报服务（比如Bugly），上报其上下文信息了。</p><p>这些线上异常的监控数据，对于开发者尽早发现线上隐患，确定问题根因至关重要。如果我们想进一步评估应用整体的稳定性的话，就需要把异常信息与页面的渲染关联起来。比如，页面渲染过程是否出现了异常，而导致功能不可用？</p><p>而对于以“丝般顺滑”著称的Flutter应用而言，页面渲染的性能同样需要我们重点关注。比如，界面渲染是否出现会掉帧卡顿现象，或者页面加载是否会出现性能问题导致耗时过长？这些问题，虽不至于让应用完全不能使用，但也很容易引起用户对应用质量的质疑，甚至是反感。</p><p>通过上面的分析，可以看到，衡量线上Flutter应用整体质量的指标，可以分为以下3类：</p><ul><li>页面异常率；</li><li>页面帧率；</li><li>页面加载时长。</li></ul><p>其中，页面异常率反应了页面的健康程度，页面帧率反应了视觉效果的顺滑程度，而页面加载时长则反应了整个渲染过程中点对点的延时情况。</p><p>这三项数据指标，是度量Flutter应用是否优秀的重要质量指标。通过梳理这些指标的统计口径，建立起Flutter应用的质量监控能力，这样一来我们不仅可以及早发现线上隐患，还可以确定质量基线，从而持续提升用户体验。</p><p>所以在今天的分享中，我会与你详细讲述这3项指标是如何采集的。</p><h2 id="页面异常率" tabindex="-1"><a class="header-anchor" href="#页面异常率"><span>页面异常率</span></a></h2><p>页面异常率指的是，页面渲染过程中出现异常的概率。它度量的是页面维度下功能不可用的情况，其统计公式为：<strong>页面异常率=异常发生次数/整体页面PV数</strong>。</p><p>在了解了页面异常率的统计口径之后，接下来我们分别来看一下这个公式中的分子与分母应该如何统计吧。</p><p>我们先来看看<strong>异常发生次数的统计方法</strong>。通过上一篇文章，我们已经知道了在Flutter中，未处理异常需要通过Zone与FlutterError去捕获。所以，如果我们想统计异常发生次数的话，依旧是利用这两个方法，只不过要在异常拦截的方法中，通过一个计数器进行累加，统一记录。</p><p>下面的例子演示了异常发生次数的具体统计方法。我们使用全局变量exceptionCount，在异常捕获的回调方法_reportError中持续地累加捕获到的异常次数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int exceptionCount = 0; </span></span>
<span class="line"><span>Future&amp;lt;Null&amp;gt; _reportError(dynamic error, dynamic stackTrace) async {</span></span>
<span class="line"><span>  exceptionCount++; //累加异常次数</span></span>
<span class="line"><span>  FlutterCrashPlugin.postException(error, stackTrace);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Future&amp;lt;Null&amp;gt; main() async {</span></span>
<span class="line"><span>  FlutterError.onError = (FlutterErrorDetails details) async {</span></span>
<span class="line"><span>    //将异常转发至Zone</span></span>
<span class="line"><span>    Zone.current.handleUncaughtError(details.exception, details.stack);</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  runZoned&amp;lt;Future&amp;lt;Null&amp;gt;&amp;gt;(() async {</span></span>
<span class="line"><span>    runApp(MyApp());</span></span>
<span class="line"><span>  }, onError: (error, stackTrace) async {</span></span>
<span class="line"><span>    //拦截异常</span></span>
<span class="line"><span>    await _reportError(error, stackTrace);</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们再看看<strong>整体页面PV数如何统计</strong>吧。整体页面PV数，其实就是页面的打开次数。通过第21篇文章“<a href="https://time.geekbang.org/column/article/118421" target="_blank" rel="noopener noreferrer">路由与导航，Flutter是这样实现页面切换的</a>”，我们已经知道了Flutter页面的切换需要经过Navigator来实现，所以页面切换状态也需要通过Navigator才能感知到。</p><p>与注册页面路由类似的，在MaterialApp中，我们可以通过NavigatorObservers属性，去监听页面的打开与关闭。下面的例子演示了<strong>NavigatorObserver的具体用法</strong>。在下面的代码中，我们定义了一个继承自NavigatorObserver的观察者，并在其didPush方法中，去统计页面的打开行为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int totalPV = 0;</span></span>
<span class="line"><span>//导航监听器</span></span>
<span class="line"><span>class MyObserver extends NavigatorObserver{</span></span>
<span class="line"><span>  @override</span></span>
<span class="line"><span>  void didPush(Route route, Route previousRoute) {</span></span>
<span class="line"><span>    super.didPush(route, previousRoute);</span></span>
<span class="line"><span>    totalPV++;//累加PV</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class MyApp extends StatelessWidget {</span></span>
<span class="line"><span>  @override</span></span>
<span class="line"><span>  Widget build(BuildContext context) {</span></span>
<span class="line"><span>    return  MaterialApp(</span></span>
<span class="line"><span>    //设置路由监听</span></span>
<span class="line"><span>       navigatorObservers: [</span></span>
<span class="line"><span>         MyObserver(),</span></span>
<span class="line"><span>       ],</span></span>
<span class="line"><span>       home: HomePage(),</span></span>
<span class="line"><span>    ); </span></span>
<span class="line"><span>  }   </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们已经收集到了异常发生次数和整体页面PV数这两个参数，接下来我们就可以计算出页面异常率了：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>double pageException() {</span></span>
<span class="line"><span>  if(totalPV == 0) return 0;</span></span>
<span class="line"><span>  return exceptionCount/totalPV;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，页面异常率的计算还是相对比较简单的。</p><h2 id="页面帧率" tabindex="-1"><a class="header-anchor" href="#页面帧率"><span>页面帧率</span></a></h2><p>页面帧率，即FPS，是图像领域中的定义，指的是画面每秒传输帧数。由于人眼的视觉暂留特质，当所见到的画面传输帧数高于一定数量的时候，就会认为是连贯性的视觉效果。因此，对于动态页面而言，每秒钟展示的帧数越多，画面就越流畅。</p><p>由此我们可以得出，<strong>FPS的计算口径为单位时间内渲染的帧总数</strong>。在移动设备中，FPS的推荐数值通常是60Hz，即每秒刷新页面60次。</p><p>为什么是60Hz，而不是更高或更低的值呢？这是因为显示过程，是由VSync信号周期性驱动的，而VSync信号的周期就是每秒60次，这也是FPS的上限。</p><p>CPU与GPU在接收到VSync信号后，就会计算图形图像，准备渲染内容，并将其提交到帧缓冲区，等待下一次VSync信号到来时显示到屏幕上。如果在一个VSync时间内，CPU或者GPU没有完成内容提交，这一帧就会被丢弃，等待下一次机会再显示，而这时页面会保留之前的内容不变，造成界面卡顿。因此，FPS低于60Hz时就会出现掉帧现象，而如果低于45Hz则会有比较严重的卡顿现象。</p><p>为方便开发者统计FPS，Flutter在全局window对象上提供了帧回调机制。我们可以<strong>在window对象上注册onReportTimings方法</strong>，将最近绘制帧耗费的时间（即FrameTiming），以回调的形式告诉我们。有了每一帧的绘制时间后，我们就可以计算FPS了。</p><p>需要注意的是，onReportTimings方法只有在有帧被绘制时才有数据回调，如果用户没有和App发生交互，界面状态没有变化时，是不会产生新的帧的。考虑到单个帧的绘制时间差异较大，逐帧计算可能会产生数据跳跃，所以为了让FPS的计算更加平滑，我们需要保留最近25个FrameTiming用于求和计算。</p><p>而另一方面，对于FPS的计算，我们并不能孤立地只考虑帧绘制时间，而应该结合VSync信号的周期，即1/60秒（即16.67毫秒）来综合评估。</p><p>由于帧的渲染是依靠VSync信号驱动的，如果帧绘制的时间没有超过16.67毫秒，我们也需要把它当成16.67毫秒来算，因为绘制完成的帧必须要等到下一次VSync信号来了之后才能渲染。而如果帧绘制时间超过了16.67毫秒，则会占用后续的VSync信号周期，从而打乱后续的绘制次序，产生卡顿现象。这里有两种情况：</p><ul><li>如果帧绘制时间正好是16.67的整数倍，比如50，则代表它花费了3个VSync信号周期，即本来可以绘制3帧，但实际上只绘制了1帧；</li><li>如果帧绘制时间不是16.67的整数倍，比如51，那么它花费的VSync信号周期应该向上取整，即4个，这意味着本来可以绘制4帧，实际上只绘制了1帧。</li></ul><p>所以我们的FPS计算公式最终确定为：<strong>FPS=60*实际渲染的帧数/本来应该在这个时间内渲染完成的帧数</strong>。</p><p>下面的示例演示了如何通过onReportTimings回调函数实现FPS的计算。在下面的代码中，我们定义了一个容量为25的列表，用于存储最近的帧绘制耗时FrameTiming。在FPS的计算函数中，我们将列表中每帧绘制时间与VSync周期frameInterval进行比较，得出本来应该绘制的帧数，最后两者相除就得到了FPS指标。</p><p>需要注意的是，Android Studio提供的Flutter插件里展示的FPS信息，其实也来自于onReportTimings回调，所以我们在注册回调时需要保留原始回调引用，否则插件就读不到FPS信息了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import &#39;dart:ui&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var orginalCallback;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void main() {</span></span>
<span class="line"><span>  runApp(MyApp());</span></span>
<span class="line"><span>  //设置帧回调函数并保存原始帧回调函数</span></span>
<span class="line"><span>  orginalCallback = window.onReportTimings;</span></span>
<span class="line"><span>  window.onReportTimings = onReportTimings;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//仅缓存最近25帧绘制耗时</span></span>
<span class="line"><span>const maxframes = 25;</span></span>
<span class="line"><span>final lastFrames = List&amp;lt;FrameTiming&amp;gt;();</span></span>
<span class="line"><span>//基准VSync信号周期</span></span>
<span class="line"><span>const frameInterval = const Duration(microseconds: Duration.microsecondsPerSecond ~/ 60);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void onReportTimings(List&amp;lt;FrameTiming&amp;gt; timings) {</span></span>
<span class="line"><span>  lastFrames.addAll(timings);</span></span>
<span class="line"><span>  //仅保留25帧</span></span>
<span class="line"><span>  if(lastFrames.length &amp;gt; maxframes) {</span></span>
<span class="line"><span>    lastFrames.removeRange(0, lastFrames.length - maxframes);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  //如果有原始帧回调函数，则执行</span></span>
<span class="line"><span>  if (orginalCallback != null) {</span></span>
<span class="line"><span>    orginalCallback(timings);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>double get fps {</span></span>
<span class="line"><span>  int sum = 0;</span></span>
<span class="line"><span>  for (FrameTiming timing in lastFrames) {</span></span>
<span class="line"><span>    //计算渲染耗时</span></span>
<span class="line"><span>    int duration = timing.timestampInMicroseconds(FramePhase.rasterFinish) - timing.timestampInMicroseconds(FramePhase.buildStart);</span></span>
<span class="line"><span>    //判断耗时是否在Vsync信号周期内</span></span>
<span class="line"><span>    if(duration &amp;lt; frameInterval.inMicroseconds) {</span></span>
<span class="line"><span>      sum += 1;</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>      //有丢帧，向上取整</span></span>
<span class="line"><span>      int count = (duration/frameInterval.inMicroseconds).ceil();</span></span>
<span class="line"><span>      sum += count;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return lastFrames.length/sum * 60;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行这段代码，可以看到，我们统计的FPS指标和Flutter插件展示的FPS走势是一致的。</p><img src="https://static001.geekbang.org/resource/image/a8/1b/a807f4338b5a1979f7255ad2a3bb051b.png" alt=""><h2 id="页面加载时长" tabindex="-1"><a class="header-anchor" href="#页面加载时长"><span>页面加载时长</span></a></h2><p>页面加载时长，指的是页面从创建到可见的时间。它反应的是代码中创建页面视图是否存在过度绘制，或者绘制不合理导致创建视图时间过长的情况。</p><p>从定义可以看出，<strong>页面加载时长的统计口径为页面可见的时间-页面创建的时间</strong>。获取页面创建的时间比较容易，我们只需要在页面的初始化函数里记录时间即可。那么，<strong>页面可见的时间应该如何统计</strong>呢？</p><p>在第11篇文章“<a href="https://time.geekbang.org/column/article/109490" target="_blank" rel="noopener noreferrer">提到生命周期，我们是在说什么？</a>”中，我在介绍Widget的生命周期时，曾向你介绍过Flutter的帧回调机制。WidgetsBinding提供了单次Frame回调addPostFrameCallback方法，它会在当前Frame绘制完成之后进行回调，并且只会回调一次。一旦监听到Frame绘制完成回调后，我们就可以确认页面已经被渲染出来了，因此我们可以借助这个方法去获取页面可见的时间。</p><p>下面的例子演示了如何通过帧回调机制获取页面加载时长。在下面的代码中，我们在页面MyPage的初始化方法中记录了页面的创建时间startTime，然后在页面状态的初始化方法中，通过addPostFrameCallback注册了单次帧绘制回调，并在回调函数中记录了页面的渲染完成时间endTime。将这两个时间做减法，我们就得到了MyPage的页面加载时长：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class MyHomePage extends StatefulWidget {</span></span>
<span class="line"><span>  int startTime;</span></span>
<span class="line"><span>  int endTime;</span></span>
<span class="line"><span>  MyHomePage({Key key}) : super(key: key) {</span></span>
<span class="line"><span>    //页面初始化时记录启动时间</span></span>
<span class="line"><span>    startTime = DateTime.now().millisecondsSinceEpoch;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  @override</span></span>
<span class="line"><span>  _MyHomePageState createState() =&amp;gt; _MyHomePageState();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {</span></span>
<span class="line"><span>  @override</span></span>
<span class="line"><span>  void initState() {</span></span>
<span class="line"><span>    super.initState();</span></span>
<span class="line"><span>    //通过帧绘制回调获取渲染完成时间</span></span>
<span class="line"><span>    WidgetsBinding.instance.addPostFrameCallback((_) {</span></span>
<span class="line"><span>      widget.endTime = DateTime.now().millisecondsSinceEpoch;</span></span>
<span class="line"><span>      int timeSpend = widget.endTime - widget.startTime;</span></span>
<span class="line"><span>      print(&amp;quot;Page render time:\${timeSpend} ms&amp;quot;);</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>试着运行一下代码，观察命令行输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>flutter: Page render time:548 ms</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以看到，通过单次帧绘制回调统计得出的页面加载时间为548毫秒。</p><p>至此，我们就已经得到了页面异常率、页面帧率和页面加载时长这3个指标了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，今天的分享就到这里，我们来总结下主要内容吧。</p><p>今天我们一起学习了衡量Flutter应用线上质量的3个指标，即页面异常率、页面帧率和页面加载时长，以及分别对应的数据采集方式。</p><p>其中，页面异常率表示页面渲染过程中的稳定性，可以通过集中捕获未处理异常，结合NavigatorObservers观察页面PV，计算得出页面维度下功能不可用的概率。</p><p>页面帧率则表示了页面的流畅情况，可以利用Flutter提供的帧绘制耗时回调onReportTimings，以加权的形式计算出本应该绘制的帧数，得到更为准确的FPS。</p><p>而页面加载时长，反应的是渲染过程的延时情况。我们可以借助于单次帧回调机制，来获取页面渲染完成时间，从而得到整体页面的加载时长。</p><p>通过这3个数据指标统计方法，我们再去评估Flutter应用的性能时，就有一个具体的数字化标准了。而有了数据之后，我们不仅可以及早发现问题隐患，准确定位及修复问题，还可以根据它们去评估应用的健康程度和页面的渲染性能，从而确定后续的优化方向。</p><p>我把今天分享涉及的知识点打包到了<a href="https://github.com/cyndibaby905/40_peformance_demo" target="_blank" rel="noopener noreferrer">GitHub</a>中，你可以下载下来，反复运行几次，加深理解与记忆。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>最后，我给你留一道思考题吧。</p><p>如果页面的渲染需要依赖单个或多个网络接口数据，这时的页面加载时长应该如何统计呢？</p><p>欢迎你在评论区给我留言分享你的观点，我会在下一篇文章中等待你！感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>`,61)]))}const c=s(p,[["render",l]]),o=JSON.parse('{"path":"/posts/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/Flutter%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/40%20_%20%E8%A1%A1%E9%87%8FFlutter%20App%E7%BA%BF%E4%B8%8A%E8%B4%A8%E9%87%8F%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E8%BF%99%E4%B8%89%E4%B8%AA%E6%8C%87%E6%A0%87.html","title":"40 _ 衡量Flutter App线上质量，我们需要关注这三个指标","lang":"zh-CN","frontmatter":{"description":"40 _ 衡量Flutter App线上质量，我们需要关注这三个指标 你好，我是陈航。 在上一篇文章中，我与你分享了如何捕获Flutter应用的未处理异常。所谓异常，指的是Dart代码在运行时意外发生的错误事件。对于单一异常来说，我们可以使用try-catch，或是catchError去处理；而如果我们想对异常进行集中的拦截治理，则需要使用Zone，并...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/Flutter%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/40%20_%20%E8%A1%A1%E9%87%8FFlutter%20App%E7%BA%BF%E4%B8%8A%E8%B4%A8%E9%87%8F%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E8%BF%99%E4%B8%89%E4%B8%AA%E6%8C%87%E6%A0%87.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"40 _ 衡量Flutter App线上质量，我们需要关注这三个指标"}],["meta",{"property":"og:description","content":"40 _ 衡量Flutter App线上质量，我们需要关注这三个指标 你好，我是陈航。 在上一篇文章中，我与你分享了如何捕获Flutter应用的未处理异常。所谓异常，指的是Dart代码在运行时意外发生的错误事件。对于单一异常来说，我们可以使用try-catch，或是catchError去处理；而如果我们想对异常进行集中的拦截治理，则需要使用Zone，并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"40 _ 衡量Flutter App线上质量，我们需要关注这三个指标\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":12.01,"words":3604},"filePathRelative":"posts/Flutter核心技术与实战/Flutter综合应用/40 _ 衡量Flutter App线上质量，我们需要关注这三个指标.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"40 | 衡量Flutter App线上质量，我们需要关注这三个指标\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/64/13/64f57505dd24028f093afc9f00a7f313.mp3\\"></audio></p>\\n<p>你好，我是陈航。</p>\\n<p>在上一篇文章中，我与你分享了如何捕获Flutter应用的未处理异常。所谓异常，指的是Dart代码在运行时意外发生的错误事件。对于单一异常来说，我们可以使用try-catch，或是catchError去处理；而如果我们想对异常进行集中的拦截治理，则需要使用Zone，并结合FlutterError进行统一管理。异常一旦被抓取，我们就可以利用第三方数据上报服务（比如Bugly），上报其上下文信息了。</p>","autoDesc":true}');export{c as comp,o as data};

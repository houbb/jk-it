import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,s){return i(),a("div",null,s[0]||(s[0]=[e(`<p><audio id="audio" title="第20讲 | 脚本语言在游戏开发中有哪些应用？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/de/3b/dee9c9b0ac13b8adef126d53d397b53b.mp3"></audio></p><p>上一次，我们谈到了如何在游戏中嵌入脚本语言，我们用的语言是Lua。Lua语言具有轻量级、速度快的特点，而且API的调用也非常方便和直观。现在，我们仍然拿Lua脚本，试着把它应用在我们开发的游戏中。</p><p>我们使用C语言来对Lua脚本的绑定做一次深入的剖析，然后来看一下，在游戏开发中绑定了脚本语言后，脚本语言能做些什么事情。</p><p>首先，我们要明白一点，事实上<strong>任何模块都可以使用脚本语言编写</strong>。当然在游戏开发的过程中，需要分工明确，如果不分工的话，效率可能会比较低。</p><p>在需要某些效率要求非常高的情况下，一般是用C、C++或ASM语言，将底层模块搭建好，然后将一些逻辑部分分出来，给脚本语言处理。比如我们熟知的服务器端，可以使用C/C++来编写服务器端的IOCP或者epoll处理；而接收、发送、逻辑处理等等，都可以使用绑定脚本的方式编写。</p><p>我们在编写的过程中，需要对C/C++的语言和代码有个了解，我们需要先考虑这个函数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int test_func(lua_State *L)    </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>     return 0;    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这只是一个空的C函数，在这个函数里面，我们看到它的传入参数是lua_State，接受一个指针L。随后，这个函数返回一个0。</p><p>lua_State是Lua虚拟机的对象指针，也就是我们需要把前面new出来的一个虚拟机传进去，才可以保证在这个函数里面，使用的是一致的虚拟机。</p><p>这个函数的作用是，<strong>只要注册到了Lua虚拟机里面，它就是lua的一个函数，其中在lua函数中，传入的参数由函数内部决定</strong>。</p><p>比如我可以这么写：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int test_func(lua_State *L)    </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>     const char *p1 = lua_tostring(L, 1);    </span></span>
<span class="line"><span>     const char *p2 = lua_tostring(L, 2);    </span></span>
<span class="line"><span>     // .... do something    </span></span>
<span class="line"><span>     lua_pushstring(L, &amp;quot;something&amp;quot;);    </span></span>
<span class="line"><span>     return 1;    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面，lua_tosting 就是这个函数的传入参数，传入的是一个字符串的参数；第二个参数也是字符串参数，其中 lua_tosting 的第二个参数1或者2，表明的是在Lua虚拟机的堆栈中从栈底到栈顶开始计数，一般先压入的参数在第一个，后压入的在第二个，以此类推。返回1的意思是，这个函数会返回一个参数，这个参数就是我们前面 lua_pushstring 后压入的这个内容something，这就是返回的参数。</p><p>那么这个函数究竟怎么注册成为Lua函数呢？我们来看这段代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>lua_register(L, &amp;quot;test&amp;quot;, &amp;amp;test_func);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>lua_register函数的功能是，注册C函数到Lua虚拟机。其中L是虚拟机指针。这个在前面的代码都有说到，而第二个参数test就是注册在Lua虚拟机中的函数名，所以这个函数名叫test。第三个参数是函数指针，我们把test_func这个函数传入到lua_register函数中。这样，一个函数就注册好了。</p><p>那么，如果我们在游戏中有许多许多的函数需要注册到Lua中，那么这种写法是不是太慢了，有没有一种快捷的写法来支持注册等操作呢？</p><p>如果你没有C/C++的语言基础，或者C/C++语言基础比较薄弱，下面的内容可能需要花一点时间消化，我也会竭尽所能解释清楚代码的意思，但如果你已经是个C/C++程序员，那么下面的代码对你来说应该不会太难。</p><p>我们需要使用lua_register，我们先看它里面有什么参数。第一个是<strong>字符串</strong>，也就是<strong>char*；<strong>第二个是</strong>函数指针</strong>，也就是<strong>int (</strong>)(lua_State**)** 这种形式的。</p><p>那么，我们需要定义一个struct结构，这个结构可以这么写：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   #define _max 256    </span></span>
<span class="line"><span>    typedef struct _ph_func    </span></span>
<span class="line"><span>    {    </span></span>
<span class="line"><span>          char ph_name[_max];    </span></span>
<span class="line"><span>          int (*ph_p_func)(lua_State*);    </span></span>
<span class="line"><span>    } ph_func;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们定义了一个struct结构，这个结构的名字叫_ph_func，名字叫什么并没有关系，但是最开始有一个typedef，这说明在这个结构声明完后，接下来最后一行ph_func就是替代最初定义的那个_ph_func的名字，替代的结果是，<strong>ph_func 等同于struct _ph_func</strong>，这在很多C语言的代码里面经常能见到。</p><p>接下来，我们看到char ph_name[_max]。其中_max的值为256。我相信你应该能理解这句话。第二个变量就是我们所看到的函数指针，其中ph_p_func是函数指针，其中函数指针指向的内容目前暂时还没有确定，我们将在后续初始化这个结构变量的时候进行赋值。</p><p>我们来仔细看一下这两段宏的内容。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define func_reg(fname) #fname, &amp;amp;ph_##fname</span></span>
<span class="line"><span>#define func_lua(fname) int ph_##fname(lua_State* L)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中func_reg是在给前面那个结构体初始化赋值的时候使用的，因为我们知道，如果我们需要给这个结构体赋值，看起来的代码是这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ph_func pobj =  {&amp;quot;test&amp;quot;, &amp;amp;test_func};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么由于我们有大量的函数需要注册，所以我们将之拆分为宏，其中#fname的意思是，将fname变为字符串，而ph_##fname的意思是使用##字符，将前后内容连接起来。</p><p>通过这个宏，比如我们输入一个a赋值给 fname，那么#fname就变成字符串&quot;a&quot;，通过 ph_##fname，结果就是ph_a。</p><p>接下来的代码，是方便在代码中编写一个一个lua注册函数用的，所以很明显，和上述的宏一样，我们只需要输入a，那么这个函数就变成了 int ph_a(lua_State* L)；</p><p>定义好了这两个宏，我们怎么来应用呢？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>func_lua(test_func);</span></span>
<span class="line"><span>          </span></span>
<span class="line"><span>ph_func p_funcs[] =    </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>      { func_reg(test_func) },    </span></span>
<span class="line"><span>};    </span></span>
<span class="line"><span>func_lua(test_func)    </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>     const char *p1 = lua_tostring(L, 1);    </span></span>
<span class="line"><span>     const char *p2 = lua_tostring(L, 2);    </span></span>
<span class="line"><span>     // .... do something    </span></span>
<span class="line"><span>     lua_pushstring(L, &amp;quot;something&amp;quot;);    </span></span>
<span class="line"><span>     return 1;    </span></span>
<span class="line"><span>}    </span></span>
<span class="line"><span>void register_func(lua_State* L)    </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>      int i;    </span></span>
<span class="line"><span>      for(i=0; i&amp;lt;sizeof(p_funcs)/sizeof(p_funcs[0]); i++)    </span></span>
<span class="line"><span>      lua_register(L, p_funcs[i].ph_name,  p_funcs[i].ph_p_func);    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，联系上面的宏，第一行代码是使用func_lua，所以func_lua输入的宏参数是test_func。于是，通过这个宏，我们最终得到的函数名字是int ph_test_func(lua_State* L); 。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ph_func p_funcs[] =  </span></span>
<span class="line"><span>{    </span></span>
<span class="line"><span>      { func_reg(test_func) },    </span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码，使用的是func_reg的宏。test_func最终在宏里面，变成了 “test_func”，以及&amp;ph_test_func函数指针。</p><p>最后我们来看一个重要的函数，<strong>register_func</strong>，这个函数在后续将会输入一个Lua虚拟机指针，但是我们要知道它在函数内部它做了什么东西。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int i;    </span></span>
<span class="line"><span>for(i=0; i&amp;lt;sizeof(p_funcs)/sizeof(p_funcs[0]); i++)    </span></span>
<span class="line"><span>      lua_register(L, p_funcs[i].ph_name,  p_funcs[i].ph_p_func)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在循环里面，我们计算p_funcs的结构数组的长度，怎么计算的呢？</p><p>首先，我们使用sizeof编译器内置函数，来取得p_funcs整个数组的长度，这整个长度等于sizeof(ph_func)的值乘以数组长度。而ph_func结构体拥有一个字符串数组，每个数组长度是256，加上一个函数指针为4字节长，所以长度是260。而如果有两个数组元素，那就是520的长度。</p><p>以此类推，/sizeof(p_funcs[0]的意思是，我们取出第一个数组的长度作为被除数。事实上就是结构体本身的长度，所以就是结构体数组总长度除以结构体长度，就是一共有多少数组元素，随后进行循环。</p><p>在循环的过程中，我们看到，我们填入了结构体里面的两个变量ph_name以及ph_p_func，这样一来，我们只需要通过宏加上一些小技巧，就可以把Lua的函数都注册到C程序里面，我们假设这个C程序就是游戏的话，那么我们很容易就可以和Lua进行互通了。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>我总结一下今天所讲的内容。</p><li> 在Lua与C的结合过程中，C语言需要新建一个Lua虚拟机，然后使用虚拟机的指针来操作Lua函数。 </li><li> 在程序的应用中，使用C语言中的一些宏的技巧，可以使代码能够便利地应用在程序里。 </li><p>最后，给你留一个小问题。</p><p>如果使用Lua往C语言传递一些内容，比如从C语言获取Lua脚本中某个变量的值，应该怎么做？</p><p>欢迎留言说出你的看法。我在下一节的挑战中等你！</p>`,48)]))}const d=n(p,[["render",l]]),u=JSON.parse('{"path":"/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/%E7%AC%AC20%E8%AE%B2%20_%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"上一次，我们谈到了如何在游戏中嵌入脚本语言，我们用的语言是Lua。Lua语言具有轻量级、速度快的特点，而且API的调用也非常方便和直观。现在，我们仍然拿Lua脚本，试着把它应用在我们开发的游戏中。 我们使用C语言来对Lua脚本的绑定做一次深入的剖析，然后来看一下，在游戏开发中绑定了脚本语言后，脚本语言能做些什么事情。 首先，我们要明白一点，事实上任何模...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/%E7%AC%AC20%E8%AE%B2%20_%20%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"上一次，我们谈到了如何在游戏中嵌入脚本语言，我们用的语言是Lua。Lua语言具有轻量级、速度快的特点，而且API的调用也非常方便和直观。现在，我们仍然拿Lua脚本，试着把它应用在我们开发的游戏中。 我们使用C语言来对Lua脚本的绑定做一次深入的剖析，然后来看一下，在游戏开发中绑定了脚本语言后，脚本语言能做些什么事情。 首先，我们要明白一点，事实上任何模..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":7.34,"words":2202},"filePathRelative":"posts/从0开始学游戏开发/第四章：脚本语言/第20讲 _ 脚本语言在游戏开发中有哪些应用？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"第20讲 | 脚本语言在游戏开发中有哪些应用？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/de/3b/dee9c9b0ac13b8adef126d53d397b53b.mp3\\"></audio></p>\\n<p>上一次，我们谈到了如何在游戏中嵌入脚本语言，我们用的语言是Lua。Lua语言具有轻量级、速度快的特点，而且API的调用也非常方便和直观。现在，我们仍然拿Lua脚本，试着把它应用在我们开发的游戏中。</p>","autoDesc":true}');export{d as comp,u as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-6Bz2fGO5.js";const l={};function p(t,n){return i(),e("div",null,n[0]||(n[0]=[a(`<p><audio id="audio" title="06 | App 如何通过注入动态库的方式实现极速编译调试？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/2e/fe/2e82135e45c225a4c9347a67338b7bfe.mp3"></audio></p><p>你好，我是戴铭。</p><p>在上一篇文章中，我和你分享了链接器的基础知识。今天我们再继续聊聊，动态库链接器的实际应用，也就是编译调试的提速问题。</p><p>iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 App 来进行的。所以，项目代码量越大，编译时间就越长。虽然我们可以通过将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每次编译都还是需要重启 App，需要再走一遍调试流程。</p><p>对于开发者来说，提高编译调试的速度就是提高生产效率。试想一下，如果上线前一天突然发现了一个严重的bug，每次编译调试都要耗费几十分钟，结果这一天的黄金时间，一晃就过去了。到最后，可能就是上线时间被延误。这个责任可不轻啊。</p><p>那么问题来了，原生代码怎样才能够实现动态极速调试，以此来大幅提高编译调试速度呢？在回答这个问题之前，我们先看看有哪些工具是这么玩儿的。了解了它们的玩法，我们也就自然清楚这个问题的答案了。</p><h2 id="swift-playground" tabindex="-1"><a class="header-anchor" href="#swift-playground"><span>Swift Playground</span></a></h2><p>说到iOS代码动态极速调试的工具，你首先能想到的估计就是 Playground。它是 Xcode 里集成的一个能够快速、实时调试程序的工具，可以实现所见即所得的效果，如下图所示：</p><img src="https://static001.geekbang.org/resource/image/46/01/46007bcd100b7b23edccd46b760e5b01.png" alt=""><p>可以看到，任何的代码修改都能够实时地在右侧反馈出来。</p><h2 id="flutter-hot-reload" tabindex="-1"><a class="header-anchor" href="#flutter-hot-reload"><span>Flutter Hot Reload</span></a></h2><p>Flutter 是 Google 开发的一个跨平台开发框架，调试也是快速实时的。官方的效果动画如下：</p><img src="https://static001.geekbang.org/resource/image/6d/1d/6d8b83e4e063dbccf279adfe2b66dd1d.gif" alt=""><p>可以看到，在 Flutter 编辑器中修改文字 clicked 为 tapped 后点击 reload，模拟器中的文字立刻就改变了，程序没有重启。同样地，修改按钮图标也会立刻生效。</p><p>接下来，我们先看看 Flutter 是怎么实现实时编译的。</p><p>Flutter 会在点击 reload 时去查看自上次编译以后改动过的代码，重新编译涉及到的代码库，还包括主库，以及主库的相关联库。所有这些重新编译过的库都会转换成内核文件发到 Dart VM 里，Dart VM 会重新加载新的内核文件，加载后会让 Flutter framework 触发所有的Widgets 和 Render Objects 进行重建、重布局、重绘。</p><p>Flutter 为了能够支持跨平台开发，使用了自研的 Dart 语言配合在 App 内集成 Dart VM 的方式运行 Flutter 程序。目前 Flutter 还没有达到 Cocoa 框架那样的普及程度，所以如果你不是使用 Flutter 来开发 iOS 程序的话，想要达到极速调试应该要怎么做呢？</p><h1 id="injection-for-xcode" tabindex="-1"><a class="header-anchor" href="#injection-for-xcode"><span>Injection for Xcode</span></a></h1><p>所幸的是，John Holdsworth 开发了一个叫作 Injection 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。John Holdsworth 也提供了动画演示效果，如下：</p><img src="https://static001.geekbang.org/resource/image/a2/13/a239763b1a5c7226e5ee8d7481285a13.gif" alt=""><p>作者已经开源了这个工具，地址是<a href="https://github.com/johnno1962/InjectionIII" target="_blank" rel="noopener noreferrer">https://github.com/johnno1962/InjectionIII</a> 。使用方式就是 clone 下代码，构建 InjectionPluginLite/InjectionPlugin.xcodeproj ；删除方式是，在终端里运行下面这行代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/InjectionPlugin.xcplugin</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>构建完成后，我们就可以编译项目。这时添加一个新的方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (void)injected</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    NSLog(@&amp;quot;I&#39;ve been injected: %@&amp;quot;, self);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在这个方法中添加一个断点，按下 ctrl + = ，接下来你会发现程序运行时会停到断点处，这样你的代码就成功地被运行中的 App 执行了。那么，<strong>Injection 是怎么做到的呢？</strong></p><p>Injection 会监听源代码文件的变化，如果文件被改动了，Injection Server 就会执行 rebuildClass 重新进行编译、打包成动态库，也就是 .dylib 文件。编译、打包成动态库后使用 writeSting 方法通过 Socket 通知运行的 App。writeString 的代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- (BOOL)writeString:(NSString *)string {</span></span>
<span class="line"><span>    const char *utf8 = string.UTF8String;</span></span>
<span class="line"><span>    uint32_t length = (uint32_t)strlen(utf8);</span></span>
<span class="line"><span>    if (write(clientSocket, &amp;amp;length, sizeof length) != sizeof length ||</span></span>
<span class="line"><span>        write(clientSocket, utf8, length) != length)</span></span>
<span class="line"><span>        return FALSE;</span></span>
<span class="line"><span>    return TRUE;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Server 会在后台发送和监听 Socket 消息，实现逻辑在 <code>InjectionServer.mm</code> 的 runInBackground 方法里。Client 也会开启一个后台去发送和监听 Socket 消息，实现逻辑在 <code>InjectionClient.mm</code>里的 runInBackground 方法里。</p><p>Client 接收到消息后会调用 inject(tmpfile: String) 方法，运行时进行类的动态替换。inject(tmpfile: String) 方法的具体实现代码，你可以点击<a href="https://github.com/johnno1962/InjectionIII/blob/master/InjectionBundle/SwiftInjection.swift" target="_blank" rel="noopener noreferrer">这个链接</a>查看。</p><p>inject(tmpfile: String) 方法的代码大部分都是做新类动态替换旧类。inject(tmpfile: String) 的入参 tmpfile 是动态库的文件路径，那么这个动态库是如何加载到可执行文件里的呢？具体的实现在inject(tmpfile: String) 方法开始里，如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let newClasses = try SwiftEval.instance.loadAndInject(tmpfile: tmpfile)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你先看下 SwiftEval.instance.loadAndInject(tmpfile: tmpfile) 这个方法的代码实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@objc func loadAndInject(tmpfile: String, oldClass: AnyClass? = nil) throws -&amp;gt; [AnyClass] {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    print(&amp;quot;???? Loading .dylib - Ignore any duplicate class warning...&amp;quot;)</span></span>
<span class="line"><span>    // load patched .dylib into process with new version of class</span></span>
<span class="line"><span>    guard let dl = dlopen(&amp;quot;\\(tmpfile).dylib&amp;quot;, RTLD_NOW) else {</span></span>
<span class="line"><span>        throw evalError(&amp;quot;dlopen() error: \\(String(cString: dlerror()))&amp;quot;)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    print(&amp;quot;???? Loaded .dylib - Ignore any duplicate class warning...&amp;quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if oldClass != nil {</span></span>
<span class="line"><span>        // find patched version of class using symbol for existing</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        var info = Dl_info()</span></span>
<span class="line"><span>        guard dladdr(unsafeBitCast(oldClass, to: UnsafeRawPointer.self), &amp;amp;info) != 0 else {</span></span>
<span class="line"><span>            throw evalError(&amp;quot;Could not locate class symbol&amp;quot;)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        debug(String(cString: info.dli_sname))</span></span>
<span class="line"><span>        guard let newSymbol = dlsym(dl, info.dli_sname) else {</span></span>
<span class="line"><span>            throw evalError(&amp;quot;Could not locate newly loaded class symbol&amp;quot;)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return [unsafeBitCast(newSymbol, to: AnyClass.self)]</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    else {</span></span>
<span class="line"><span>        // grep out symbols for classes being injected from object file</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try injectGenerics(tmpfile: tmpfile, handle: dl)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        guard shell(command: &amp;quot;&amp;quot;&amp;quot;</span></span>
<span class="line"><span>            \\(xcodeDev)/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm \\(tmpfile).o | grep -E &#39; S _OBJC_CLASS_\\\\$_| _(_T0|\\\\$S).*CN$&#39; | awk &#39;{print $3}&#39; &amp;gt;\\(tmpfile).classes</span></span>
<span class="line"><span>            &amp;quot;&amp;quot;&amp;quot;) else {</span></span>
<span class="line"><span>            throw evalError(&amp;quot;Could not list class symbols&amp;quot;)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        guard var symbols = (try? String(contentsOfFile: &amp;quot;\\(tmpfile).classes&amp;quot;))?.components(separatedBy: &amp;quot;\\n&amp;quot;) else {</span></span>
<span class="line"><span>            throw evalError(&amp;quot;Could not load class symbol list&amp;quot;)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        symbols.removeLast()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return Set(symbols.flatMap { dlsym(dl, String($0.dropFirst())) }).map { unsafeBitCast($0, to: AnyClass.self) }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，你是不是看到你所熟悉的动态库加载函数 dlopen 了呢？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>guard let dl = dlopen(&amp;quot;\\(tmpfile).dylib&amp;quot;, RTLD_NOW) else {</span></span>
<span class="line"><span>    throw evalError(&amp;quot;dlopen() error: \\(String(cString: dlerror()))&amp;quot;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码所示，dlopen 会把 tmpfile 动态库文件载入运行的 App 里，返回指针 dl。接下来，dlsym 会得到 tmpfile 动态库的符号地址，然后就可以处理类的替换工作了。dlsym 调用对应代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>guard let newSymbol = dlsym(dl, info.dli_sname) else {</span></span>
<span class="line"><span>    throw evalError(&amp;quot;Could not locate newly loaded class symbol&amp;quot;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当类的方法都被替换后，我们就可以开始重新绘制界面了。整个过程无需重新编译和重启 App，至此使用动态库方式极速调试的目的就达成了。</p><p>我把Injection的工作原理用一张图表示了出来，如下所示：</p><img src="https://static001.geekbang.org/resource/image/4f/c9/4f49ea2047d2dd2d5c4646b0ba55b8c9.png" alt=""><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>今天这篇文章，我和你详细分享了动态库链接器的一个非常实用的应用场景：如何使用动态库加载方式进行极速调试。由此我们可以看出，类似链接器这样的底层知识是非常重要的。</p><p>当然了，这只是一个场景，还有更多的场景等待着我们去发掘。比如把 Injection 技术扩展开想，每当你修改了另一个人负责的代码就给那个人发条消息，同时将修改的代码编译、打包成动态库直接让对方看到修改的情况，这样不仅是提高了自己的效率，还提高了整个团队的沟通效率。怎么样？是不是有种想立刻尝试的感觉，心动不如行动，动手写起来吧。</p><p>所以，打好了底层知识的基础以后，我们才可以利用它们去提高开发效率，为用户提供更稳定、性能更好的 App 。</p><p>今天这篇文章最后，我留给你的一个小作业是，思考一下底层知识还有哪些运用场景，并在评论区分享出来吧。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p><img src="https://static001.geekbang.org/resource/image/6c/89/6c844d233e74aec08417be65e4ef1d89.jpg" alt="">`,47)]))}const o=s(l,[["render",p]]),c=JSON.parse('{"path":"/posts/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AF%87/06%20_%20App%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%EF%BC%9F.html","title":"Injection for Xcode","lang":"zh-CN","frontmatter":{"description":"你好，我是戴铭。 在上一篇文章中，我和你分享了链接器的基础知识。今天我们再继续聊聊，动态库链接器的实际应用，也就是编译调试的提速问题。 iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 App 来进行的。所以，项目代码量越大，编译时间就越长。虽然我们可以通过将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/iOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AF%87/06%20_%20App%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Injection for Xcode"}],["meta",{"property":"og:description","content":"你好，我是戴铭。 在上一篇文章中，我和你分享了链接器的基础知识。今天我们再继续聊聊，动态库链接器的实际应用，也就是编译调试的提速问题。 iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 App 来进行的。所以，项目代码量越大，编译时间就越长。虽然我们可以通过将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Injection for Xcode\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":7.1,"words":2129},"filePathRelative":"posts/iOS开发高手课/基础篇/06 _ App 如何通过注入动态库的方式实现极速编译调试？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"06 | App 如何通过注入动态库的方式实现极速编译调试？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/2e/fe/2e82135e45c225a4c9347a67338b7bfe.mp3\\"></audio></p>\\n<p>你好，我是戴铭。</p>\\n<p>在上一篇文章中，我和你分享了链接器的基础知识。今天我们再继续聊聊，动态库链接器的实际应用，也就是编译调试的提速问题。</p>\\n<p>iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 App 来进行的。所以，项目代码量越大，编译时间就越长。虽然我们可以通过将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每次编译都还是需要重启 App，需要再走一遍调试流程。</p>","autoDesc":true}');export{o as comp,c as data};

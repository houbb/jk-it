import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,s){return i(),n("div",null,s[0]||(s[0]=[e(`<p><audio id="audio" title="JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/65/68/651494b39e6d5304727e745cd50bfa68.mp3"></audio></p><p>你好，我是winter。这一部分我们来讲一讲JavaScript的执行。</p><p>首先我们考虑一下，如果我们是浏览器或者Node的开发者，我们该如何使用JavaScript引擎。</p><p>当拿到一段JavaScript代码时，浏览器或者Node环境首先要做的就是；传递给JavaScript引擎，并且要求它去执行。</p><p>然而，执行JavaScript并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给JavaScript引擎去执行，此外，我们可能还会提供API给JavaScript引擎，比如setTimeout这样的API，它会允许JavaScript在特定的时机执行。</p><p>所以，我们首先应该形成一个感性的认知：一个JavaScript引擎会常驻于内存中，它等待着我们（宿主）把JavaScript代码或者函数传递给它执行。</p><p>在ES3和更早的版本中，JavaScript本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给JavaScript引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。</p><p>但是，在ES5之后，JavaScript引入了Promise，这样，不需要浏览器的安排，JavaScript引擎本身也可以发起任务了。</p><p>由于我们这里主要讲JavaScript语言，那么采纳JSC引擎的术语，我们把宿主发起的任务称为宏观任务，把JavaScript引擎发起的任务称为微观任务。</p><h2 id="宏观和微观任务" tabindex="-1"><a class="header-anchor" href="#宏观和微观任务"><span>宏观和微观任务</span></a></h2><p>JavaScript引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在Node术语中，也会把这个部分称为事件循环。</p><p>不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的C/C++代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>while(TRUE) {</span></span>
<span class="line"><span>    r = wait();</span></span>
<span class="line"><span>    execute(r);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，整个循环做的事情基本上就是反复“等待-执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。</p><p>这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。</p><p>在宏观任务中，JavaScript的Promise还会产生异步代码，JavaScript必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：</p><img src="https://static001.geekbang.org/resource/image/16/65/16f70a9a51a65d5302166b0d78414d65.jpg" alt=""><p>有了宏观任务和微观任务机制，我们就可以实现JavaScript引擎级和宿主级的任务了，例如：Promise永远在队列尾部添加微观任务。setTimeout等宿主API，则会添加宏观任务。</p><p>接下来，我们来详细介绍一下Promise。</p><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>Promise</span></a></h2><p>Promise是JavaScript语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过Promise的then方法的回调）。</p><p>Promise的基本用法示例如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    function sleep(duration) {</span></span>
<span class="line"><span>        return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span>            setTimeout(resolve,duration);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    sleep(1000).then( ()=&amp;gt; console.log(&amp;quot;finished&amp;quot;));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码定义了一个函数sleep，它的作用是等候传入参数指定的时长。</p><p>Promise的then回调是一个异步的执行过程，下面我们就来研究一下Promise函数中的执行顺序，我们来看一段代码示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    var r = new Promise(function(resolve, reject){</span></span>
<span class="line"><span>        console.log(&amp;quot;a&amp;quot;);</span></span>
<span class="line"><span>        resolve()</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    r.then(() =&amp;gt; console.log(&amp;quot;c&amp;quot;));</span></span>
<span class="line"><span>    console.log(&amp;quot;b&amp;quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们执行这段代码后，注意输出的顺序是 a b c。在进入console.log(“b”) 之前，毫无疑问 r 已经得到了resolve，但是Promise的resolve始终是异步操作，所以c无法出现在b之前。</p><p>接下来我们试试跟setTimeout混用的Promise。</p><p>在这段代码中，我设置了两段互不相干的异步操作：通过setTimeout执行console.log(“d”)，通过Promise执行console.log(“c”)。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    var r = new Promise(function(resolve, reject){</span></span>
<span class="line"><span>        console.log(&amp;quot;a&amp;quot;);</span></span>
<span class="line"><span>        resolve()</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    setTimeout(()=&amp;gt;console.log(&amp;quot;d&amp;quot;), 0)</span></span>
<span class="line"><span>    r.then(() =&amp;gt; console.log(&amp;quot;c&amp;quot;));</span></span>
<span class="line"><span>    console.log(&amp;quot;b&amp;quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现，不论代码顺序如何，d必定发生在c之后，因为Promise产生的是JavaScript引擎内部的微任务，而setTimeout是浏览器API，它产生宏任务。</p><p>为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时1秒的Promise。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    setTimeout(()=&amp;gt;console.log(&amp;quot;d&amp;quot;), 0)</span></span>
<span class="line"><span>    var r = new Promise(function(resolve, reject){</span></span>
<span class="line"><span>        resolve()</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    r.then(() =&amp;gt; { </span></span>
<span class="line"><span>        var begin = Date.now();</span></span>
<span class="line"><span>        while(Date.now() - begin &amp;lt; 1000);</span></span>
<span class="line"><span>        console.log(&amp;quot;c1&amp;quot;) </span></span>
<span class="line"><span>        new Promise(function(resolve, reject){</span></span>
<span class="line"><span>            resolve()</span></span>
<span class="line"><span>        }).then(() =&amp;gt; console.log(&amp;quot;c2&amp;quot;))</span></span>
<span class="line"><span>    });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们强制了1秒的执行耗时，这样，我们可以确保任务c2是在d之后被添加到任务队列。</p><p>我们可以看到，即使耗时一秒的c1执行完毕，再enque的c2，仍然先于d执行了，这很好地解释了微任务优先的原理。</p><p>通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：</p><ul><li>首先我们分析有多少个宏任务；</li><li>在每个宏任务中，分析有多少个微任务；</li><li>根据调用次序，确定宏任务中的微任务执行次序；</li><li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li><li>确定整个顺序。</li></ul><p>我们再来看一个稍微复杂的例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    function sleep(duration) {</span></span>
<span class="line"><span>        return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span>            console.log(&amp;quot;b&amp;quot;);</span></span>
<span class="line"><span>            setTimeout(resolve,duration);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    console.log(&amp;quot;a&amp;quot;);</span></span>
<span class="line"><span>    sleep(5000).then(()=&amp;gt;console.log(&amp;quot;c&amp;quot;));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一段非常常用的封装方法，利用Promise把setTimeout封装成可以用于异步的函数。</p><p>我们首先来看，setTimeout把整个代码分割成了2个宏观任务，这里不论是5秒还是0秒，都是一样的。</p><p>第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”);。</p><p>setTimeout后，第二个宏观任务执行调用了resolve，然后then中的代码异步得到执行，所以调用了console.log(“c”)，最终输出的顺序才是： a b c。</p><p>Promise是JavaScript中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从ES6开始，我们有了async/await，这个语法改进跟Promise配合，能够有效地改善代码结构。</p><h2 id="新特性-async-await" tabindex="-1"><a class="header-anchor" href="#新特性-async-await"><span>新特性：async/await</span></a></h2><p>async/await是ES2016新加入的特性，它提供了用for、if等代码结构来编写异步的方式。它的运行时基础是Promise，面对这种比较新的特性，我们先来看一下基本用法。</p><p>async函数必定返回Promise，我们把所有返回Promise的函数都可以认为是异步函数。</p><p>async函数是一种特殊语法，特征是在function关键字之前加上async关键字，这样，就定义了一个async函数，我们可以在其中使用await来等待一个Promise。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function sleep(duration) {</span></span>
<span class="line"><span>    return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span>        setTimeout(resolve,duration);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>async function foo(){</span></span>
<span class="line"><span>    console.log(&amp;quot;a&amp;quot;)</span></span>
<span class="line"><span>    await sleep(2000)</span></span>
<span class="line"><span>    console.log(&amp;quot;b&amp;quot;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码利用了我们之前定义的sleep函数。在异步函数foo中，我们调用sleep。</p><p>async函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用async函数组合出新的async函数。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function sleep(duration) {</span></span>
<span class="line"><span>    return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span>        setTimeout(resolve,duration);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>async function foo(name){</span></span>
<span class="line"><span>    await sleep(2000)</span></span>
<span class="line"><span>    console.log(name)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>async function foo2(){</span></span>
<span class="line"><span>    await foo(&amp;quot;a&amp;quot;);</span></span>
<span class="line"><span>    await foo(&amp;quot;b&amp;quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里foo2用await调用了两次异步函数foo，可以看到，如果我们把sleep这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解Promise的概念即可进行异步编程了。</p><p>此外，generator/iterator也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少async/await的时候，一些框架（最著名的要数co）使用这样的特性来模拟async/await。</p><p>但是generator并非被设计成实现异步，所以有了async/await之后，generator/iterator来模拟异步的方法应该被废弃。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>在今天的文章里，我们学习了JavaScript执行部分的知识，首先我们学习了JavaScript的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把JavaScript引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。</p><p>除此之外，我们还展开介绍了用Promise来添加微观任务的方式，并且介绍了async/await这个语法的改进。</p><p>最后，留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形div按照绿色3秒，黄色1秒，红色2秒循环改变背景色，你会怎样编写这个代码呢？欢迎你留言讨论。</p>`,59)]))}const c=a(p,[["render",l]]),d=JSON.parse('{"path":"/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APromise%E9%87%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94setTimeout%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是winter。这一部分我们来讲一讲JavaScript的执行。 首先我们考虑一下，如果我们是浏览器或者Node的开发者，我们该如何使用JavaScript引擎。 当拿到一段JavaScript代码时，浏览器或者Node环境首先要做的就是；传递给JavaScript引擎，并且要求它去执行。 然而，执行JavaScript并非一锤子买卖，宿主环境...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9AJavaScript/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APromise%E9%87%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94setTimeout%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是winter。这一部分我们来讲一讲JavaScript的执行。 首先我们考虑一下，如果我们是浏览器或者Node的开发者，我们该如何使用JavaScript引擎。 当拿到一段JavaScript代码时，浏览器或者Node环境首先要做的就是；传递给JavaScript引擎，并且要求它去执行。 然而，执行JavaScript并非一锤子买卖，宿主环境..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":7.9,"words":2371},"filePathRelative":"posts/重学前端/模块一：JavaScript/JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/65/68/651494b39e6d5304727e745cd50bfa68.mp3\\"></audio></p>\\n<p>你好，我是winter。这一部分我们来讲一讲JavaScript的执行。</p>\\n<p>首先我们考虑一下，如果我们是浏览器或者Node的开发者，我们该如何使用JavaScript引擎。</p>","autoDesc":true}');export{c as comp,d as data};

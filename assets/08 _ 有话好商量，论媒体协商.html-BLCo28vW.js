import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as i}from"./app-CrA-f6So.js";const r={};function p(t,e){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="_08-有话好商量-论媒体协商" tabindex="-1"><a class="header-anchor" href="#_08-有话好商量-论媒体协商"><span>08 _ 有话好商量，论媒体协商</span></a></h1><p><audio id="audio" title="08 | 有话好商量，论媒体协商" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/8a/79/8ab9272820d5f29870f0a2a5765a2b79.mp3"></audio></p><p>在<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener noreferrer">《07 | 你竟然不知道SDP？它可是WebRTC的驱动核心！》</a>一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行<strong>媒体协商</strong>的。</p><p>我们平时所说的<strong>协商</strong>你应该清楚是什么意思，说白了就是讨价还价。以买白菜为例，商家说 5元一颗，买家说身上只有 4.5元卖不卖？商家同意卖，这样一次协商就完成了。</p><p>而<strong>媒体协商</strong>也是这个意思，只不过它们讨价还价的不是一般商品，而是与媒体相关的能力。那<strong>媒体能力</strong>是什么呢？实际就是你的设备所支持的音视频编解码器、使用的传输协议、传输的速率是多少等信息。</p><p>所以简单地说，<strong>媒体协商</strong>就是看看你的设备都支持那些编解码器，我的设备是否也支持？如果我的设备也支持，那么咱们双方就算协商成功了。</p><h2 id="在webrtc-处理过程中的位置" tabindex="-1"><a class="header-anchor" href="#在webrtc-处理过程中的位置"><span>在WebRTC 处理过程中的位置</span></a></h2><p>在正式进入主题之前，我们还是来看看本文在整个 WebRTC 处理过程中的位置，如下图所示：</p><img src="https://static001.geekbang.org/resource/image/f5/de/f5a65fd87dc667af6761ba7e25abe1de.png" alt=""><p>通过这张图你可以了解到，本文所涉及的内容包括<strong>创建连接</strong>和<strong>信令</strong>两部分。</p><ul><li>创建连接，指的是创建RTCPeerConnection，它负责端与端之间彼此建立 P2P 连接。在后面 RTCPeerConnection 一节中，我们还会对其做进一步的介绍。</li><li>信令，指的是客户端通过信令服务器交换 SDP 信息。</li></ul><p>所以从本文开始，我们就开始讲解 WebRTC 最核心的一部分知识了，下面就让我们开始吧。</p><h2 id="webrtc中媒体协商的作用" tabindex="-1"><a class="header-anchor" href="#webrtc中媒体协商的作用"><span>WebRTC中媒体协商的作用</span></a></h2><p>在 WebRTC 1.0 规范中，在双方通信时，双方必须清楚彼此使用的编解码器是什么，也必须知道传输过来的音视频流的 SSRC（SSRC的概念参见<a href="https://time.geekbang.org/column/article/109999" target="_blank" rel="noopener noreferrer">《06 | WebRTC中的RTP及RTCP详解》</a>一文）信息，如果连这些最基本的信息彼此都不清楚的话，那么双方是无法正常通信的。</p><p>举个例子，如果WebRTC不清楚对方使用的是哪种编码器编码的数据，比如到底是H264，还是VP8？那WebRTC就无法将这些数据包正常解码，还原成原来的音视频帧，这将导致音视频无法正常显示或播放。</p><p>同样的道理，如果WebRTC不知道对方发过来的音视频流的 SSRC 是多少，那么WebRTC就无法对该音视频流的合法性做验证，这也将导致你无法观看正常的音视频。因为对于无法验证的音视频流，WebRTC在接收音视频包后会直接将其抛弃。</p><p>通过上面的描述，我想你已经非常清楚媒体协商的作用是什么了。没错，<strong>媒体协商的作用就是让双方找到共同支持的媒体能力</strong>，如双方都支持的编解码器，从而<strong>最终实现彼此之间的音视频通信</strong>。</p><p>那 WebRTC 是怎样进行媒体协商的呢？这就要用到<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener noreferrer">《07 | 你竟然不知道SDP？它可是WebRTC的驱动核心！》</a>文章中讲解的 SDP了。</p><ul><li>首先，通信双方将它们各自的媒体信息，如编解码器、媒体流的SSRC、传输协议、IP地址和端口等，按 SDP 格式整理好。</li><li>然后，通信双方通过信令服务器交换SDP信息，并待彼此拿到对方的 SDP 信息后，找出它们共同支持的媒体能力。</li><li>最后，双方按照协商好的媒体能力开始音视频通信。</li></ul><p>WebRTC 进行媒体协商的步骤基本如上所述。接下来，我们来看看 WebRTC 具体是如何操作的。</p><h2 id="rtcpeerconnection" tabindex="-1"><a class="header-anchor" href="#rtcpeerconnection"><span>RTCPeerConnection</span></a></h2><p>讲到媒体协商，我们就不得不介绍一下 RTCPeerConnection 类， 顾名思义，它表示的就是端与端之间建立的<strong>连接</strong>。</p><p>该类是整个 WebRTC 库中<strong>最关键</strong>的一个类，通过它创建出来的对象可以做很多事情，如NAT穿越、音视频数据的接收与发送，甚至它还可以用于非音视频数据的传输等等 。</p><p>而在这里我们之所以要介绍RTCPeerConnection，最主要的原因是<strong>我们今天要讲的端到端之间的媒体协商，就是基于 RTCPeerConnection 对象实现的</strong>。</p><p>首先，我们来看一下如何创建一个RTCPeerConnection对象：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>...</span></span>
<span class="line"><span>var pcConfig = null;</span></span>
<span class="line"><span>var pc = new RTCPeerConnection(pcConfig);</span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在JavaScript下创建RTCPeerConnection对象非常简单，如上所述，只要通过 new 关键字创建即可。</p><p>在创建 RTCPeerConnection 对象时，还可以给它传一个参数<strong>pcConfig</strong>，该参数的结构非常复杂，这里我们先将其设置为null，后面在《12 | RTCPeerConnection：音视频实时通讯的核心》一文中我再对其做更详尽的描述。</p><p>有了RTCPeerConnection对象，接下来，让我们再来看看端与端之间是如何进行媒体协商的吧！</p><h2 id="媒体协商的过程" tabindex="-1"><a class="header-anchor" href="#媒体协商的过程"><span>媒体协商的过程</span></a></h2><p><strong>在通讯双方都创建好 RTCPeerConnection 对象后</strong>，它们就可以开始进行媒体协商了。不过在进行媒体协商之前，有两个重要的概念，即 <strong>Offer</strong> 与 <strong>Answer</strong> ，你必须要弄清楚。</p><p>Offer 与 Answer 是什么呢？对于1对1 通信的双方来说，我们称首先发送媒体协商消息的一方为<strong>呼叫方</strong>，而另一方则为<strong>被呼叫方</strong>。</p><ul><li>Offer，在双方通讯时，呼叫方发送的 SDP 消息称为 Offer。</li><li>Answer，在双方通讯时，被呼叫方发送的 SDP 消息称为 Answer。</li></ul><p>在WebRTC中，双方协商的整个过程如下图所示：</p><img src="https://static001.geekbang.org/resource/image/55/29/55971e410ce15be231b3f5fab0881e29.png" alt=""><p>首先，呼叫方创建 Offer 类型的SDP消息。创建完成后，调用 setLocalDescriptoin 方法将该Offer 保存到本地 Local 域，然后通过信令将 Offer 发送给被呼叫方。</p><p>被呼叫方收到 Offer 类型的 SDP 消息后，调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。作为应答，被呼叫方要创建 Answer 类型的 SDP 消息，Answer消息创建成功后，再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。最后，被呼叫方将 Answer 消息通过信令发送给呼叫方。至此，被呼叫方的工作就完部完成了。</p><p>接下来是呼叫方的收尾工作，呼叫方收到 Answer 类型的消息后，调用 RTCPeerConnecton 对象的 setRemoteDescription 方法，将 Answer 保存到它的 Remote 域。</p><p>至此，<strong>整个媒体协商过程处理完毕</strong>。</p><p>当通讯双方拿到彼此的SDP信息后，就可以进行媒体协商了。媒体协商的具体过程是在 WebRTC内部实现的，我们就不去细讲了。你只需要记住本地的 SDP 和远端的 SDP 都设置好后，协商就算成功了。</p><h2 id="媒体协商的代码实现" tabindex="-1"><a class="header-anchor" href="#媒体协商的代码实现"><span>媒体协商的代码实现</span></a></h2><p>了解了WebRTC的媒体协商过程之后，我们再看一下如何使用 JavaScript 代码来实现这一功能。浏览器提供了几个非常方便的 API，这些 API 是对底层 WebRTC API 的封装。如下所示：</p><ul><li>createOffer ，创建 Offer；</li><li>createAnswer，创建 Answer；</li><li>setLocalDescription，设置本地 SDP 信息；</li><li>setRemoteDescription，设置远端的 SDP 信息。</li></ul><p>接下来，我们就结合上述的协商过程对这几个重要的 API 做下详细的讲解。</p><h3 id="_1-呼叫方创建offer" tabindex="-1"><a class="header-anchor" href="#_1-呼叫方创建offer"><span>1. 呼叫方创建Offer</span></a></h3><p>当呼叫方发起呼叫之前，首先要创建 Offer 类型的 SDP 信息，即调用 <strong>RTCPeerConnection</strong> 的 createOffer() 方法。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   function doCall() {</span></span>
<span class="line"><span>       console.log(&#39;Sending offer to peer&#39;);</span></span>
<span class="line"><span>       pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);</span></span>
<span class="line"><span>	}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果createOffer函数调用成功的话，浏览器会回调我们设置的 setLocalAndSendMessage 方法，你可以在 setLocalAndSendMessage 方法里获取到 <strong>RTCSessionDescription 类型的 SDP 信息</strong>；如果出错则会回调 handleCreateOfferError 方法。</p><p>最终，在 setLocalAndSendMessage 回调方法中，通过 <strong>setLocalDescription()</strong> 方法将本地SDP描述信息设置到 WebRTC 的Local 域。然后通过信令通道将此会话描述发送给被呼叫方。代码如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  function setLocalAndSendMessage(sessionDescription) {</span></span>
<span class="line"><span>      pc.setLocalDescription(sessionDescription);</span></span>
<span class="line"><span>      sendMessage(sessionDescription);</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-被呼叫方收到offer" tabindex="-1"><a class="header-anchor" href="#_2-被呼叫方收到offer"><span>2. 被呼叫方收到Offer</span></a></h3><p>被呼叫方收到 Offer 后，调用 <strong>setRemoteDescription</strong> 方法设置呼叫方发送给它的Offer作为远端描述。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  socket.on(&#39;message&#39;, function(message) {</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span>      } else if (message.type === &#39;offer&#39;) {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>          pc.setRemoteDescription(new RTCSessionDescription(message));</span></span>
<span class="line"><span>          doAnswer();</span></span>
<span class="line"><span>      } else if (...) {</span></span>
<span class="line"><span>          ...</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      ....</span></span>
<span class="line"><span>  });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-被呼叫方创建answer" tabindex="-1"><a class="header-anchor" href="#_3-被呼叫方创建answer"><span>3. 被呼叫方创建Answer</span></a></h3><p>然后，被呼叫方调用 RTCPeerConnection 对象的 createAnswer 方法，它会生成一个与远程会话兼容的本地会话，并最终将该会话描述发送给呼叫方。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> function doAnswer() {</span></span>
<span class="line"><span>     pc.createAnswer().then(</span></span>
<span class="line"><span>         setLocalAndSendMessage,</span></span>
<span class="line"><span>         onCreateSessionDescriptionError</span></span>
<span class="line"><span>     );</span></span>
<span class="line"><span> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-呼叫方收到answer" tabindex="-1"><a class="header-anchor" href="#_4-呼叫方收到answer"><span>4. 呼叫方收到Answer</span></a></h3><p>当呼叫方得到被呼叫方的会话描述，即 SDP 时，调用 setRemoteDescription方法，将收到的会话描述设置为一个远程会话。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  socket.on(&#39;message&#39;, function(message) {</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span>      } else if (message.type === &#39;answer&#39;) {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>          pc.setRemoteDescription(new RTCSessionDescription(message));</span></span>
<span class="line"><span>      } else if (...) {</span></span>
<span class="line"><span>          ...</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      ....</span></span>
<span class="line"><span>  });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，媒体协商过程完成。紧接着在 WebRTC 底层会收集 Candidate，并进行连通性检测，最终在通话双方之间建立起一条链路来。</p><p>以上就是通信双方交换媒体能力信息的过程。 对于你来说，如果媒体协商这个逻辑没搞清楚的话，那么，你在编写音视频相关程序时很容易出现各种问题，最常见的就是音视之间不能互通。</p><p>另外，<strong>需要特别注意的是，通信双方链路的建立是在设置本地媒体能力，即调用 setLocalDescription 函数之后才进行的</strong>。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>在本文中，我向你详细介绍了 WebRTC 进行媒体协商的过程，这个过程是你必须牢记在脑子里的。如果对这块不熟悉的话，后面你在真正使用 WebRTC 开发音视频应用程序时就会遇到各种困难，如音视频不通、单通等情况。</p><p>另外，本文还向你简要介绍了 RTCPeerConnection 对象，它是 WebRTC 的核心 API，媒体协商的具体操作都是通过该对象来完成的。对于该对象，我会在后面的文章中做更详尽的解答。</p><p>RTCPeerConnection 除了会在端与端之间建立连接、传输音视频数据外，还要进行两次绑定：一次是与媒体源进行绑定，以解决数据从哪里来的问题；另外一次是与输出进行绑定，以解决接收到的音视频数据显示/播放的问题。</p><h2 id="思考时间" tabindex="-1"><a class="header-anchor" href="#思考时间"><span>思考时间</span></a></h2><p>在 WebRTC中，SDP 消息的交换是使用 RTCPeerConnection 对象完成的吗？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>`,69)]))}const c=n(r,[["render",p]]),d=JSON.parse('{"path":"/posts/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/WebRTC%201%E5%AF%B91%E9%80%9A%E8%AF%9D/08%20_%20%E6%9C%89%E8%AF%9D%E5%A5%BD%E5%95%86%E9%87%8F%EF%BC%8C%E8%AE%BA%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86.html","title":"08 _ 有话好商量，论媒体协商","lang":"zh-CN","frontmatter":{"description":"08 _ 有话好商量，论媒体协商 在《07 | 你竟然不知道SDP？它可是WebRTC的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。 我们平时所说的协商你应该清楚是什么意思，说白了就是讨价还价。以买白菜为例...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E4%BB%8E0%E6%89%93%E9%80%A0%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/WebRTC%201%E5%AF%B91%E9%80%9A%E8%AF%9D/08%20_%20%E6%9C%89%E8%AF%9D%E5%A5%BD%E5%95%86%E9%87%8F%EF%BC%8C%E8%AE%BA%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"08 _ 有话好商量，论媒体协商"}],["meta",{"property":"og:description","content":"08 _ 有话好商量，论媒体协商 在《07 | 你竟然不知道SDP？它可是WebRTC的驱动核心！》一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行媒体协商的。 我们平时所说的协商你应该清楚是什么意思，说白了就是讨价还价。以买白菜为例..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"08 _ 有话好商量，论媒体协商\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":9.3,"words":2789},"filePathRelative":"posts/从0打造音视频直播系统/WebRTC 1对1通话/08 _ 有话好商量，论媒体协商.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"08 | 有话好商量，论媒体协商\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/8a/79/8ab9272820d5f29870f0a2a5765a2b79.mp3\\"></audio></p>\\n<p>在<a href=\\"https://time.geekbang.org/column/article/111337\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《07 | 你竟然不知道SDP？它可是WebRTC的驱动核心！》</a>一文中，我向你详细介绍了标准 SDP 规范，以及 WebRTC 与标准 SDP 规范的一些不同，而本文我们将重点学习一下 WebRTC 究竟是如何使用 SDP 规范进行<strong>媒体协商</strong>的。</p>","autoDesc":true}');export{c as comp,d as data};

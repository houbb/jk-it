import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,e){return i(),a("div",null,e[0]||(e[0]=[n(`<p><audio id="audio" title="练习Sample跑起来 | 唯鹿同学的练习手记 第3辑" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/df/c2/df08966dbbe1afcf86c3debc177b82c2.mp3"></audio></p><p>没想到之前的写的练习心得得到了老师的认可，看来我要更加认真努力练习了。今天来练习第22、27、ASM这三课的Sample。</p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter22" target="_blank" rel="noopener noreferrer"><strong>Chapter22</strong></a></p><blockquote></blockquote><p>尝试使用Facebook ReDex库来优化我们的安装包。</p><p><strong>准备工作</strong></p><p>首先是下载ReDex：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>git clone https://github.com/facebook/redex.git</span></span>
<span class="line"><span>cd redex</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>接着是安装：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>autoreconf -ivf &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make -j4</span></span>
<span class="line"><span>sudo make install</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在安装时执行到这里，报出下图错误：</p><img src="https://static001.geekbang.org/resource/image/40/fa/40ba14544153f1ef67bfd21a884c1efa.jpg" alt=""><p>其实就是没有安装Boost，所以执行下面的命令安装它。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>brew install boost jsoncpp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>安装Boost完成后，再等待十几分钟时间安装ReDex。</p><p>下来就是编译我们的Sample，得到的安装包信息如下。</p><img src="https://static001.geekbang.org/resource/image/bc/0b/bcf38372f4d9315b9d288607e437040b.jpeg" alt=""><p>可以看到有三个Dex文件，APK大小为13.7MB。</p><p><strong>通过ReDex命令优化</strong></p><p>为了让我们可以更加清楚流程，你可以输出ReDex的日志。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>export TRACE=2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>去除Debuginfo的方法，需要在项目根目录执行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redex --sign -s ReDexSample/keystore/debug.keystore -a androiddebugkey -p android -c redex-test/stripdebuginfo.config -P ReDexSample/proguard-rules.pro  -o redex-test/strip_output.apk ReDexSample/build/outputs/apk/debug/ReDexSample-debug.apk</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面这段很长的命令，其实可以拆解为几部分：</p><li> \`--sign\` 签名信息 </li><li> \`-s\`（keystore）签名文件路径 </li><li> \`-a\`（keyalias）签名的别名 </li><li> \`-p\`（keypass）签名的密码 </li><li> \`-c\` 指定ReDex的配置文件路径 </li><li> \`-P\` ProGuard规则文件路径 </li><li> \`-o\` 输出的文件路径 </li><li> 最后是要处理APK文件的路径 </li><p>但在使用时，我遇到了下图的问题：</p><img src="https://static001.geekbang.org/resource/image/f9/42/f942ef115b2293562b6c3d533c0abd42.png" alt=""><p>这里是找不到<code>Zipalign</code>，所以需要我们配置Android SDK的根目录路径，添加在原命令前面：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ANDROID_SDK=/path/to/android/sdk redex [... arguments ...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果如下：</p><img src="https://static001.geekbang.org/resource/image/4f/28/4f442a95f1518cbe38311b042cdda028.png" alt=""><p>实际的优化效果是，原Debug包为14.21MB，去除Debuginfo的方法后为12.91MB，效果还是不错的。<strong>去除的内容就是一些调试信息及堆栈行号。</strong></p><img src="https://static001.geekbang.org/resource/image/fd/07/fda8e0b637df6f145f9867764720ab07.jpeg" alt=""><p>不过老师在Sample的proguard-rules.pro中添加了<code>-keepattributes SourceFile,LineNumberTable</code>保留了行号信息。</p><p>所以处理后的包安装后进入首页，还是可以看到堆栈信息的行号。</p><p><strong>Dex重分包的方法</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redex --sign -s ReDexSample/keystore/debug.keystore -a androiddebugkey -p android -c redex-test/interdex.config -P ReDexSample/proguard-rules.pro  -o redex-test/interdex_output.apk ReDexSample/build/outputs/apk/debug/ReDexSample-debug.apk</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>和之前的命令一样，只是<code>-c</code>使用的配置文件为interdex.config。</p><p>输出信息：</p><img src="https://static001.geekbang.org/resource/image/29/aa/293f13ab6fe75ede7d4840d04f0d56aa.jpeg" alt=""><p>优化效果为，原Debug包为14.21MB、3个Dex，优化后为13.34MB、2个Dex。</p><img src="https://static001.geekbang.org/resource/image/77/c3/77abb69a81448e677b64bb5cbd59fec3.jpeg" alt=""><p>根据老师的介绍，<strong>如果你的应用有4个以上的Dex，这个体积优化至少有10%</strong>。 看来效果还是很棒棒的。至于其他问题，比如在Windows环境使用ReDex，可以参看ReDex的<a href="https://fbredex.com/docs/installation" target="_blank" rel="noopener noreferrer">使用文档</a>。</p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter27" target="_blank" rel="noopener noreferrer"><strong>Chapter27</strong></a></p><blockquote></blockquote><p>利用AspectJ实现插桩的例子。</p><p>效果和<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter07" target="_blank" rel="noopener noreferrer">Chapter07</a>是一样的，只是Chapter07使用的是ASM方式实现的，这次是AspectJ实现。ASM与AspectJ都是Java字节码处理框架，相比较来说AspectJ使用更加简单，同样的功能实现只需下面这点代码，但是ASM比AspectJ更加高效和灵活。</p><p>AspectJ实现代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Aspect</span></span>
<span class="line"><span>public class TraceTagAspectj {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)</span></span>
<span class="line"><span>    @Before(&amp;quot;execution(* **(..))&amp;quot;)</span></span>
<span class="line"><span>    public void before(JoinPoint joinPoint) {</span></span>
<span class="line"><span>        Trace.beginSection(joinPoint.getSignature().toString());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * hook method when it&#39;s called out.</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)</span></span>
<span class="line"><span>    @After(&amp;quot;execution(* **(..))&amp;quot;)</span></span>
<span class="line"><span>    public void after() {</span></span>
<span class="line"><span>        Trace.endSection();</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单介绍下上面代码的意思：</p><li> \`@Aspect\`：在编译时AspectJ会查找被\`@Aspect\`注解的类，然后执行我们的AOP实现。 </li><li> \`@Before\`：可以简单理解为方法执行前。 </li><li> \`@After\`：可以简单理解为方法执行后。 </li><li> \`execution\`：方法执行。 </li><li> \`* **(..)\`：第一个星号代表任意返回类型，第二个星号代表任意类，第三个代表任意方法，括号内为方法参数无限制。星号和括号内都是可以替换为具体值，比如String TestClass.test(String)。 </li><p>知道了相关注解的含义，那么实现的代码含义就是，<strong>所有方法在执行前后插入相应指定操作</strong>。</p><p>效果对比如下：</p><p><img src="https://static001.geekbang.org/resource/image/64/77/644381974bcd1e3b2d468cdeb432ed77.png" alt=""><br><br><img src="https://static001.geekbang.org/resource/image/02/ca/02b99a9e7fd70da8d9fdf086f31c78ca.png" alt=""></p><p>下来实现给MainActivity的<code>onResume</code>方法增加try catch。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Aspect</span></span>
<span class="line"><span>public class TryCatchAspect {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    @Pointcut(&amp;quot;execution(* com.sample.systrace.MainActivity.onResume())&amp;quot;) // &amp;lt;- 指定类与方法</span></span>
<span class="line"><span>    public void methodTryCatch() {</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Around(&amp;quot;methodTryCatch()&amp;quot;)</span></span>
<span class="line"><span>    public void aroundTryJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>         // try catch</span></span>
<span class="line"><span>         try {</span></span>
<span class="line"><span>             joinPoint.proceed(); // &amp;lt;- 调用原方法</span></span>
<span class="line"><span>         } catch (Exception e) {</span></span>
<span class="line"><span>              e.printStackTrace();</span></span>
<span class="line"><span>         }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面用到了两个新注解：</p><li> \`@Around\`：用于替换以前的代码，使用joinPoint.proceed()可以调用原方法。 </li><li> \`@Pointcut\`：指定一个切入点。 </li><p>实现就是指定一个切入点，利用替换原方法的思路包裹一层try catch。</p><p>效果对比如下：</p><p><img src="https://static001.geekbang.org/resource/image/7f/c0/7f4a5bb6995c53872966c956d7e78ec0.png" alt=""><br><br><img src="https://static001.geekbang.org/resource/image/08/bc/08d123aa792c8f4fc8538fd5658cb9bc.png" alt=""></p><p>当然AspectJ还有很多用法，Sample中包含有《AspectJ程序设计指南》，便于我们具体了解和学习AspectJ。</p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter-ASM" target="_blank" rel="noopener noreferrer"><strong>Chapter-ASM</strong></a></p><blockquote></blockquote><p>Sample利用ASM实现了统计方法耗时和替换项目中所有的new Thread。</p><li> 运行项目首先要注掉ASMSample build.gradle的\`apply plugin: &#39;com.geektime.asm-plugin&#39;\`和根目录build.gradle的\`classpath (&quot;com.geektime.asm:asm-gradle-plugin:1.0&quot;) { changing = true }\`。 </li><li> 运行\`gradle task &quot;:asm-gradle-plugin:buildAndPublishToLocalMaven&quot;\`编译plugin插件，编译的插件在本地\`.m2\\repository\`目录下 </li><li> 打开第一步注掉的内容就可以运行了。 </li><p>实现的大致过程是，先利用Transform遍历所有文件，再通过ASM的<code>visitMethod</code>遍历所有方法，最后通过AdviceAdapter实现最终的修改字节码。具体实现可以看代码和<a href="https://time.geekbang.org/column/article/83148" target="_blank" rel="noopener noreferrer">《练习Sample跑起来 | ASM插桩强化练习》</a>。</p><p>效果对比：</p><p><img src="https://static001.geekbang.org/resource/image/ee/0b/ee98c9349e62d5aca66b883a89cd470b.png" alt=""><br><br><img src="https://static001.geekbang.org/resource/image/d0/3a/d0dd3c68ac2d56b6eebf6853f871c43a.png" alt=""></p><p>下面是两个练习：</p><p>1.给某个方法增加try catch</p><p>这里我就给MainActivity的<code>mm</code>方法进行try catch。实现很简单，直接修改ASMCode的TraceMethodAdapter。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static class TraceMethodAdapter extends AdviceAdapter {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        private final String methodName;</span></span>
<span class="line"><span>        private final String className;</span></span>
<span class="line"><span>        private final Label tryStart = new Label();</span></span>
<span class="line"><span>        private final Label tryEnd = new Label();</span></span>
<span class="line"><span>        private final Label catchStart = new Label();</span></span>
<span class="line"><span>        private final Label catchEnd = new Label();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        protected TraceMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {</span></span>
<span class="line"><span>            super(api, mv, access, name, desc);</span></span>
<span class="line"><span>            this.className = className;</span></span>
<span class="line"><span>            this.methodName = name;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected void onMethodEnter() {</span></span>
<span class="line"><span>            if (className.equals(&amp;quot;com/sample/asm/MainActivity&amp;quot;) &amp;amp;&amp;amp; methodName.equals(&amp;quot;mm&amp;quot;)) {</span></span>
<span class="line"><span>                mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, &amp;quot;java/lang/Exception&amp;quot;);</span></span>
<span class="line"><span>                mv.visitLabel(tryStart);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected void onMethodExit(int opcode) {</span></span>
<span class="line"><span>            if (className.equals(&amp;quot;com/sample/asm/MainActivity&amp;quot;) &amp;amp;&amp;amp; methodName.equals(&amp;quot;mm&amp;quot;)) {</span></span>
<span class="line"><span>                mv.visitLabel(tryEnd);</span></span>
<span class="line"><span>                mv.visitJumpInsn(GOTO, catchEnd);</span></span>
<span class="line"><span>                mv.visitLabel(catchStart);</span></span>
<span class="line"><span>                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &amp;quot;java/lang/RuntimeException&amp;quot;, &amp;quot;printStackTrace&amp;quot;, &amp;quot;()V&amp;quot;, false);</span></span>
<span class="line"><span>                mv.visitInsn(Opcodes.RETURN);</span></span>
<span class="line"><span>                mv.visitLabel(catchEnd);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>visitTryCatchBlock</code>方法：前三个参数均是Label实例，其中一、二表示try块的范围，三则是catch块的开始位置，第四个参数是异常类型。其他的方法及参数就不细说了，具体你可以参考<a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener noreferrer">ASM文档</a>。</p><p>实现类似AspectJ，在方法执行开始及结束时插入我们的代码。</p><p>效果我就不截图了，代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public void mm() {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            A a = new A(new B(2));</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.查看代码中谁获取了IMEI</p><p>这个就更简单了，直接寻找谁使用了TelephonyManager的<code>getDeviceId</code>方法，并且在Sample中有答案。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class IMEIMethodAdapter extends AdviceAdapter {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private final String methodName;</span></span>
<span class="line"><span>    private final String className;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    protected IMEIMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {</span></span>
<span class="line"><span>        super(api, mv, access, name, desc);</span></span>
<span class="line"><span>        this.className = className;</span></span>
<span class="line"><span>        this.methodName = name;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {</span></span>
<span class="line"><span>        super.visitMethodInsn(opcode, owner, name, desc, itf);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (owner.equals(&amp;quot;android/telephony/TelephonyManager&amp;quot;) &amp;amp;&amp;amp; name.equals(&amp;quot;getDeviceId&amp;quot;) &amp;amp;&amp;amp; desc.equals(&amp;quot;()Ljava/lang/String;&amp;quot;)) {</span></span>
<span class="line"><span>            Log.e(&amp;quot;asmcode&amp;quot;, &amp;quot;get imei className:%s, method:%s, name:%s&amp;quot;, className, methodName, name);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Build后输出如下：</p><img src="https://static001.geekbang.org/resource/image/2d/94/2d5c01eee4fc651b5831c0341d6e0994.png" alt=""><p>总体来说ASM的上手难度还是高于AspectJ，需要我们了解编译后的字节码，这里所使用的功能也只是冰山一角。课代表鹏飞同学推荐的ASM Bytecode Outline插件是个好帮手！最后我将我练习的代码也上传到了<a href="https://github.com/simplezhli/Chapter-ASM" target="_blank" rel="noopener noreferrer">GitHub</a>，里面还包括一份中文版的ASM文档，有兴趣的同学可以下载看看。</p><p>参考</p><ul><li><a href="http://time.geekbang.org/column/article/83148" target="_blank" rel="noopener noreferrer">练习Sample跑起来 | ASM插桩强化练</a></li><li><a href="http://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener noreferrer">ASM文档</a></li></ul>`,99)]))}const c=s(p,[["render",l]]),o=JSON.parse('{"path":"/posts/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5%20_%20%E5%94%AF%E9%B9%BF%E5%90%8C%E5%AD%A6%E7%9A%84%E7%BB%83%E4%B9%A0%E6%89%8B%E8%AE%B0%20%E7%AC%AC3%E8%BE%91.html","title":"","lang":"zh-CN","frontmatter":{"description":"没想到之前的写的练习心得得到了老师的认可，看来我要更加认真努力练习了。今天来练习第22、27、ASM这三课的Sample。 Chapter22 尝试使用Facebook ReDex库来优化我们的安装包。 准备工作 首先是下载ReDex： 接着是安装： 在安装时执行到这里，报出下图错误： 其实就是没有安装Boost，所以执行下面的命令安装它。 安装Boo...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5/%E7%BB%83%E4%B9%A0Sample%E8%B7%91%E8%B5%B7%E6%9D%A5%20_%20%E5%94%AF%E9%B9%BF%E5%90%8C%E5%AD%A6%E7%9A%84%E7%BB%83%E4%B9%A0%E6%89%8B%E8%AE%B0%20%E7%AC%AC3%E8%BE%91.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"没想到之前的写的练习心得得到了老师的认可，看来我要更加认真努力练习了。今天来练习第22、27、ASM这三课的Sample。 Chapter22 尝试使用Facebook ReDex库来优化我们的安装包。 准备工作 首先是下载ReDex： 接着是安装： 在安装时执行到这里，报出下图错误： 其实就是没有安装Boost，所以执行下面的命令安装它。 安装Boo..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":6.62,"words":1985},"filePathRelative":"posts/Android开发高手课/练习Sample跑起来/练习Sample跑起来 _ 唯鹿同学的练习手记 第3辑.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"练习Sample跑起来 | 唯鹿同学的练习手记 第3辑\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/df/c2/df08966dbbe1afcf86c3debc177b82c2.mp3\\"></audio></p>\\n<p>没想到之前的写的练习心得得到了老师的认可，看来我要更加认真努力练习了。今天来练习第22、27、ASM这三课的Sample。</p>\\n<p><a href=\\"https://github.com/AndroidAdvanceWithGeektime/Chapter22\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><strong>Chapter22</strong></a></p>","autoDesc":true}');export{c as comp,o as data};

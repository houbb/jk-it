import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,o as i}from"./app-6Bz2fGO5.js";const l={};function p(t,n){return i(),s("div",null,n[0]||(n[0]=[e(`<p><audio id="audio" title="答疑篇：代码篇思考题集锦（二）" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/20/f8/20ff92d160e92fb43de58a4d197d00f8.mp3"></audio></p><p>你好，我是朱晔。</p><p>今天，我们继续一起分析这门课第7~12讲的课后思考题。这些题目涉及了数据库索引、判等问题、数值计算、集合类、空值处理和异常处理的12道问题。</p><p>接下来，我们就一一具体分析吧。</p><h3 id="_07-数据库索引-索引并不是万能药" tabindex="-1"><a class="header-anchor" href="#_07-数据库索引-索引并不是万能药"><span><a href="https://time.geekbang.org/column/article/213342" target="_blank" rel="noopener noreferrer">07 | 数据库索引：索引并不是万能药</a></span></a></h3><p>**问题1：**在介绍二级索引代价时，我们通过EXPLAIN命令看到了索引覆盖和回表的两种情况。你能用optimizer trace来分析一下这两种情况的成本差异吗？</p><p>答：如下代码所示，打开optimizer_trace后，再执行SQL就可以查询information_schema.OPTIMIZER_TRACE表查看执行计划了，最后可以关闭optimizer_trace功能：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>SET optimizer_trace=&amp;quot;enabled=on&amp;quot;;</span></span>
<span class="line"><span>SELECT * FROM person WHERE NAME &amp;gt;&#39;name84059&#39; AND create_time&amp;gt;&#39;2020-01-24 05:00:00&#39;;</span></span>
<span class="line"><span>SELECT * FROM information_schema.OPTIMIZER_TRACE;</span></span>
<span class="line"><span>SET optimizer_trace=&amp;quot;enabled=off&amp;quot;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设我们为表person的NAME和SCORE列建了联合索引，那么下面第二条语句应该可以走索引覆盖，而第一条语句需要回表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>explain select * from person where NAME=&#39;name1&#39;;</span></span>
<span class="line"><span>explain select NAME,SCORE from person where NAME=&#39;name1&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过观察OPTIMIZER_TRACE的输出可以看到，索引覆盖（index_only=true）的成本是1.21而回表查询（index_only=false）的是2.21，也就是索引覆盖节省了回表的成本1。</p><p>索引覆盖：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>analyzing_range_alternatives&amp;quot;: {</span></span>
<span class="line"><span>  &amp;quot;range_scan_alternatives&amp;quot;: [</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    &amp;quot;index&amp;quot;: &amp;quot;name_score&amp;quot;,</span></span>
<span class="line"><span>    &amp;quot;ranges&amp;quot;: [</span></span>
<span class="line"><span>      &amp;quot;name1 &amp;lt;= name &amp;lt;= name1&amp;quot;</span></span>
<span class="line"><span>    ] /* ranges */,</span></span>
<span class="line"><span>    &amp;quot;index_dives_for_eq_ranges&amp;quot;: true,</span></span>
<span class="line"><span>    &amp;quot;rowid_ordered&amp;quot;: false,</span></span>
<span class="line"><span>    &amp;quot;using_mrr&amp;quot;: false,</span></span>
<span class="line"><span>    &amp;quot;index_only&amp;quot;: true,</span></span>
<span class="line"><span>    &amp;quot;rows&amp;quot;: 1,</span></span>
<span class="line"><span>    &amp;quot;cost&amp;quot;: 1.21,</span></span>
<span class="line"><span>    &amp;quot;chosen&amp;quot;: true</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;quot;range_scan_alternatives&amp;quot;: [</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    &amp;quot;index&amp;quot;: &amp;quot;name_score&amp;quot;,</span></span>
<span class="line"><span>    &amp;quot;ranges&amp;quot;: [</span></span>
<span class="line"><span>      &amp;quot;name1 &amp;lt;= name &amp;lt;= name1&amp;quot;</span></span>
<span class="line"><span>    ] /* ranges */,</span></span>
<span class="line"><span>    &amp;quot;index_dives_for_eq_ranges&amp;quot;: true,</span></span>
<span class="line"><span>    &amp;quot;rowid_ordered&amp;quot;: false,</span></span>
<span class="line"><span>    &amp;quot;using_mrr&amp;quot;: false,</span></span>
<span class="line"><span>    &amp;quot;index_only&amp;quot;: false,</span></span>
<span class="line"><span>    &amp;quot;rows&amp;quot;: 1,</span></span>
<span class="line"><span>    &amp;quot;cost&amp;quot;: 2.21,</span></span>
<span class="line"><span>    &amp;quot;chosen&amp;quot;: true</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**问题2：**索引除了可以用于加速搜索外，还可以在排序时发挥作用，你能通过EXPLAIN来证明吗？你知道，针对排序在什么情况下，索引会失效吗？</p><p>答：排序使用到索引，在执行计划中的体现就是key这一列。如果没有用到索引，会在Extra中看到Using filesort，代表使用了内存或磁盘进行排序。而具体走内存还是磁盘，是由sort_buffer_size和排序数据大小决定的。</p><p>排序无法使用到索引的情况有：</p><ul><li>对于使用联合索引进行排序的场景，多个字段排序ASC和DESC混用；</li><li>a+b作为联合索引，按照a范围查询后按照b排序；</li><li>排序列涉及到的多个字段不属于同一个联合索引；</li><li>排序列使用了表达式。</li></ul><p>其实，这些原因都和索引的结构有关。你可以再有针对性地复习下<a href="https://time.geekbang.org/column/article/213342" target="_blank" rel="noopener noreferrer">第07讲</a>的聚簇索引和二级索引部分。</p><h3 id="_08-判等问题-程序里如何确定你就是你" tabindex="-1"><a class="header-anchor" href="#_08-判等问题-程序里如何确定你就是你"><span><a href="https://time.geekbang.org/column/article/213604" target="_blank" rel="noopener noreferrer">08 | 判等问题：程序里如何确定你就是你？</a></span></a></h3><p>**问题1：**在实现equals时，我是先通过getClass方法判断两个对象的类型，你可能会想到还可以使用instanceof来判断。你能说说这两种实现方式的区别吗？</p><p>答：事实上，使用getClass和instanceof这两种方案都是可以判断对象类型的。它们的区别就是，getClass限制了这两个对象只能属于同一个类，而instanceof却允许两个对象是同一个类或其子类。</p><p>正是因为这种区别，不同的人对这两种方案有不同的喜好，争论也很多。在我看来，你只需要根据自己的要求去选择。补充说明一下，Lombok使用的是instanceof的方案。</p><p>**问题2：**在“hashCode 和 equals 要配对实现”这一节的例子中，我演示了可以通过HashSet的contains方法判断元素是否在HashSet中。那同样是Set的TreeSet，其contains方法和HashSet的contains方法有什么区别吗？</p><p>答：HashSet基于HashMap，数据结构是哈希表。所以，HashSet的contains方法，其实就是根据hashcode和equals去判断相等的。</p><p>TreeSet基于TreeMap，数据结构是红黑树。所以，TreeSet的contains方法，其实就是根据compareTo去判断相等的。</p><h3 id="_09-数值计算-注意精度、舍入和溢出问题" tabindex="-1"><a class="header-anchor" href="#_09-数值计算-注意精度、舍入和溢出问题"><span><a href="https://time.geekbang.org/column/article/213796" target="_blank" rel="noopener noreferrer">09 | 数值计算：注意精度、舍入和溢出问题</a></span></a></h3><p><strong>问题1：</strong><a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html" target="_blank" rel="noopener noreferrer">BigDecimal</a>提供了8种舍入模式，你能通过一些例子说说它们的区别吗？</p><p>答：@Darren同学的留言非常全面，梳理得也非常清楚了。这里，我对他的留言稍加修改，就是这个问题的答案了。</p><p>第一种，ROUND_UP，舍入远离零的舍入模式，在丢弃非零部分之前始终增加数字（始终对非零舍弃部分前面的数字加1）。 需要注意的是，此舍入模式始终不会减少原始值。</p><p>第二种，ROUND_DOWN，接近零的舍入模式，在丢弃某部分之前始终不增加数字（从不对舍弃部分前面的数字加1，即截断）。 需要注意的是，此舍入模式始终不会增加原始值。</p><p>第三种，ROUND_CEILING，接近正无穷大的舍入模式。 如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同； 如果为负，则舍入行为与 ROUND_DOWN 相同。 需要注意的是，此舍入模式始终不会减少原始值。</p><p>第四种，ROUND_FLOOR，接近负无穷大的舍入模式。 如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同； 如果为负，则舍入行为与 ROUND_UP 相同。 需要注意的是，此舍入模式始终不会增加原始值。</p><p>第五种，ROUND_HALF_UP，向“最接近的”数字舍入。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同；否则，舍入行为与 ROUND_DOWN 相同。 需要注意的是，这是我们大多数人在小学时就学过的舍入模式（四舍五入）。</p><p>第六种，ROUND_HALF_DOWN，向“最接近的”数字舍入。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同；否则，舍入行为与 ROUND_DOWN 相同（五舍六入）。</p><p>第七种，ROUND_HALF_EVEN，向“最接近的”数字舍入。这种算法叫做银行家算法，具体规则是，四舍六入，五则看前一位，如果是偶数舍入，如果是奇数进位，比如5.5 -&gt; 6，2.5 -&gt; 2。</p><p>第八种，ROUND_UNNECESSARY，假设请求的操作具有精确的结果，也就是不需要进行舍入。如果计算结果产生不精确的结果，则抛出ArithmeticException。</p><p>**问题2：**数据库（比如MySQL）中的浮点数和整型数字，你知道应该怎样定义吗？又如何实现浮点数的准确计算呢？</p><p>答：MySQL中的整数根据能表示的范围有TINYINT、SMALLINT、MEDIUMINT、INTEGER、BIGINT等类型，浮点数包括单精度浮点数FLOAT和双精度浮点数DOUBLE和Java中的float/double一样，同样有精度问题。</p><p>要解决精度问题，主要有两个办法：</p><ul><li>第一，使用DECIMAL类型（和那些INT类型一样，都属于严格数值数据类型），比如DECIMAL(13, 2)或DECIMAL(13, 4)。</li><li>第二，使用整数保存到分，这种方式容易出错，万一读的时候忘记/100或者是存的时候忘记*100，可能会引起重大问题。当然了，我们也可以考虑将整数和小数分开保存到两个整数字段。</li></ul><h3 id="_10-集合类-坑满地的list列表操作" tabindex="-1"><a class="header-anchor" href="#_10-集合类-坑满地的list列表操作"><span><a href="https://time.geekbang.org/column/article/216778" target="_blank" rel="noopener noreferrer">10 | 集合类：坑满地的List列表操作</a></span></a></h3><p>**问题1：**调用类型是Integer的ArrayList的remove方法删除元素，传入一个Integer包装类的数字和传入一个int基本类型的数字，结果一样吗？</p><p>答：传int基本类型的remove方法是按索引值移除，返回移除的值；传Integer包装类的remove方法是按值移除，返回列表移除项目之前是否包含这个值（是否移除成功）。</p><p>为了验证两个remove方法重载的区别，我们写一段测试代码比较一下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private static void removeByIndex(int index) {</span></span>
<span class="line"><span>    List&amp;lt;Integer&amp;gt; list =</span></span>
<span class="line"><span>            IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toCollection(ArrayList::new));</span></span>
<span class="line"><span>    System.out.println(list.remove(index));</span></span>
<span class="line"><span>    System.out.println(list);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>private static void removeByValue(Integer index) {</span></span>
<span class="line"><span>    List&amp;lt;Integer&amp;gt; list =</span></span>
<span class="line"><span>            IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toCollection(ArrayList::new));</span></span>
<span class="line"><span>    System.out.println(list.remove(index));</span></span>
<span class="line"><span>    System.out.println(list);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试一下removeByIndex(4)，通过输出可以看到第五项被移除了，返回5：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>5</span></span>
<span class="line"><span>[1, 2, 3, 4, 6, 7, 8, 9, 10]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>而调用removeByValue(Integer.valueOf(4))，通过输出可以看到值4被移除了，返回true：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>true</span></span>
<span class="line"><span>[1, 2, 3, 5, 6, 7, 8, 9, 10]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>**问题2：**循环遍历List，调用remove方法删除元素，往往会遇到ConcurrentModificationException，原因是什么，修复方式又是什么呢？</p><p>答：原因是，remove的时候会改变modCount，通过迭代器遍历就会触发ConcurrentModificationException。我们看下ArrayList类内部迭代器的相关源码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public E next() {</span></span>
<span class="line"><span>    checkForComodification();</span></span>
<span class="line"><span>    int i = cursor;</span></span>
<span class="line"><span>    if (i &amp;gt;= size)</span></span>
<span class="line"><span>        throw new NoSuchElementException();</span></span>
<span class="line"><span>    Object[] elementData = ArrayList.this.elementData;</span></span>
<span class="line"><span>    if (i &amp;gt;= elementData.length)</span></span>
<span class="line"><span>        throw new ConcurrentModificationException();</span></span>
<span class="line"><span>    cursor = i + 1;</span></span>
<span class="line"><span>    return (E) elementData[lastRet = i];</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final void checkForComodification() {</span></span>
<span class="line"><span>    if (modCount != expectedModCount)</span></span>
<span class="line"><span>        throw new ConcurrentModificationException();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要修复这个问题，有以下两种解决方案。</p><p>第一种，通过ArrayList的迭代器remove。迭代器的remove方法会维护一个expectedModCount，使其与 ArrayList 的modCount保持一致：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&amp;lt;String&amp;gt; list =</span></span>
<span class="line"><span>        IntStream.rangeClosed(1, 10).mapToObj(String::valueOf).collect(Collectors.toCollection(ArrayList::new));</span></span>
<span class="line"><span>for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {</span></span>
<span class="line"><span>    String next = iterator.next();</span></span>
<span class="line"><span>    if (&amp;quot;2&amp;quot;.equals(next)) {</span></span>
<span class="line"><span>        iterator.remove();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>System.out.println(list);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种，直接使用removeIf方法，其内部使用了迭代器的remove方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&amp;lt;String&amp;gt; list =</span></span>
<span class="line"><span>        IntStream.rangeClosed(1, 10).mapToObj(String::valueOf).collect(Collectors.toCollection(ArrayList::new));</span></span>
<span class="line"><span>list.removeIf(item -&amp;gt; item.equals(&amp;quot;2&amp;quot;));</span></span>
<span class="line"><span>System.out.println(list);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_11-空值处理-分不清楚的null和恼人的空指针" tabindex="-1"><a class="header-anchor" href="#_11-空值处理-分不清楚的null和恼人的空指针"><span><a href="https://time.geekbang.org/column/article/216830" target="_blank" rel="noopener noreferrer">11 | 空值处理：分不清楚的null和恼人的空指针</a></span></a></h3><p>**问题1：**ConcurrentHashMap的Key和Value都不能为null，而HashMap却可以，你知道这么设计的原因是什么吗？TreeMap、Hashtable等Map的Key和Value是否支持null呢？</p><p>答：原因正如ConcurrentHashMap的作者所说：</p><blockquote></blockquote><p>The main reason that nulls aren’t allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can’t be accommodated. The main one is that if map.get(key) returns null, you can’t detect whether the key explicitly maps to null vs the key isn’t mapped. In a non-concurrent map, you can check this via map.contains(key), but in a concurrent one, the map might have changed between calls.</p><p>如果Value为null会增加二义性，也就是说多线程情况下map.get(key)返回null，我们无法区分Value原本就是null还是Key没有映射，Key也是类似的原因。此外，我也更同意他的观点，就是普通的Map允许null是否是一个正确的做法，也值得商榷，因为这会增加犯错的可能性。</p><p>Hashtable也是线程安全的，所以Key和Value不可以是null。</p><p>TreeMap是线程不安全的，但是因为需要排序，需要进行key的compareTo方法，所以Key不能是null，而Value可以是null。</p><p>**问题2：**对于Hibernate框架，我们可以使用@DynamicUpdate注解实现字段的动态更新。那么，对于MyBatis框架来说，要如何实现类似的动态SQL功能，实现插入和修改SQL只包含POJO中的非空字段呢？</p><p>答：MyBatis可以通过动态SQL实现：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;lt;select id=&amp;quot;findUser&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;</span></span>
<span class="line"><span>  SELECT * FROM USER</span></span>
<span class="line"><span>  WHERE 1=1</span></span>
<span class="line"><span>  &amp;lt;if test=&amp;quot;name != null&amp;quot;&amp;gt;</span></span>
<span class="line"><span>    AND name like #{name}</span></span>
<span class="line"><span>  &amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>  &amp;lt;if test=&amp;quot;email != null&amp;quot;&amp;gt;</span></span>
<span class="line"><span>    AND email = #{email}</span></span>
<span class="line"><span>  &amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>&amp;lt;/select&amp;gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用MyBatisPlus的话，实现类似的动态SQL功能会更方便。我们可以直接在字段上加@TableField注解来实现，可以设置insertStrategy、updateStrategy、whereStrategy属性。关于这三个属性的使用方式，你可以参考如下源码，或是<a href="https://mp.baomidou.com/guide/annotation.html#tablefield" target="_blank" rel="noopener noreferrer">这里</a>的官方文档：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span>	     * 字段验证策略之 insert: 当insert操作时，该字段拼接insert语句时的策略</span></span>
<span class="line"><span>	     * IGNORED: 直接拼接 insert into table_a(column) values (#{columnProperty});</span></span>
<span class="line"><span>	     * NOT_NULL: insert into table_a(&amp;lt;if test=&amp;quot;columnProperty != null&amp;quot;&amp;gt;column&amp;lt;/if&amp;gt;) values (&amp;lt;if test=&amp;quot;columnProperty != null&amp;quot;&amp;gt;#{columnProperty}&amp;lt;/if&amp;gt;)</span></span>
<span class="line"><span>	     * NOT_EMPTY: insert into table_a(&amp;lt;if test=&amp;quot;columnProperty != null and columnProperty!=&#39;&#39;&amp;quot;&amp;gt;column&amp;lt;/if&amp;gt;) values (&amp;lt;if test=&amp;quot;columnProperty != null and columnProperty!=&#39;&#39;&amp;quot;&amp;gt;#{columnProperty}&amp;lt;/if&amp;gt;)</span></span>
<span class="line"><span>	     *</span></span>
<span class="line"><span>	     * @since 3.1.2</span></span>
<span class="line"><span>	     */</span></span>
<span class="line"><span>	    FieldStrategy insertStrategy() default FieldStrategy.DEFAULT;</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	    /**</span></span>
<span class="line"><span>	     * 字段验证策略之 update: 当更新操作时，该字段拼接set语句时的策略</span></span>
<span class="line"><span>	     * IGNORED: 直接拼接 update table_a set column=#{columnProperty}, 属性为null/空string都会被set进去</span></span>
<span class="line"><span>	     * NOT_NULL: update table_a set &amp;lt;if test=&amp;quot;columnProperty != null&amp;quot;&amp;gt;column=#{columnProperty}&amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>	     * NOT_EMPTY: update table_a set &amp;lt;if test=&amp;quot;columnProperty != null and columnProperty!=&#39;&#39;&amp;quot;&amp;gt;column=#{columnProperty}&amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>	     *</span></span>
<span class="line"><span>	     * @since 3.1.2</span></span>
<span class="line"><span>	     */</span></span>
<span class="line"><span>	    FieldStrategy updateStrategy() default FieldStrategy.DEFAULT;</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	    /**</span></span>
<span class="line"><span>	     * 字段验证策略之 where: 表示该字段在拼接where条件时的策略</span></span>
<span class="line"><span>	     * IGNORED: 直接拼接 column=#{columnProperty}</span></span>
<span class="line"><span>	     * NOT_NULL: &amp;lt;if test=&amp;quot;columnProperty != null&amp;quot;&amp;gt;column=#{columnProperty}&amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>	     * NOT_EMPTY: &amp;lt;if test=&amp;quot;columnProperty != null and columnProperty!=&#39;&#39;&amp;quot;&amp;gt;column=#{columnProperty}&amp;lt;/if&amp;gt;</span></span>
<span class="line"><span>	     *</span></span>
<span class="line"><span>	     * @since 3.1.2</span></span>
<span class="line"><span>	     */</span></span>
<span class="line"><span>	    FieldStrategy whereStrategy() default FieldStrategy.DEFAULT;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_12-异常处理-别让自己在出问题的时候变为瞎子" tabindex="-1"><a class="header-anchor" href="#_12-异常处理-别让自己在出问题的时候变为瞎子"><span><a href="https://time.geekbang.org/column/article/220230" target="_blank" rel="noopener noreferrer">12 | 异常处理：别让自己在出问题的时候变为瞎子</a></span></a></h3><p>**问题1：**关于在finally代码块中抛出异常的坑，如果在finally代码块中返回值，你觉得程序会以try或catch中的返回值为准，还是以finally中的返回值为准呢？</p><p>答：以finally中的返回值为准。</p><p>从语义上来说，finally是做方法收尾资源释放处理的，我们不建议在finally中有return，这样逻辑会很混乱。这是因为，实现上finally中的代码块会被复制多份，分别放到try和catch调用return和throw异常之前，所以finally中如果有返回值，会覆盖try中的返回值。</p><p>**问题2：**对于手动抛出的异常，不建议直接使用Exception或RuntimeException，通常建议复用JDK中的一些标准异常，比如<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" target="_blank" rel="noopener noreferrer">IllegalArgumentException</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html" target="_blank" rel="noopener noreferrer">IllegalStateException</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener noreferrer">UnsupportedOperationException</a>。你能说说它们的适用场景，并列出更多常见的可重用标准异常吗？</p><p>答：我们先分别看看IllegalArgumentException、IllegalStateException、UnsupportedOperationException这三种异常的适用场景。</p><ul><li>IllegalArgumentException：参数不合法异常，适用于传入的参数不符合方法要求的场景。</li><li>IllegalStateException：状态不合法异常，适用于状态机的状态的无效转换，当前逻辑的执行状态不适合进行相应操作等场景。</li><li>UnsupportedOperationException：操作不支持异常，适用于某个操作在实现或环境下不支持的场景。</li></ul><p>还可以重用的异常有IndexOutOfBoundsException、NullPointerException、ConcurrentModificationException等。</p><p>以上，就是咱们这门课第7~12讲的思考题答案了。</p><p>关于这些题目，以及背后涉及的知识点，如果你还有哪里感觉不清楚的，欢迎在评论区与我留言，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>`,82)]))}const c=a(l,[["render",p]]),d=JSON.parse('{"path":"/posts/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E4%BB%A3%E7%A0%81%E7%AF%87/%E7%AD%94%E7%96%91%E7%AF%87%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E9%9B%86%E9%94%A6%EF%BC%88%E4%BA%8C%EF%BC%89.html","title":"","lang":"zh-CN","frontmatter":{"description":"你好，我是朱晔。 今天，我们继续一起分析这门课第7~12讲的课后思考题。这些题目涉及了数据库索引、判等问题、数值计算、集合类、空值处理和异常处理的12道问题。 接下来，我们就一一具体分析吧。 07 | 数据库索引：索引并不是万能药 **问题1：**在介绍二级索引代价时，我们通过EXPLAIN命令看到了索引覆盖和回表的两种情况。你能用optimizer ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/%E4%BB%A3%E7%A0%81%E7%AF%87/%E7%AD%94%E7%96%91%E7%AF%87%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E9%9B%86%E9%94%A6%EF%BC%88%E4%BA%8C%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"你好，我是朱晔。 今天，我们继续一起分析这门课第7~12讲的课后思考题。这些题目涉及了数据库索引、判等问题、数值计算、集合类、空值处理和异常处理的12道问题。 接下来，我们就一一具体分析吧。 07 | 数据库索引：索引并不是万能药 **问题1：**在介绍二级索引代价时，我们通过EXPLAIN命令看到了索引覆盖和回表的两种情况。你能用optimizer ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":12.07,"words":3622},"filePathRelative":"posts/Java业务开发常见错误100例/代码篇/答疑篇：代码篇思考题集锦（二）.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"答疑篇：代码篇思考题集锦（二）\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/20/f8/20ff92d160e92fb43de58a4d197d00f8.mp3\\"></audio></p>\\n<p>你好，我是朱晔。</p>\\n<p>今天，我们继续一起分析这门课第7~12讲的课后思考题。这些题目涉及了数据库索引、判等问题、数值计算、集合类、空值处理和异常处理的12道问题。</p>\\n<p>接下来，我们就一一具体分析吧。</p>","autoDesc":true}');export{c as comp,d as data};

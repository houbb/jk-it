import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-CrA-f6So.js";const p={};function l(r,s){return i(),a("div",null,s[0]||(s[0]=[e(`<h1 id="_36-继承有什么安全缺陷" tabindex="-1"><a class="header-anchor" href="#_36-继承有什么安全缺陷"><span>36 _ 继承有什么安全缺陷？</span></a></h1><p><audio id="audio" title="36 | 继承有什么安全缺陷？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/03/93/03d1c1cd441504b06a53bef54fe21293.mp3"></audio></p><p>有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。</p><p>比如<a href="https://time.geekbang.org/column/article/87256" target="_blank" rel="noopener noreferrer">上一篇文章</a><a href="https://time.geekbang.org/column/article/87256" target="_blank" rel="noopener noreferrer">中</a>，我们说到的敏感信息通过异常信息泄露的问题，就是面向对象设计和实现给我们带来的小困扰。再比如<a href="https://time.geekbang.org/column/article/86590" target="_blank" rel="noopener noreferrer">前面还有</a><a href="https://time.geekbang.org/column/article/86590" target="_blank" rel="noopener noreferrer">一个</a><a href="https://time.geekbang.org/column/article/86590" target="_blank" rel="noopener noreferrer">案例</a>，说到了共享内存或者缓存技术带来的潜在危害和挑战，这些都是成熟技术发展背后需要做出的小妥协。只是有时候，这些小小的妥协如果没有被安排好和处理好，可能就会带来不成比例的代价。</p><h2 id="评审案例" tabindex="-1"><a class="header-anchor" href="#评审案例"><span>评审案例</span></a></h2><p>我们一起来看一段节选的java.io.FilePermission类的定义。你知道为什么FilePermission被定义为final类吗？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package java.io;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * This class represents access to a file or directory.  A</span></span>
<span class="line"><span> * FilePermission consists of a pathname and a set of actions</span></span>
<span class="line"><span> * valid for that pathname.</span></span>
<span class="line"><span> * &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public final class FilePermission</span></span>
<span class="line"><span>        extends Permission implements Serializable {</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * Creates a new FilePermission object with the specified actions.</span></span>
<span class="line"><span>     * &amp;lt;i&amp;gt;path&amp;lt;/i&amp;gt; is the pathname of a file or directory, and</span></span>
<span class="line"><span>     * &amp;lt;i&amp;gt;actions&amp;lt;/i&amp;gt; contains a comma-separated list of the desired</span></span>
<span class="line"><span>     * actions granted on the file or directory. Possible actions are</span></span>
<span class="line"><span>     * &amp;quot;read&amp;quot;, &amp;quot;write&amp;quot;, &amp;quot;execute&amp;quot;, &amp;quot;delete&amp;quot;, and &amp;quot;readlink&amp;quot;.</span></span>
<span class="line"><span>     * &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public FilePermission(String path, String actions);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * Returns the &amp;quot;canonical string representation&amp;quot; of the actions.</span></span>
<span class="line"><span>     * That is, this method always returns present actions in the</span></span>
<span class="line"><span>     * following order: read, write, execute, delete, readlink. </span></span>
<span class="line"><span>     * &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public String getActions();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * Checks if this FilePermission object &amp;quot;implies&amp;quot; the </span></span>
<span class="line"><span>     * specified permission.</span></span>
<span class="line"><span>     * &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span>     * @param p the permission to check against.</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @return &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; if the specified permission</span></span>
<span class="line"><span>     *         is not &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; and is implied by this</span></span>
<span class="line"><span>     *         object, &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; otherwise.</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean implies(Permission p);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // &amp;lt;snipped&amp;gt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FilePermission被声明为final，也就意味着该类不能被继承，不能被扩展了。我们都知道，在面向对象的设计中，是否具备可扩展性是一个衡量设计优劣的好指标。如果允许扩展的话，那么想要增加一个“link”的操作就会方便很多，只要扩展FilePermission类就可以了。 但是对于FilePermission这个类，OpenJDK为什么放弃了可扩展性？</p><h2 id="案例分析" tabindex="-1"><a class="header-anchor" href="#案例分析"><span>案例分析</span></a></h2><p>如果我们保留FilePermission的可扩展性，你来评审一下下面的代码，可以看出这段代码的问题吗？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package com.example;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public final class MyFilePermission extends FilePermission {</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public String getActions() {</span></span>
<span class="line"><span>      return &amp;quot;read&amp;quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean implies(Permission p) {</span></span>
<span class="line"><span>      return true;</span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你还没有找出这个问题，可能是因为我还遗漏了对FilePermission常见使用场景的介绍。在Java的安全管理模式下，一个用户通常可能会被授予有限的权限。 比如用户“xuelei”可以读取用户“duke”的文件，但不能更改用户“duke”的文件。</p><p>授权的策咯可能看起来像下面的描述：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>grant Principal com.sun.security.auth.UnixPrincipal &amp;quot;xuelei&amp;quot; {</span></span>
<span class="line"><span>    permission com.example.MyFilePermission &amp;quot;/home/duke&amp;quot;, &amp;quot;read&amp;quot;;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这项策略要想起作用，上面的描述就要转换成一个MyFilePermission的实例。然后调用该实例的implies()方法类判断是否可以授权一项操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Permission myPermission = ...  // read &amp;quot;/home/duke&amp;quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void checkRead() {</span></span>
<span class="line"><span>  if (myPermission.implies(New FilePermission(file, &amp;quot;read&amp;quot;))) {</span></span>
<span class="line"><span>    // read is allowed.</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    // throw exception, read is not allowed.</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void checkWrite() {</span></span>
<span class="line"><span>  if (myPermission.implies(New FilePermission(file, &amp;quot;write&amp;quot;))) {</span></span>
<span class="line"><span>    // writeis allowed.</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    // throw exception, write is not allowed.</span></span>
<span class="line"><span>  }  </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里请注意，MyFilePermission.implies()总是返回“true”， 所以上述的checkRead()和checkWrite()方法总是成功的，不管用户被明确指示授予了什么权限，实际上暗地里他已经被授予了所有权限。这就成功地绕过了Java的安全管理。</p><p>能够绕过Java安全机制的主要原因，在于我们允许了FilePermission的扩展。而扩展类的实现，有可能有意或者无意地改变了FilePermission的规范和运行，从而带来不可预料的行为。</p><p>如果你关注OpenJDK安全组的代码评审邮件组，你可能会注意到，对于面向对象的可扩展性这一便利和诱惑，很多工程师能够保持住克制。</p><p>保持克制，可能会遗漏一两颗看似近在眼前的甜甜的糖果，但可以减轻你对未来长期的担忧。</p><p>一个类或者方法如果使用了final关键字，我们可以稍微放宽心。如果没有使用final关键字，我们可能需要反复揣摩好长时间，仔细权衡可扩展性可能会带来的弊端。</p><p>一个公共类或者方法如果使用了final关键字，将来如果需要扩展性，就可以去掉这个关键字。但是，如果最开始没有使用final关键字，特别是对于公开的接口来说，将来想要加上就可能是一件非常困难的事。</p><p>上面的例子是子类通过改变父类的规范和行为带来的潜在问题。那么父类是不是也可以改变子类的行为呢？ 这听起来有点怪异，但是父类对子类行为的影响，有时候也的确是一个让人非常头疼的问题。</p><h2 id="麻烦的继承" tabindex="-1"><a class="header-anchor" href="#麻烦的继承"><span>麻烦的继承</span></a></h2><p>我先总结一下，父类对子类行为的影响大致有三种：</p><li> 改变未继承方法的实现，或者子类调用的方法的实现（super）； </li><li> 变更父类或者父类方法的规范； </li><li> 为父类添加新方法。 </li><p>第一种和第三种相对比较容易理解，第二种稍微复杂一点。我们还是通过一个例子来看看其中的问题。</p><p>Hashtable是一个古老的，被广泛使用的类，它最先出现在JDK 1.0中。其中，put()和remove()是两个关键的方法。在JDK 1.2中，又有更多的方法被添加进来，比如entrySet()方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class Hashtable&amp;lt;K,V&amp;gt; ... {</span></span>
<span class="line"><span>    // snipped</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * Returns a {@link Set} view of the mappings contained in</span></span>
<span class="line"><span>     （ this map.</span></span>
<span class="line"><span>     * The set is backed by the map, so changes to the map are</span></span>
<span class="line"><span>     * reflected in the set, and vice-versa.  If the map is modified</span></span>
<span class="line"><span>     * while an iteration over the set is in progress (except through</span></span>
<span class="line"><span>     * the iterator&#39;s own {@code remove} operation, or through the</span></span>
<span class="line"><span>     * {@code setValue} operation on a map entry returned by the</span></span>
<span class="line"><span>     * iterator) the results of the iteration are undefined.  The set</span></span>
<span class="line"><span>     * supports element removal, which removes the corresponding</span></span>
<span class="line"><span>     * mapping from the map, via the {@code Iterator.remove},</span></span>
<span class="line"><span>     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and</span></span>
<span class="line"><span>     * {@code clear} operations.  It does not support the</span></span>
<span class="line"><span>     * {@code add} or {@code addAll} operations.</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @since 1.2</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet() {</span></span>
<span class="line"><span>        // snipped</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // snipped</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就引入了一个难以察觉的潜在的安全漏洞。 你可能会问，添加一个方法不是很常见吗？这能有什么问题呢？</p><p>问题在于继承Hashtable的子类。假设有一个子类，它的Hashtable里要存放敏感数据，数据的添加和删除都需要授权，在JDK 1.2之前，这个子类可以重写put()和remove()方法，加载权限检查的代码。在JDK 1.2中，这个子类可能意识不到Hashtable添加了entrySet()这个新方法，从而也没有意识到要重写覆盖entrySet()方法，然而，通过对entrySet()返回值的直接操作，就可以执行数据的添加和删除的操作，成功地绕过了授权。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class MySensitiveData extends Hashtable&amp;lt;Object, Object&amp;gt; {</span></span>
<span class="line"><span>    // snipped</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public synchronized Object put(Object key, Object value) {</span></span>
<span class="line"><span>        // check permission and then add the key-value</span></span>
<span class="line"><span>        // snipped</span></span>
<span class="line"><span>        super.put(key, value)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public synchronized Object remove(Object key) {</span></span>
<span class="line"><span>        // check permission and then remove the key-value</span></span>
<span class="line"><span>        // snipped</span></span>
<span class="line"><span>        return super.remove(key);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // snipped, no override of entrySet()</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>MySensitiveData sensitiveData = ...   // get the handle of the data</span></span>
<span class="line"><span>Set&amp;lt;Map.Entry&amp;lt;Object, Object&amp;gt;&amp;gt; sdSet = sensitiveData.entrySet();</span></span>
<span class="line"><span>sdSet.remove(...);    // no permission check</span></span>
<span class="line"><span>sdSet.add(...);       // no permission check</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// the sensitive data get modified, unwarranted.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现实中，这种问题非常容易发生。一般来说，我们的代码总是依赖一定的类库，有时候需要扩展某些类。这个类库可能是第三方的产品，也可能是一个独立的内部类库。但遗憾的是，类库并不知道我们需要拓展哪些类，也可能没办法知道我们该如何拓展。</p><p>所以，当有一个新方法添加到类库的新版本中时，这个新方法会如何影响扩展类，该类库也没有特别多的想象空间和处理办法。就像Hashtable要增加entrySet()方法时，让Hashtable的维护者意识到有一个特殊的MySensitiveData扩展，是非常困难和不现实的。然而Hashtable增加entrySet()方法，合情又合理，也没有什么值得抱怨的。</p><p>然而，当JDK 1.0/1.1升级到JDK 1.2时，Hashtable增加了entrySet()方法，上述的MySensitiveData的实现就存在严重的安全漏洞。要想修复该安全漏洞，MySensitiveData需要重写覆盖entrySet()方法，植入权限检查的代码。</p><p>可是，我们怎样可能知道MySensitiveData需要修改呢！ 一般来说，如果依赖的类库进行了升级，没有影响应用的正常运营，我们就正常升级了，而不会想到检查依赖类库做了哪些具体的变更，以及评估每个变更潜在的影响。这实在不是软件升级的初衷，也远远超越了大部分组织的能力范围。</p><p>而且，如果MySensitiveData不是直接继承Hashtable，而是经过了中间环节，这个问题就会更加隐晦，更加难以察觉。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class IntermediateOne extends Hashtable&amp;lt;Object, Object&amp;gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class IntermediateTwo extends IntermediateOne;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class Intermediate extends IntermediateTwo;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class MySensitiveData extends Intermediate;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>糟糕的是，随着语言变得越来越高级，类库越来越丰富，发现这些潜在问题的难度也是节节攀升。我几乎已经不期待肉眼可以发现并防范这类问题了。</p><p>那么，到底有没有办法可以防范此类风险呢？</p><p>主要有两个方法。</p><p><strong>一方面，当我们变更一个可扩展类时，要极其谨慎小心</strong>。一个类如果可以不变更，就尽量不要变更，能在现有框架下解决问题，就尽量不要试图创造新的轮子。有时候，我们的确难以压制想要创造出什么好东西的冲动，这是非常好的品质。只是变更公开类库时，一定要多考虑这么做的潜在影响。你是不是开始思念final关键字的好处了？</p><p><strong>另一方面，当我们扩展一个类时，如果涉及到敏感信息的授权与保护，可以考虑使用代理的模式，而不是继承的模式</strong>。代理模式可以有效地降低可扩展对象的新增方法带来的影响。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class MySensitiveData {</span></span>
<span class="line"><span>    private final Hashtable hashtable = ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public synchronized Object put(Object key, Object value) {</span></span>
<span class="line"><span>        // check permission and then add the key-value</span></span>
<span class="line"><span>        hashtable.put(key, value)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public synchronized Object remove(Object key) {</span></span>
<span class="line"><span>        // check permission and then remove the key-value</span></span>
<span class="line"><span>        return hashtable.remove(key);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用了Java语言来讨论继承的问题，其实**这是一个面向对象机制的普遍的问****题，**甚至它也不单单是面向对象语言的问题，比如使用C语言的设计和实现，也存在类似的问题。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>通过对这个案例的讨论，我想和你分享下面两点个人看法。</p><li> **一个可扩展的类，子类和父类可能会相互影响，从而导致不可预知的行为。** </li><li> **涉及敏感信息的类，增加可扩展性不一定是个优先选项，要尽量避免父类或者子类的影响。** </li><p>学会处理和保护敏感信息，是一个优秀工程师必须迈过的门槛。</p><h2 id="一起来动手" tabindex="-1"><a class="header-anchor" href="#一起来动手"><span>一起来动手</span></a></h2><p>了解语言和各种固定模式的缺陷，是我们打怪升级的一个很好的办法。有时候，我们偏重于学习语言或者设计经验的优点，忽视了它们背后做出小小的妥协，或者缺陷。如果能利用好优点，处理好缺陷，我们就可以更好地掌握这些经验总结。毕竟世上哪有什么完美的东西呢？不完美的东西，用好了，就是好东西。</p><p>我们利用讨论区，来聊聊设计模式这个老掉牙的、备受争议的话题。说起“老掉牙”，科技的进步真是快，设计模式十多年前还是一个时髦的话题，如今已经不太受待见了，虽然我们或多或少，或直接或间接地都受益于设计模式的思想。如果你了解过设计模式，你能够分享某个设计模式的优点和缺陷吗？ 使用设计模式有没有给你带来实际的困扰呢？</p><p>上面的例子中，我们提到了使用代理模式来降低父类对子类的影响。那么你知道代理模式的缺陷吗？</p><p>欢迎你把自己的经验和看法写在留言区，我们一起来学习、思考、精进！</p><p>如果你觉得这篇文章有所帮助，欢迎点击“请朋友读”，把它分享给你的朋友或者同事。</p>`,59)]))}const c=n(p,[["render",l]]),o=JSON.parse('{"path":"/posts/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E7%AC%AC%E4%B8%89%E6%A8%A1%E5%9D%97%EF%BC%9A%E4%BB%A3%E7%A0%81%E2%80%9C%E5%AE%89%E5%85%A8%E2%80%9D%E7%AF%87/36%20_%20%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%EF%BC%9F.html","title":"36 _ 继承有什么安全缺陷？","lang":"zh-CN","frontmatter":{"description":"36 _ 继承有什么安全缺陷？ 有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。 比如上一篇文章中，我们说到的敏感信息通过异常信息泄露的问题，就是面向对象设计和实现给我们带来的小困扰。再比如前面还有一个案例，说到了共享内存或者缓存技术带来的潜在危害和挑战，这些都...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E7%AC%AC%E4%B8%89%E6%A8%A1%E5%9D%97%EF%BC%9A%E4%BB%A3%E7%A0%81%E2%80%9C%E5%AE%89%E5%85%A8%E2%80%9D%E7%AF%87/36%20_%20%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"36 _ 继承有什么安全缺陷？"}],["meta",{"property":"og:description","content":"36 _ 继承有什么安全缺陷？ 有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。 比如上一篇文章中，我们说到的敏感信息通过异常信息泄露的问题，就是面向对象设计和实现给我们带来的小困扰。再比如前面还有一个案例，说到了共享内存或者缓存技术带来的潜在危害和挑战，这些都..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"36 _ 继承有什么安全缺陷？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":11.08,"words":3323},"filePathRelative":"posts/代码精进之路/第三模块：代码“安全”篇/36 _ 继承有什么安全缺陷？.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"36 | 继承有什么安全缺陷？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/03/93/03d1c1cd441504b06a53bef54fe21293.mp3\\"></audio></p>\\n<p>有时候，为了解决一个问题，我们需要一个解决办法。可是，这个办法本身还会带来更多的问题。新问题的解决带来更新的问题，就这样周而复始，绵延不绝。</p>\\n<p>比如<a href=\\"https://time.geekbang.org/column/article/87256\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">上一篇文章</a><a href=\\"https://time.geekbang.org/column/article/87256\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">中</a>，我们说到的敏感信息通过异常信息泄露的问题，就是面向对象设计和实现给我们带来的小困扰。再比如<a href=\\"https://time.geekbang.org/column/article/86590\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">前面还有</a><a href=\\"https://time.geekbang.org/column/article/86590\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一个</a><a href=\\"https://time.geekbang.org/column/article/86590\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">案例</a>，说到了共享内存或者缓存技术带来的潜在危害和挑战，这些都是成熟技术发展背后需要做出的小妥协。只是有时候，这些小小的妥协如果没有被安排好和处理好，可能就会带来不成比例的代价。</p>","autoDesc":true}');export{c as comp,o as data};

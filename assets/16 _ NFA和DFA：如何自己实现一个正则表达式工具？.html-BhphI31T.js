import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-6Bz2fGO5.js";const p={};function l(t,s){return i(),n("div",null,s[0]||(s[0]=[e(`<p><audio id="audio" title="16 | NFA和DFA：如何自己实现一个正则表达式工具？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/c6/e9/c693a53e2eccfedc3359aef4538907e9.mp3"></audio></p><p>回顾之前讲的内容，原理篇重在建立直观理解，帮你建立信心，这是第一轮的认知迭代。应用篇帮你涉足应用领域，在解决领域问题时发挥编译技术的威力，积累运用编译技术的一手经验，也启发你用编译技术去解决更多的领域问题，这是第二轮的认知迭代。而为时三节课的算法篇将你是第三轮的认知迭代。</p><p>在第三轮的认知迭代中，我会带你掌握前端技术中的核心算法。而本节课，我就借“怎样实现正则表达式工具？”这个问题，探讨第一组算法：<strong>与正则表达式处理有关的算法。</strong></p><p>在词法分析阶段，我们可以手工构造有限自动机（FSA，或FSM）实现词法解析，过程比较简单。现在我们不再手工构造词法分析器，而是直接用正则表达式解析词法。</p><p>你会发现，我们只要写一些规则，就能基于这些规则分析和处理文本。这种能够理解正则表达式的功能，除了能生成词法分析器，还有很多用途。比如Linux的三个超级命令，又称三剑客（grep、awk和sed），都是因为能够直接支持正则表达式，功能才变得强大的。</p><p>接下来，我就带你完成编写正则表达式工具的任务，与此同时，你就能用正则文法生成词法分析器了：</p><p>**首先，**把正则表达式翻译成非确定的有限自动机（Nondeterministic Finite Automaton，NFA）。<br><br> **其次，**基于NFA处理字符串，看看它有什么特点。<br><br> **然后，**把非确定的有限自动机转换成确定的有限自动机（Deterministic Finite Automaton，DFA）<br><br> **最后，**运行DFA，看看它有什么特点。</p><p>强调一下，不要被非确定的有限自动机、确定的有限自动机这些概念吓倒，我肯定让你学明白。</p><h2 id="认识dfa和nfa" tabindex="-1"><a class="header-anchor" href="#认识dfa和nfa"><span>认识DFA和NFA</span></a></h2><p>在讲词法分析时，我提到有限自动机（FSA）有有限个状态。识别Token的过程，就是FSA状态迁移的过程。其中，FSA分为<strong>确定的有限自动机（DFA）<strong>和</strong>非确定的有限自动机（NFA）。</strong></p><p>**DFA的特点是，**在任何一个状态，我们基于输入的字符串，都能做一个确定的转换，比如：</p><img src="https://static001.geekbang.org/resource/image/15/35/15da400d09ede2ce6ac60fa6d5342835.jpg" alt=""><p>**NFA的特点是，**它存在某些状态，针对某些输入，不能做一个确定的转换，这又细分成两种情况：</p><ul><li>对于一个输入，它有两个状态可以转换。</li><li>存在ε转换。也就是没有任何输入的情况下，也可以从一个状态迁移到另一个状态。</li></ul><p>比如，“a[a-zA-Z0-9]*bc”这个正则表达式对字符串的要求是以a开头，以bc结尾，a和bc之间可以有任意多个字母或数字。在图中状态1的节点输入b时，这个状态是有两条路径可以选择的，所以这个有限自动机是一个NFA。</p><img src="https://static001.geekbang.org/resource/image/9b/e8/9bf26739958568453cceeb6f209da2e8.jpg" alt=""><p>这个NFA还有引入ε转换的画法，它们是等价的。实际上，第二个NFA可以用我们今天讲的算法，通过正则表达式自动生成出来。</p><img src="https://static001.geekbang.org/resource/image/9b/09/9bb22ee26309b3076db53fee34112009.jpg" alt=""><p>需要注意的是，无论是NFA还是DFA，都等价于正则表达式。也就是，所有的正则表达式都能转换成NFA或DFA，所有的NFA或DFA，也都能转换成正则表达式。</p><p>理解了NFA和DFA之后，来看看我们如何从正则表达式生成NFA。</p><h2 id="从正则表达式生成nfa" tabindex="-1"><a class="header-anchor" href="#从正则表达式生成nfa"><span>从正则表达式生成NFA</span></a></h2><p>我们需要把它分为两个子任务：</p><p>**第一个子任务，**是把正则表达式解析成一个内部的数据结构，便于后续的程序使用。因为正则表达式也是个字符串，所以要先做一个小的编译器，去理解代表正则表达式的字符串。我们可以偷个懒，直接针对示例的正则表达式生成相应的数据结构，不需要做出这个编译器。</p><p>用来测试的正则表达式可以是int关键字、标识符，或者数字字面量：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int | [a-zA-Z][a-zA-Z0-9]* | [0-9]+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我用下面这段代码创建了一个树状的数据结构，来代表用来测试的正则表达式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private static GrammarNode sampleGrammar1() {</span></span>
<span class="line"><span>    GrammarNode node = new GrammarNode(&amp;quot;regex1&amp;quot;,GrammarNodeType.Or);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //int关键字</span></span>
<span class="line"><span>    GrammarNode intNode = node.createChild(GrammarNodeType.And);</span></span>
<span class="line"><span>    intNode.createChild(new CharSet(&#39;i&#39;));</span></span>
<span class="line"><span>    intNode.createChild(new CharSet(&#39;n&#39;));</span></span>
<span class="line"><span>    intNode.createChild(new CharSet(&#39;t&#39;));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //标识符</span></span>
<span class="line"><span>    GrammarNode idNode = node.createChild(GrammarNodeType.And);</span></span>
<span class="line"><span>    GrammarNode firstLetter = idNode.createChild(CharSet.letter);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    GrammarNode letterOrDigit = idNode.createChild(CharSet.letterOrDigit);</span></span>
<span class="line"><span>    letterOrDigit.setRepeatTimes(0, -1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //数字字面量</span></span>
<span class="line"><span>    GrammarNode literalNode = node.createChild(CharSet.digit);</span></span>
<span class="line"><span>    literalNode.setRepeatTimes(1, -1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return node;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打印输出的结果如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>RegExpression</span></span>
<span class="line"><span>	Or</span></span>
<span class="line"><span>		Union</span></span>
<span class="line"><span>			i</span></span>
<span class="line"><span>			n</span></span>
<span class="line"><span>			t</span></span>
<span class="line"><span>		Union</span></span>
<span class="line"><span>			[a-z]|[A-Z]</span></span>
<span class="line"><span>			[0-9]|[a-z]|[A-Z]*</span></span>
<span class="line"><span>		[0-9]+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>画成图会更直观一些：</p><img src="https://static001.geekbang.org/resource/image/a6/8e/a6af22cdcb96ba92fe9df35bf998768e.jpg" alt=""><p>测试数据生成之后，<strong>第二个子任务</strong>就是把表示正则表达式的数据结构，转换成一个NFA。这个过程比较简单，因为针对正则表达式中的每一个结构，我们都可以按照一个固定的规则做转换。</p><ul><li>识别ε的NFA：</li></ul><blockquote></blockquote><p>不接受任何输入，也能从一个状态迁移到另一个状态，状态图的边上标注ε。</p><img src="https://static001.geekbang.org/resource/image/0d/ed/0d11ad629f809a94ff091199f27661ed.jpg" alt=""><ul><li>识别i的NFA：</li></ul><blockquote></blockquote><p>当接受字符i的时候，引发一个转换，状态图的边上标注i。</p><img src="https://static001.geekbang.org/resource/image/fe/bc/fe3edc36b5bd69e88eebcd0d28aa4abc.jpg" alt=""><ul><li>转换“s|t”这样的正则表达式：</li></ul><blockquote></blockquote><p>它的意思是或者s，或者t，二者选一。s和t本身是两个子表达式，我们可以增加两个新的状态：**开始状态和接受状态（最终状态）**也就是图中带双线的状态，它意味着被检验的字符串此时是符合正则表达式的。然后用ε转换分别连接代表s和t的子图。它的含义也比较直观，要么走上面这条路径，那就是s，要么走下面这条路径，那就是t。</p><img src="https://static001.geekbang.org/resource/image/19/95/197071ebe504889264cf8c955d112895.jpg" alt=""><ul><li>转换“st”这样的正则表达式：</li></ul><blockquote></blockquote><p>s之后接着出现t，转换规则是把s的开始状态变成st整体的开始状态，把t的结束状态变成st整体的结束状态，并且把s的结束状态和t的开始状态合二为一。这样就把两个子图接了起来，走完s接着走t。</p><img src="https://static001.geekbang.org/resource/image/95/0b/9504b495df0de1cc59ef8d8357c49e0b.jpg" alt=""><ul><li>对于“?”“*”和“+”这样的操作：</li></ul><blockquote></blockquote><p>意思是可以重复0次、0到多次、1到多次，转换时要增加额外的状态和边。</p><p>以“s*”为例，做下面的转换：</p><img src="https://static001.geekbang.org/resource/image/40/c5/409d889a2c811221a0cfdd81f32df4c5.jpg" alt=""><p>你能看出，它可以从i直接到f，也就是对s匹配零次，也可以在s的起止节点上循环多次。</p><ul><li>“s+”：</li></ul><blockquote></blockquote><p>没有办法跳过s，s至少经过一次。</p><img src="https://static001.geekbang.org/resource/image/a7/07/a753fb42e82341d381c3cbca0247b007.png" alt=""><p>按照这些规则，我们可以编写程序进行转换。你可以参考示例代码<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Regex.java" target="_blank" rel="noopener noreferrer">Regex.java</a>中的regexToNFA方法。转换完毕以后，将生成的NFA打印输出，列出了所有的状态，以及每个状态到其他状态的转换，比如“0 ε -&gt; 2”的意思是从状态0通过ε转换，到达状态2 ：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>NFA states:</span></span>
<span class="line"><span>0	ε -&amp;gt; 2</span></span>
<span class="line"><span>	ε -&amp;gt; 8</span></span>
<span class="line"><span>	ε -&amp;gt; 14</span></span>
<span class="line"><span>2	i -&amp;gt; 3</span></span>
<span class="line"><span>3	n -&amp;gt; 5</span></span>
<span class="line"><span>5	t -&amp;gt; 7</span></span>
<span class="line"><span>7	ε -&amp;gt; 1</span></span>
<span class="line"><span>1	(end)</span></span>
<span class="line"><span>	acceptable</span></span>
<span class="line"><span>8	[a-z]|[A-Z] -&amp;gt; 9</span></span>
<span class="line"><span>9	ε -&amp;gt; 10</span></span>
<span class="line"><span>	ε -&amp;gt; 13</span></span>
<span class="line"><span>10	[0-9]|[a-z]|[A-Z] -&amp;gt; 11</span></span>
<span class="line"><span>11	ε -&amp;gt; 10</span></span>
<span class="line"><span>	ε -&amp;gt; 13</span></span>
<span class="line"><span>13	ε -&amp;gt; 1</span></span>
<span class="line"><span>14	[0-9] -&amp;gt; 15</span></span>
<span class="line"><span>15	ε -&amp;gt; 14</span></span>
<span class="line"><span>	ε -&amp;gt; 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我用图片直观地展示了输出结果，图中分为上中下三条路径，你能清晰地看出解析int关键字、标识符和数字字面量的过程：</p><img src="https://static001.geekbang.org/resource/image/3d/9b/3defa4a1d7ce789b6c6cfecdfbf8179b.jpg" alt=""><p>生成NFA之后，如何利用它识别某个字符串是否符合这个NFA代表的正则表达式呢？</p><p>以上图为例，当我们解析intA这个字符串时，首先选择最上面的路径去匹配，匹配完int这三个字符以后，来到状态7，若后面没有其他字符，就可以到达接受状态1，返回匹配成功的信息。可实际上，int后面是有A的，所以第一条路径匹配失败。</p><p>失败之后不能直接返回“匹配失败”的结果，因为还有其他路径，所以我们要回溯到状态0，去尝试第二条路径，在第二条路径中，尝试成功了。</p><p>运行Regex.java中的matchWithNFA()方法，你可以用NFA来做正则表达式的匹配：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span> * 用NFA来匹配字符串</span></span>
<span class="line"><span> * @param state 当前所在的状态</span></span>
<span class="line"><span> * @param chars 要匹配的字符串，用数组表示</span></span>
<span class="line"><span> * @param index1 当前匹配字符开始的位置。</span></span>
<span class="line"><span> * @return 匹配后，新index的位置。指向匹配成功的字符的下一个字符。</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>private static int matchWithNFA(State state, char[] chars, int index1){</span></span>
<span class="line"><span>    System.out.println(&amp;quot;trying state : &amp;quot; + state.name + &amp;quot;, index =&amp;quot; + index1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int index2 = index1;</span></span>
<span class="line"><span>    for (Transition transition : state.transitions()){</span></span>
<span class="line"><span>        State nextState = state.getState(transition);</span></span>
<span class="line"><span>        //epsilon转换</span></span>
<span class="line"><span>        if (transition.isEpsilon()){</span></span>
<span class="line"><span>            index2 = matchWithNFA(nextState, chars, index1);</span></span>
<span class="line"><span>            if (index2 == chars.length){</span></span>
<span class="line"><span>                break;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        //消化掉一个字符，指针前移</span></span>
<span class="line"><span>        else if (transition.match(chars[index1])){</span></span>
<span class="line"><span>            index2 ++; //消耗掉一个字符</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if (index2 &amp;lt; chars.length) {</span></span>
<span class="line"><span>                index2 = matchWithNFA(nextState, chars, index1 + 1);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            //如果已经扫描完所有字符</span></span>
<span class="line"><span>            //检查当前状态是否是接受状态，或者可以通过epsilon到达接受状态</span></span>
<span class="line"><span>            //如果状态机还没有到达接受状态，本次匹配失败</span></span>
<span class="line"><span>            else {</span></span>
<span class="line"><span>                if (acceptable(nextState)) {</span></span>
<span class="line"><span>                    break;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                else{</span></span>
<span class="line"><span>                    index2 = -1;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return index2;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，在匹配“intA”时，你会看到它的回溯过程：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>NFA matching: &#39;intA&#39;</span></span>
<span class="line"><span>trying state : 0, index =0</span></span>
<span class="line"><span>trying state : 2, index =0    //先走第一条路径，即int关键字这个路径</span></span>
<span class="line"><span>trying state : 3, index =1</span></span>
<span class="line"><span>trying state : 5, index =2</span></span>
<span class="line"><span>trying state : 7, index =3</span></span>
<span class="line"><span>trying state : 1, index =3    //到了末尾了，发现还有字符&#39;A&#39;没有匹配上</span></span>
<span class="line"><span>trying state : 8, index =0    //回溯，尝试第二条路径，即标识符</span></span>
<span class="line"><span>trying state : 9, index =1</span></span>
<span class="line"><span>trying state : 10, index =1   //在10和11这里循环多次</span></span>
<span class="line"><span>trying state : 11, index =2</span></span>
<span class="line"><span>trying state : 10, index =2</span></span>
<span class="line"><span>trying state : 11, index =3</span></span>
<span class="line"><span>trying state : 10, index =3</span></span>
<span class="line"><span>true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**从中可以看到用NFA算法的特点：**因为存在多条可能的路径，所以需要试探和回溯，在比较极端的情况下，回溯次数会非常多，性能会变得非常慢。特别是当处理类似s*这样的语句时，因为s可以重复0到无穷次，所以在匹配字符串时，可能需要尝试很多次。</p><p>注意，在我们生成的NFA中，如果一个状态有两条路径到其他状态，算法会依据一定的顺序来尝试不同的路径。</p><p>9和11两个状态都有两条向外走的线，其中红色的线是更优先的路径，也就是尝试让*号匹配尽量多的字符。这种算法策略叫做“贪婪（greedy）”策略。</p><p>在有的情况下，我们会希望让算法采用非贪婪策略，或者叫“忽略优先”策略，以便让效率更高。有的正则表达式工具会支持多加一个?，比如??、*?、+?，来表示非贪婪策略。</p><p>NFA的运行可能导致大量的回溯，所以能否将NFA转换成DFA，让字符串的匹配过程更简单呢？如果能的话，那整个过程都可以自动化，从正则表达式到NFA，再从NFA到DFA。</p><h2 id="把nfa转换成dfa" tabindex="-1"><a class="header-anchor" href="#把nfa转换成dfa"><span>把NFA转换成DFA</span></a></h2><p>的确有这样的算法，那就是**子集构造法，**它的思路如下。</p><p>首先NFA有一个初始状态（从状态0通过ε转换可以到达的所有状态，也就是说，在不接受任何输入的情况下，从状态0也可以到达的状态）。这个状态的集合叫做“状态0的ε闭包”，简单一点儿，我们称之为s0，s0包含0、2、8、14这几个状态。</p><img src="https://static001.geekbang.org/resource/image/9c/f7/9c35bf11efb869c5fa4a22e23de52ff7.jpg" alt=""><p>将字母i给到s0中的每一个状态，看它们能转换成什么状态，再把这些状态通过ε转换就能到达的状态也加入进来，形成一个包含“3、9、10、13、1”5个状态的集合s1。其中3和9是接受了字母i所迁移到的状态，10、13、1是在状态9的ε闭包中。</p><img src="https://static001.geekbang.org/resource/image/d2/40/d2f3035a3492b680c56777b7fa375e40.jpg" alt=""><p>在s0和s1中间画条迁移线，标注上i，意思是s0接收到i的情况下，转换到s1：</p><img src="https://static001.geekbang.org/resource/image/58/29/58388daf0627d0bc71efbf7b48401029.jpg" alt=""><p>在这里，我们把s0和s1分别看成一个状态。也就是说，要生成的DFA，它的每个状态，\b是原来的NFA的某些状态的集合。</p><p>在上面的推导过程中，我们有两个主要的计算：</p><p>1.ε-closure(s)，即集合s的ε闭包。也就是从集合s中的每个节点，加上从这个节点出发通过ε转换所能到达的所有状态。<br><br> 2.move(s, ‘i’)，即从集合s接收一个字符i，所能到达的新状态的集合。<br><br> 所以，s1 = ε-closure(move(s0,‘i’))</p><p>按照上面的思路继续推导，识别int关键字的识别路径也就推导出来了：</p><img src="https://static001.geekbang.org/resource/image/be/00/be1a150ce14e828e8e9993b419360e00.jpg" alt=""><p>我们把上面这种推导的思路写成算法，参见<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Regex.java" target="_blank" rel="noopener noreferrer">Regex.java</a>中的NFA2DFA()方法。我写了一段伪代码，方便你阅读：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>计算s0，即状态0的ε闭包</span></span>
<span class="line"><span>把s0压入待处理栈</span></span>
<span class="line"><span>把s0加入所有状态集的集合S</span></span>
<span class="line"><span>循环：待处理栈内还有未处理的状态集</span></span>
<span class="line"><span>   循环：针对字母表中的每个字符c</span></span>
<span class="line"><span>      循环：针对栈里的每个状态集合s(i)（未处理的状态集）</span></span>
<span class="line"><span>          计算s(m) = move(s(i), c)（就是从s(i)出发，接收字符c能够</span></span>
<span class="line"><span>                                   迁移到的新状态的集合）</span></span>
<span class="line"><span>          计算s(m)的ε闭包，叫做s(j)</span></span>
<span class="line"><span>          看看s(j)是不是个新的状态集，如果已经有这个状态集了，把它找出来</span></span>
<span class="line"><span>                  否则，把s(j)加入全集S和待处理栈</span></span>
<span class="line"><span>          建立s(i)到s(j)的连线，转换条件是c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行NFA2DFA()方法，然后打印输出生成的DFA。画成图，你就能很直观地看出迁移的路径了：</p><img src="https://static001.geekbang.org/resource/image/b3/ea/b31b50f7b527de9915b81cb7a117c2ea.jpg" alt=""><p>从初始状态开始，如果输入是i，那就走int识别这条线，也就是按照19、21、22这条线依次迁移，如果中间发现不符合int模式，就跳转到20，也就是标识符状态。</p><p>注意，在上面的DFA中，只要包含接受状态1的，都是DFA的接受状态。进一步区分的话，22是int关键字的接受状态，因为它包含了int关键字原来的接受状态7。同理，17是数字字面量的接受状态，18、19、20、21都是标识符的接受状态。</p><p>而且，你会发现，算法生成的DFA跟手工构造DFA是很接近的！我们在第二讲手工构造了DFA识别int关键字和标识符，比本节课少识别一个数字字面量：</p><img src="https://static001.geekbang.org/resource/image/11/3c/11cf7add8fb07db41f4eb067db4ac13c.jpg" alt=""><p>不过，光看对int关键字和标识符的识别，我们算法生成的DFA和手工构造的DFA，非常相似！手工构造的相当于把18和20两个状态合并了，所以，这个算法是非常有效的！你可以运行一下示例程序Regex.java中的matchWithDFA()的方法，看看效果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private static boolean matchWithDFA(DFAState state, char[] chars, int index){</span></span>
<span class="line"><span>    System.out.println(&amp;quot;trying DFAState : &amp;quot; + state.name + &amp;quot;, index =&amp;quot; + index);</span></span>
<span class="line"><span>    //根据字符，找到下一个状态</span></span>
<span class="line"><span>    DFAState nextState = null;</span></span>
<span class="line"><span>    for (Transition transition : state.transitions()){</span></span>
<span class="line"><span>        if (transition.match(chars[index])){</span></span>
<span class="line"><span>            nextState = (DFAState)state.getState(transition);</span></span>
<span class="line"><span>            break;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (nextState != null){</span></span>
<span class="line"><span>        //继续匹配字符串</span></span>
<span class="line"><span>        if (index &amp;lt; chars.length-1){</span></span>
<span class="line"><span>            return matchWithDFA(nextState,chars, index + 1);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        else{</span></span>
<span class="line"><span>            //字符串已经匹配完毕</span></span>
<span class="line"><span>            //看看是否到达了接受状态</span></span>
<span class="line"><span>            if(state.isAcceptable()){</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            else{</span></span>
<span class="line"><span>                return false;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    else{</span></span>
<span class="line"><span>        return false;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行时会打印输出匹配过程，而执行过程中不产生任何回溯。</p><p>现在，我们可以自动生成DFA了，可以根据DFA做更高效的计算。不过，有利就有弊，DFA也存在一些缺点。比如，DFA可能有很多个状态。</p><p>假设原来NFA的状态有n个，那么把它们组合成不同的集合，可能的集合总数是2的n次方个。针对我们示例的NFA，它有13个状态，所以最坏的情况下，形成的DFA可能有2的13次方，也就是8192个状态，会占据更多的内存空间。而且生成这个DFA本身也需要消耗一定的计算时间。</p><p>当然了，这种最坏的状态很少发生，我们示例的NFA生成DFA后，只有7个状态。</p><h2 id="课程小结" tabindex="-1"><a class="header-anchor" href="#课程小结"><span>课程小结</span></a></h2><p>本节课，我带你实现了一个正则表达式工具，或者说根据正则表达式自动做了词法分析，它们的主要原理是相同的。</p><p>首先，我们需要解析正则表达式，形成计算机内部的数据结构，然后要把这个正则表达式生成NFA。我们可以基于NFA进行字符串的匹配，或者把NFA转换成DFA，再进行字符串匹配。</p><p>NFA和DFA有各自的优缺点：NFA通常状态数量比较少，可以直接用来进行计算，但可能会涉及回溯，从而性能低下；DFA的状态数量可能很大，占用更多的空间，并且生成DFA本身也需要消耗计算资源。所以，我们根据实际需求选择采用NFA还是DFA就可以了。</p><p>不过，一般来说，正则表达式工具可以直接基于NFA。而词法分析器（如Lex），则是基于DFA。原因很简单，因为在生成词法分析工具时，只需要计算一次DFA，就可以基于这个DFA做很多次词法分析。</p><h2 id="一课一思" tabindex="-1"><a class="header-anchor" href="#一课一思"><span>一课一思</span></a></h2><p>本节课我们实现了一个简单的正则表达式工具。在你的日常编程任务中，有哪些需要进行正则处理的需求？用传统的正则表达式工具有没有性能问题？你有没有办法用本节课讲到的原理来优化这些工作？欢迎在留言区分享你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>本节课的示例代码我放在了文末，供你参考。</p><ul><li>lab/16-18（算法篇的示例代码）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/tree/master/lab/16-18" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/tree/master/lab/16-18" target="_blank" rel="noopener noreferrer">GitHub</a></li><li>Regex.java（正则表达式有关的算法）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Regex.java" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Regex.java" target="_blank" rel="noopener noreferrer">GitHub</a></li><li>Lexer.java（基于正则文法自动做词法解析）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Lexer.java" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/Lexer.java" target="_blank" rel="noopener noreferrer">GitHub</a></li><li>GrammarNode.java（用于表达正则文法）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/GrammarNode.java" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/GrammarNode.java" target="_blank" rel="noopener noreferrer">GitHub</a></li><li>State.java（自动机的状态）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/State.java" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/State.java" target="_blank" rel="noopener noreferrer">GitHub</a></li><li>DFAState.java（DFA的状态）：<a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/DFAState.java" target="_blank" rel="noopener noreferrer">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/DFAState.java" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul>`,111)]))}const d=a(p,[["render",l]]),m=JSON.parse('{"path":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%20%C2%B7%20%E7%AE%97%E6%B3%95%E7%AF%87/16%20_%20NFA%E5%92%8CDFA%EF%BC%9A%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7%EF%BC%9F.html","title":"","lang":"zh-CN","frontmatter":{"description":"回顾之前讲的内容，原理篇重在建立直观理解，帮你建立信心，这是第一轮的认知迭代。应用篇帮你涉足应用领域，在解决领域问题时发挥编译技术的威力，积累运用编译技术的一手经验，也启发你用编译技术去解决更多的领域问题，这是第二轮的认知迭代。而为时三节课的算法篇将你是第三轮的认知迭代。 在第三轮的认知迭代中，我会带你掌握前端技术中的核心算法。而本节课，我就借“怎样实...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%20%C2%B7%20%E7%AE%97%E6%B3%95%E7%AF%87/16%20_%20NFA%E5%92%8CDFA%EF%BC%9A%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:description","content":"回顾之前讲的内容，原理篇重在建立直观理解，帮你建立信心，这是第一轮的认知迭代。应用篇帮你涉足应用领域，在解决领域问题时发挥编译技术的威力，积累运用编译技术的一手经验，也启发你用编译技术去解决更多的领域问题，这是第二轮的认知迭代。而为时三节课的算法篇将你是第三轮的认知迭代。 在第三轮的认知迭代中，我会带你掌握前端技术中的核心算法。而本节课，我就借“怎样实..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:00:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:00:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:00:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743411611000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":16.06,"words":4819},"filePathRelative":"posts/编译原理之美/实现一门脚本语言 · 算法篇/16 _ NFA和DFA：如何自己实现一个正则表达式工具？.md","localizedDate":"2025年3月31日","excerpt":"<p><audio id=\\"audio\\" title=\\"16 | NFA和DFA：如何自己实现一个正则表达式工具？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/c6/e9/c693a53e2eccfedc3359aef4538907e9.mp3\\"></audio></p>\\n<p>回顾之前讲的内容，原理篇重在建立直观理解，帮你建立信心，这是第一轮的认知迭代。应用篇帮你涉足应用领域，在解决领域问题时发挥编译技术的威力，积累运用编译技术的一手经验，也启发你用编译技术去解决更多的领域问题，这是第二轮的认知迭代。而为时三节课的算法篇将你是第三轮的认知迭代。</p>","autoDesc":true}');export{d as comp,m as data};

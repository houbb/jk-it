import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as e,b as a,d as s,o as l}from"./app-CrA-f6So.js";const t={};function d(r,n){return l(),p("div",null,n[0]||(n[0]=[e(`<h1 id="_10-应用3-如何在语言中用正则让文本处理能力上一个台阶" tabindex="-1"><a class="header-anchor" href="#_10-应用3-如何在语言中用正则让文本处理能力上一个台阶"><span>10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？</span></a></h1><p><audio id="audio" title="10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/f3/22/f3f806df5c8485f50dcf89bf91598022.mp3"></audio></p><p>你好，我是伟忠。今天要和你分享的内容是如何在编程语言中使用正则，让文本处理能力上一个台阶。</p><p>现代主流的编程语言几乎都内置了正则模块，很少能见到不支持正则的编程语言。学会在编程语言中使用正则，可以极大地提高文本的处理能力。</p><p>在进行文本处理时，正则解决的问题大概可以分成四类，分别是校验文本内容、提取文本内容、替换文本内容、切割文本内容。在这一节里，我会从功能分类出发，给你讲解在一些常见的编程语言中，如何正确地实现这些功能。</p><h2 id="_1-校验文本内容" tabindex="-1"><a class="header-anchor" href="#_1-校验文本内容"><span>1.校验文本内容</span></a></h2><p>我们先来看一下数据验证，通常我们在网页上输入的手机号、邮箱、日期等，都需要校验。校验的特点在于，整个文本的内容要符合正则，比如要求输入6位数字的时候，输入123456abc 就是不符合要求的。</p><p>下面我们以验证日期格式年月日为例子来讲解，比如2020-01-01，我们使用正则\\d{4}-\\d{2}-\\d{2} 来验证。</p><h3 id="python" tabindex="-1"><a class="header-anchor" href="#python"><span>Python</span></a></h3><p>在 Python 中，正则的包名是 re，验证文本可以使用 re.match 或 re.search 的方法，这两个方法的区别在于，re.match 是从开头匹配的，re.search是从文本中找子串。下面是详细的解释：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 测试环境 Python3</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; re.match(r&#39;\\d{4}-\\d{2}-\\d{2}&#39;, &#39;2020-06-01&#39;)</span></span>
<span class="line"><span>&amp;lt;re.Match object; span=(0, 10), match=&#39;2020-06-01&#39;&amp;gt;</span></span>
<span class="line"><span># 这个输出是匹配到了，范围是从下标0到下标10，匹配结果是2020-06-01</span></span>
<span class="line"><span># re.search 输出结果也是类似的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在Python中，校验文本是否匹配的正确方式<strong><strong>如下所示</strong></strong>：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 测试环境 Python3</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;\\A\\d{4}-\\d{2}-\\d{2}\\Z&#39;)  # 建议先编译，提高效率</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.search(&#39;2020-06-01&#39;) is not None</span></span>
<span class="line"><span>True</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.match(&#39;2020-06-01&#39;) is not None  # 使用match时\\A可省略</span></span>
<span class="line"><span>True</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不添加 \\A 和 \\Z 的话，我们就可能得到错误的结果。而造成这个错误的主要原因就是，没有完全匹配，而是部分匹配。至于为什么不推荐用<code>^</code>和<code>$</code>，因为在多行模式下，它们的匹配行为会发现变化，相关内容在前面匹配模式中讲解过，要是忘记了你可以返回去回顾一下。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 错误示范</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; re.match(r&#39;\\d{4}-\\d{2}-\\d{2}&#39;, &#39;2020-06-01abc&#39;) is not None</span></span>
<span class="line"><span>True</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; re.search(r&#39;\\d{4}-\\d{2}-\\d{2}&#39;, &#39;abc2020-06-01&#39;) is not None</span></span>
<span class="line"><span>True</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="go" tabindex="-1"><a class="header-anchor" href="#go"><span>Go</span></a></h3><p>Go语言（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。在Go语言中，正则相关的包是 regexp，下面是一个完整可运行的示例。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package main</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import (</span></span>
<span class="line"><span>   &amp;quot;fmt&amp;quot;</span></span>
<span class="line"><span>   &amp;quot;regexp&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>   re := regexp.MustCompile(\`\\A\\d{4}-\\d{2}-\\d{2}\\z\`)</span></span>
<span class="line"><span>   // 输出 true</span></span>
<span class="line"><span>   fmt.Println(re.MatchString(&amp;quot;2020-06-01&amp;quot;))</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存成 main.go ，在配置好go环境的前提下，直接使用命令 go run main.go 运行。不方便本地搭建Go环境的同学，可以点击 <a href="https://play.golang.org/p/bTQJe0mT839" target="_blank" rel="noopener noreferrer">这里</a> 或 <a href="https://repl.it/@twz915/learn-regex#%E6%A0%A1%E9%AA%8C/date.go" target="_blank" rel="noopener noreferrer">这里</a> 进行在线运行测试。</p><p>另外，需要注意的是，和 Python 语言不同，在 Go 语言中，正则尾部断言使用的是 \\z，而不是 \\Z。</p><h3 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h3><p>在JavaScript中没有 \\A 和 \\z，我们可以使用<code>^</code>和<code>$</code>来表示每行的开头和结尾，默认情况下它们是匹配整个文本的开头或结尾（默认不是多行匹配模式）。在 JavaScript 中校验文本的时候，不要使用多行匹配模式，因为使用多行模式会改变<code>^</code>和<code>$</code>的匹配行为。</p><p>JavaScript代码可以直接在浏览器的Console中很方便地测试。（进入方式：任意网页上点击鼠标右键，检查，Console）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 方法1</span></span>
<span class="line"><span>/^\\d{4}-\\d{2}-\\d{2}$/.test(&amp;quot;2020-06-01&amp;quot;)  // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 方法2</span></span>
<span class="line"><span>var regex = /^\\d{4}-\\d{2}-\\d{2}$/</span></span>
<span class="line"><span>&amp;quot;2020-06-01&amp;quot;.search(regex) == 0  // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 方法3</span></span>
<span class="line"><span>var regex = new RegExp(/^\\d{4}-\\d{2}-\\d{2}$/)</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01&amp;quot;) // tru</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法3本质上和方法1是一样的，方法1写起来更简洁。需要注意的是，在使用 RegExp 对象时，如果使用 g 模式，可能会有意想不到的结果，连续调用会出现第二次返回 false 的情况，就像下面这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var r = new RegExp(/^\\d{4}-\\d{2}-\\d{2}$/, &amp;quot;g&amp;quot;)</span></span>
<span class="line"><span>r.test(&amp;quot;2020-01-01&amp;quot;) // true</span></span>
<span class="line"><span>r.test(&amp;quot;2020-01-01&amp;quot;) // false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为 RegExp 在全局模式下，正则会找出文本中的所有可能的匹配，找到一个匹配时会记下 lastIndex，在下次再查找时找不到，lastIndex变为0，所以才有上面现象。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var regex = new RegExp(/^\\d{4}-\\d{2}-\\d{2}$/, &amp;quot;g&amp;quot;)</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01&amp;quot;) // true</span></span>
<span class="line"><span>regex.lastIndex // 10</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01&amp;quot;) // false</span></span>
<span class="line"><span>regex.lastIndex // 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 为了加深理解，你可以看下面这个例子</span></span>
<span class="line"><span>var regex = new RegExp(/\\d{4}-\\d{2}-\\d{2}/, &amp;quot;g&amp;quot;)</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01 2020-02-02&amp;quot;) // true</span></span>
<span class="line"><span>regex.lastIndex // 10</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01 2020-02-02&amp;quot;) // true</span></span>
<span class="line"><span>regex.lastIndex // 21</span></span>
<span class="line"><span>regex.test(&amp;quot;2020-01-01 2020-02-02&amp;quot;) // false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于我们这里是文本校验，并不需要找出所有的。所以要记住，JavaScript中文本校验在使用 RegExp 时不要设置 g 模式。</p><p>另外在ES6中添加了匹配模式 u，如果要在 JavaScript 中匹配中文等多字节的 Unicode 字符，可以指定匹配模式 u，比如测试是否为一个字符，可以是任意Unicode字符，详情可以参考下面的示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/^\\u{1D306}$/u.test(&amp;quot;𝌆&amp;quot;) // true</span></span>
<span class="line"><span>/^\\u{1D306}$/.test(&amp;quot;𝌆&amp;quot;) // false</span></span>
<span class="line"><span>/^.$/u.test(&amp;quot;好&amp;quot;) // true</span></span>
<span class="line"><span>/^.$/u.test(&amp;quot;好人&amp;quot;) // false</span></span>
<span class="line"><span>/^.$/u.test(&amp;quot;a&amp;quot;) // true</span></span>
<span class="line"><span>/^.$/u.test(&amp;quot;ab&amp;quot;) // false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h3><p>在 Java 中，正则相关的类在 java.util.regex 中，其中最常用的是 Pattern 和 Matcher， Pattern 是正则表达式对象，Matcher是匹配到的结果对象，Pattern 和 字符串对象关联，可以得到一个 Matcher。下面是 Java 中匹配的示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import java.util.regex.Matcher;</span></span>
<span class="line"><span>import java.util.regex.Pattern;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Main {</span></span>
<span class="line"><span>  public static void main(String[] args) {</span></span>
<span class="line"><span>    //方法1，可以不加 \\A 和 \\z</span></span>
<span class="line"><span>    System.out.println(Pattern.matches(&amp;quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&amp;quot;, &amp;quot;2020-06-01&amp;quot;)); // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //方法2，可以不加 \\A 和 \\z</span></span>
<span class="line"><span>    System.out.println(&amp;quot;2020-06-01&amp;quot;.matches(&amp;quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&amp;quot;)); // true</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    //方法3，必须加上 \\A 和 \\z</span></span>
<span class="line"><span>    Pattern pattern = Pattern.compile(&amp;quot;\\\\A\\\\d{4}-\\\\d{2}-\\\\d{2}\\\\z&amp;quot;);</span></span>
<span class="line"><span>    System.out.println(pattern.matcher(&amp;quot;2020-06-01&amp;quot;).find()); // true</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 中目前还没有原生字符串，在之前转义一节讲过，正则需要经过字符串转义和正则转义两个步骤，因此在用到反斜扛的地方，比如表示数字的<code>\\d</code>，就得在字符串中表示成<code>\\\\d</code>，转义会让书写正则变得稍微麻烦一些，在使用的时候需要留意一下。</p><p>部分常见编程语言校验文本方式，你可以参考下面的表。</p><img src="https://static001.geekbang.org/resource/image/e9/13/e97814862f1943b59cf341728f789813.jpg" alt=""><h2 id="_2-提取文本内容" tabindex="-1"><a class="header-anchor" href="#_2-提取文本内容"><span>2.提取文本内容</span></a></h2><p>我们再来看一下文本内容提取，所谓内容提取，就是从大段的文本中抽取出我们关心的内容。比较常见的例子是网页爬虫，或者说从页面上提取邮箱、抓取需要的内容等。如果要抓取的是某一个网站，页面样式是一样的，要提取的内容都在同一个位置，可以使用 <a href="https://lxml.de/xpathxslt.html" target="_blank" rel="noopener noreferrer">xpath</a> 或 <a href="https://pypi.org/project/pyquery/" target="_blank" rel="noopener noreferrer">jquery选择器</a> 等方式，否则就只能使用正则来做了。</p><p>下面我们来讲解一下具体的例子，让你了解一下正则提取文本在一些常见的编程语言中的使用。</p><h3 id="python-1" tabindex="-1"><a class="header-anchor" href="#python-1"><span>Python</span></a></h3><p>在 Python 中提取内容最简单的就是使用 re.findall 方法了，当有子组的时候，会返回子组的内容，没有子组时，返回整个正则匹配到的内容。下面我以查找日志的年月为例进行讲解，年月可以用正则 \\d{4}-\\d{2} 来表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 没有子组时</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;\\d{4}-\\d{2}&#39;)</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.findall(&#39;2020-05 2020-06&#39;)</span></span>
<span class="line"><span>[&#39;2020-05&#39;, &#39;2020-06&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 有子组时</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;(\\d{4})-(\\d{2})&#39;)</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.findall(&#39;2020-05 2020-06&#39;)</span></span>
<span class="line"><span>[(&#39;2020&#39;, &#39;05&#39;), (&#39;2020&#39;, &#39;06&#39;)]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的示例你可以看到，直接使用 findall 方法时，它会把结果存储到一个列表（数组）中，一下返回所有匹配到的结果。如果想节约内存，可以采用迭代器的方式来处理，就像下面这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;(\\d{4})-(\\d{2})&#39;)</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; for match in reg.finditer(&#39;2020-05 2020-06&#39;):</span></span>
<span class="line"><span>...     print(&#39;date: &#39;, match[0])  # 整个正则匹配到的内容</span></span>
<span class="line"><span>...     print(&#39;year: &#39;, match[1])  # 第一个子组</span></span>
<span class="line"><span>...     print(&#39;month:&#39;, match[2])  # 第二个子组</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>date:  2020-05</span></span>
<span class="line"><span>year:  2020</span></span>
<span class="line"><span>month: 05</span></span>
<span class="line"><span>date:  2020-06</span></span>
<span class="line"><span>year:  2020</span></span>
<span class="line"><span>month: 06</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就可以实现正则找到一个，在程序中处理一个，不需要将找到的所有结果构造成一个数组（Python中的列表）。</p><h3 id="go-1" tabindex="-1"><a class="header-anchor" href="#go-1"><span>Go</span></a></h3><p>在 Go语言里面，查找也非常简洁，可以直接使用 FindAllString 方法。如果我们想捕获子组，可以使用 FindAllStringSubmatch 方法。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package main</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import (</span></span>
<span class="line"><span>  &amp;quot;fmt&amp;quot;</span></span>
<span class="line"><span>  &amp;quot;regexp&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>  re := regexp.MustCompile(\`\\d{4}-\\d{2}\`)</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  // 返回一个切片(可动态扩容的数组) [2020-06 2020-07]</span></span>
<span class="line"><span>  fmt.Println(re.FindAllString(&amp;quot;2020-06 2020-07&amp;quot;, -1)) </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  // 捕获子组的查找示例</span></span>
<span class="line"><span>  re2 := regexp.MustCompile(\`(\\d{4})-(\\d{2})\`)</span></span>
<span class="line"><span>  // 返回结果和上面 Python 类似</span></span>
<span class="line"><span>  for _, match := range re2.FindAllStringSubmatch(&amp;quot;2020-06 2020-07&amp;quot;, -1) {</span></span>
<span class="line"><span>     fmt.Println(&amp;quot;date: &amp;quot;, match[0])</span></span>
<span class="line"><span>     fmt.Println(&amp;quot;year: &amp;quot;, match[1])</span></span>
<span class="line"><span>     fmt.Println(&amp;quot;month:&amp;quot;, match[2])</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="javascript-1" tabindex="-1"><a class="header-anchor" href="#javascript-1"><span>JavaScript</span></a></h3><p>在 JavaScript 中，想要提取文本中所有符合要求的内容，正则必须使用 g 模式，否则找到第一个结果后，正则就不会继续向后查找了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 使用g模式，查找所有符合要求的内容</span></span>
<span class="line"><span>&amp;quot;2020-06 2020-07&amp;quot;.match(/\\d{4}-\\d{2}/g)</span></span>
<span class="line"><span>// 输出：[&amp;quot;2020-06&amp;quot;, &amp;quot;2020-07&amp;quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 不使用g模式，找到第一个就会停下来</span></span>
<span class="line"><span>&amp;quot;2020-06 2020-07&amp;quot;.match(/\\d{4}-\\d{2}/)</span></span>
<span class="line"><span>// 输出：[&amp;quot;2020-06&amp;quot;, index: 0, input: &amp;quot;2020-06 2020-07&amp;quot;, groups: undefined]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要查找中文等Unicode字符，可以使用 u 匹配模式，下面是具体的示例。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&#39;𝌆&#39;.match(/\\u{1D306}/ug) // 使用匹配模式u</span></span>
<span class="line"><span>[&amp;quot;𝌆&amp;quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&#39;𝌆&#39;.match(/\\u{1D306}/g) // 不使用匹配模式u</span></span>
<span class="line"><span>null</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 如果你对这个符号感兴趣，可以参考 https://unicode-table.com/cn/1D306</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java-1" tabindex="-1"><a class="header-anchor" href="#java-1"><span>Java</span></a></h3><p>在 Java 中，可以使用 Matcher 的 find 方法来获取查找到的内容，就像下面这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import java.util.regex.Matcher;</span></span>
<span class="line"><span>import java.util.regex.Pattern;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Main {</span></span>
<span class="line"><span>  public static void main(String[] args) {    </span></span>
<span class="line"><span>    Pattern pattern = Pattern.compile(&amp;quot;\\\\d{4}-\\\\d{2}&amp;quot;);</span></span>
<span class="line"><span>    Matcher match = pattern.matcher(&amp;quot;2020-06 2020-07&amp;quot;);</span></span>
<span class="line"><span>    while (match.find()) {</span></span>
<span class="line"><span>      System.out.println(match.group());      </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>部分常见编程语言提取文本方式，你可以参考下面的表。</p><img src="https://static001.geekbang.org/resource/image/b1/c9/b14435e91df9454f6fa361b1510ff2c9.jpg" alt=""><h2 id="_3-替换文本内容" tabindex="-1"><a class="header-anchor" href="#_3-替换文本内容"><span>3.替换文本内容</span></a></h2><p>我们接着来看一下文本内容替换，替换通常用于对原来的文本内容进行一些调整。之前我们也讲解过一些使用正则进行替换的例子，今天我们再来了解一下在部分常见的编程语言中，使用正则进行文本替换的方法。</p><h3 id="python-2" tabindex="-1"><a class="header-anchor" href="#python-2"><span>Python</span></a></h3><p>在 Python 中替换相关的方法有 re.sub 和 re.subn，后者会返回替换的次数。下面我以替换年月的格式为例进行讲解，假设原始的日期格式是月日年，我们要将其处理成 xxxx年xx月xx日的格式。你可以看到，在Python中正则替换操作相关的方法，使用起来非常地简单。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;(\\d{2})-(\\d{2})-(\\d{4})&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.sub(r&#39;\\3年\\1月\\2日&#39;, &#39;02-20-2020 05-21-2020&#39;)</span></span>
<span class="line"><span>&#39;2020年02月20日 2020年05月21日&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 可以在替换中使用 \\g&amp;lt;数字&amp;gt;，如果分组多于10个时避免歧义</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.sub(r&#39;\\g&amp;lt;3&amp;gt;年\\g&amp;lt;1&amp;gt;月\\g&amp;lt;2&amp;gt;日&#39;, &#39;02-20-2020 05-21-2020&#39;)</span></span>
<span class="line"><span>&#39;2020年02月20日 2020年05月21日&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 返回替换次数</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.subn(r&#39;\\3年\\1月\\2日&#39;, &#39;02-20-2020 05-21-2020&#39;)</span></span>
<span class="line"><span>(&#39;2020年02月20日 2020年05月21日&#39;, 2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="go-2" tabindex="-1"><a class="header-anchor" href="#go-2"><span>Go</span></a></h3><p>在 Go语言里面，替换和Python也非常类似，只不过子组是使用 \${num} 的方式来表示的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package main</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import (</span></span>
<span class="line"><span>  &amp;quot;fmt&amp;quot;</span></span>
<span class="line"><span>  &amp;quot;regexp&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>  re := regexp.MustCompile(\`(\\d{2})-(\\d{2})-(\\d{4})\`)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 示例一，返回 2020年02月20日 2020年05月21日</span></span>
<span class="line"><span>  fmt.Println(re.ReplaceAllString(&amp;quot;02-20-2020 05-21-2020&amp;quot;, &amp;quot;\${3}年\${1}月\${2}日&amp;quot;))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 示例二，返回空字符串，因为&amp;quot;3年&amp;quot;，&amp;quot;1月&amp;quot;，&amp;quot;2日&amp;quot; 这样的子组不存在</span></span>
<span class="line"><span>  fmt.Println(re.ReplaceAllString(&amp;quot;02-20-2020 05-21-2020&amp;quot;, &amp;quot;$3年$1月$2日&amp;quot;))</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  // 示例三，返回 2020-02-20 2020-05-21</span></span>
<span class="line"><span>  fmt.Println(re.ReplaceAllString(&amp;quot;02-20-2020 05-21-2020&amp;quot;, &amp;quot;$3-$1-$2&amp;quot;))</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,67),a("p",null,[s("需要你注意的是，不建议把 "),a("code",{num:""},"$"),s(" 写成不带花括号的 "),a("code",null,"$"),s("num，比如示例二中的错误，会让人很困惑，Go认为子组是"),a("code",null,"“3年”，“1月”，“2日”"),s("。 由于这样的子组不存在，最终替换成了空字符串，所以使用的时候要注意这一点。")],-1),e(`<h3 id="javascript-2" tabindex="-1"><a class="header-anchor" href="#javascript-2"><span>JavaScript</span></a></h3><p>在 JavaScript 中替换和查找类似，需要指定 g 模式，否则只会替换第一个，就像下面这样。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 使用g模式，替换所有的</span></span>
<span class="line"><span>&amp;quot;02-20-2020 05-21-2020&amp;quot;.replace(/(\\d{2})-(\\d{2})-(\\d{4})/g, &amp;quot;$3年$1月$2日&amp;quot;)</span></span>
<span class="line"><span>// 输出 &amp;quot;2020年02月20日 2020年05月21日&amp;quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 不使用 g 模式时，只替换一次</span></span>
<span class="line"><span>&amp;quot;02-20-2020 05-21-2020&amp;quot;.replace(/(\\d{2})-(\\d{2})-(\\d{4})/, &amp;quot;$3年$1月$2日&amp;quot;)</span></span>
<span class="line"><span>// 输出 &amp;quot;2020年02月20日 05-21-2020&amp;quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java-2" tabindex="-1"><a class="header-anchor" href="#java-2"><span>Java</span></a></h3><p>在 Java 中，一般是使用 replaceAll 方法进行替换，一次性替换所有的匹配到的文本。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import java.util.regex.Matcher;</span></span>
<span class="line"><span>import java.util.regex.Pattern;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Main {</span></span>
<span class="line"><span>  public static void main(String[] args) {</span></span>
<span class="line"><span>    //方法1，输出 2020年02月20日 2020年05月21日</span></span>
<span class="line"><span>    System.out.println(&amp;quot;02-20-2020 05-21-2020&amp;quot;.replaceAll(&amp;quot;(\\\\d{2})-(\\\\d{2})-(\\\\d{4})&amp;quot;, &amp;quot;$3年$1月$2日&amp;quot;));</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    //方法2，输出 2020年02月20日 2020年05月21日</span></span>
<span class="line"><span>    final Pattern pattern = Pattern.compile(&amp;quot;(\\\\d{2})-(\\\\d{2})-(\\\\d{4})&amp;quot;);</span></span>
<span class="line"><span>    Matcher match = pattern.matcher(&amp;quot;02-20-2020 05-21-2020&amp;quot;);</span></span>
<span class="line"><span>    System.out.println(match.replaceAll(&amp;quot;$3年$1月$2日&amp;quot;));</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>部分常见编程语言替换文本方式，你可以参考下面的表。</p><img src="https://static001.geekbang.org/resource/image/98/yy/98603bb41c59dac186bab6dc12a494yy.jpg" alt=""><h2 id="_4-切割文本内容" tabindex="-1"><a class="header-anchor" href="#_4-切割文本内容"><span>4.切割文本内容</span></a></h2><p>我们最后再来看一下文本内容切割，通常切割用于变长的空白符号，多变的标点符号等。</p><p>下面我们来讲解一下具体的例子，让你了解一下正则切割文本在部分常见编程语言中的使用。</p><h3 id="python-3" tabindex="-1"><a class="header-anchor" href="#python-3"><span>Python</span></a></h3><p>在 Python 中切割相关的方法是 re.split。如果我们有按照任意空白符切割的需求，可以直接使用字符串的 split 方法，不传任何参数时就是按任意连续一到多个空白符切割。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 使用字符串的切割方法</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; &amp;quot;a b  c\\n\\nd\\t\\n \\te&amp;quot;.split()</span></span>
<span class="line"><span>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用正则进行切割，比如我们要通过标点符号切割，得到所有的单词（这里简单使用非单词组成字符来表示）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;gt;&amp;gt;&amp;gt; import re</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg = re.compile(r&#39;\\W+&#39;)</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.split(&amp;quot;apple, pear! orange; tea&amp;quot;)</span></span>
<span class="line"><span>[&#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;tea&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 限制切割次数，比如切一刀，变成两部分</span></span>
<span class="line"><span>&amp;gt;&amp;gt;&amp;gt; reg.split(&amp;quot;apple, pear! orange; tea&amp;quot;, 1)</span></span>
<span class="line"><span>[&#39;apple&#39;, &#39;pear! orange; tea&#39;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="go-3" tabindex="-1"><a class="header-anchor" href="#go-3"><span>Go</span></a></h3><p>在 Go语言里面，切割是 Split 方法，和 Python 非常地类似，只不过Go语言中这个方法的第二个参数是必传的，如果不限制次数，我们传入 -1 即可。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package main</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import (</span></span>
<span class="line"><span>  &amp;quot;fmt&amp;quot;</span></span>
<span class="line"><span>  &amp;quot;regexp&amp;quot;</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>  re := regexp.MustCompile(\`\\W+\`)</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>  // 返回 []string{&amp;quot;apple&amp;quot;, &amp;quot;pear&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;tea&amp;quot;}</span></span>
<span class="line"><span>  fmt.Printf(&amp;quot;%#v&amp;quot;, re.Split(&amp;quot;apple, pear! orange; tea&amp;quot;, -1)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但在Go语言中，有个地方和 Python 不太一样，就是传入的第二个参数代表切割成几个部分，而不是切割几刀。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 返回 []string{&amp;quot;apple&amp;quot;, &amp;quot;pear! orange; tea&amp;quot;}</span></span>
<span class="line"><span>fmt.Printf(&amp;quot;%#v\\n&amp;quot;, re.Split(&amp;quot;apple, pear! orange; tea&amp;quot;, 2))</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 返回 []string{&amp;quot;apple&amp;quot;}</span></span>
<span class="line"><span>fmt.Printf(&amp;quot;%#v\\n&amp;quot;, re.Split(&amp;quot;apple&amp;quot;, 2))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有一个<a href="https://play.golang.org/p/4VsBKxxXzYp" target="_blank" rel="noopener noreferrer">在线测试链接</a>，你可以尝试一下。</p><h3 id="javascript-3" tabindex="-1"><a class="header-anchor" href="#javascript-3"><span>JavaScript</span></a></h3><p>在 JavaScript 中，正则的切割和刚刚讲过的 Python 和 Go 有些类似，但又有区别。当第二个参数是2的时候，表示切割成2个部分，而不是切2刀（Go和Java也是类似的），但数组的内容不是 apple 后面的剩余部分，而是全部切割之后的 pear，你可以注意比较一下。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;quot;apple, pear! orange; tea&amp;quot;.split(/\\W+/)</span></span>
<span class="line"><span>// 输出：[&amp;quot;apple&amp;quot;, &amp;quot;pear&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;tea&amp;quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 传入第二个参数的情况</span></span>
<span class="line"><span>&amp;quot;apple, pear! orange; tea&amp;quot;.split(/\\W+/, 1)</span></span>
<span class="line"><span>// 输出 [&amp;quot;apple&amp;quot;]</span></span>
<span class="line"><span>&amp;quot;apple, pear! orange; tea&amp;quot;.split(/\\W+/, 2)</span></span>
<span class="line"><span>// 输出 [&amp;quot;apple&amp;quot;, &amp;quot;pear&amp;quot;]</span></span>
<span class="line"><span>&amp;quot;apple, pear! orange; tea&amp;quot;.split(/\\W+/, 10)</span></span>
<span class="line"><span>// 输出 [&amp;quot;apple&amp;quot;, &amp;quot;pear&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;tea&amp;quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java-3" tabindex="-1"><a class="header-anchor" href="#java-3"><span>Java</span></a></h3><p>Java中切割也是类似的，由于没有原生字符串，转义稍微麻烦点。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import java.util.regex.Matcher;</span></span>
<span class="line"><span>import java.util.regex.Pattern;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Main {</span></span>
<span class="line"><span>  public static void main(String[] args) {</span></span>
<span class="line"><span>    Pattern pattern = Pattern.compile(&amp;quot;\\\\W+&amp;quot;);</span></span>
<span class="line"><span>    for(String s : pattern.split(&amp;quot;apple, pear! orange; tea&amp;quot;)) {</span></span>
<span class="line"><span>      System.out.println(s);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 中，也可以传入第二个参数，类似于 Go 的结果。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>pattern.split(&amp;quot;apple, pear! orange; tea&amp;quot;, 2)</span></span>
<span class="line"><span>// 返回 &amp;quot;apple&amp;quot; 和 &amp;quot;pear! orange; tea&amp;quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>部分常见编程语言切割文本方式，你可以参考下面的表。</p><img src="https://static001.geekbang.org/resource/image/67/56/6708a65e269e645abb9c6ca85b5a4b56.jpg" alt=""><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，今天的内容讲完了，我来带你总结回顾一下。</p><p>今天我们学习了正则解决的问题大概可以分成四类，分别是校验文本内容、提取文本内容、替换文本内容、切割文本内容。从这四个功能出发，我们学习了在一些常见的编程语言中，如何正确地使用相应的方法来实现这些功能。这些方法都比较详细，希望你能够认真练习，掌握好这些方法。</p><p>我给你总结了一个今天所讲内容的详细脑图，你可以长按保存下来，经常回顾一下：</p><img src="https://static001.geekbang.org/resource/image/f1/25/f1d925e4795e1310886aaf82caf42325.png" alt=""><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考"><span>课后思考</span></a></h2><p>最后，我们来做一个小练习吧。很多网页为了防止爬虫，喜欢把邮箱里面的 @ 符号替换成 # 符号，你可以写一个正则，兼容一下这种情况么？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>例如网页的底部可能是这样的：</span></span>
<span class="line"><span>联系邮箱：xxx#163.com (请把#换成@)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以试试自己动手，使用你熟悉的编程语言，测试一下你写的正则能不能提取出这种“防爬”的邮箱。</p><p>好，今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，并把文章分享给你的朋友或者同事，一起交流一下。</p>`,42)]))}const u=i(t,[["render",d]]),o=JSON.parse('{"path":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/%E5%BA%94%E7%94%A8%E7%AF%87/10%20_%20%E5%BA%94%E7%94%A83%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%94%A8%E6%AD%A3%E5%88%99%E8%AE%A9%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%8F%B0%E9%98%B6%EF%BC%9F.html","title":"10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？","lang":"zh-CN","frontmatter":{"description":"10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？ 你好，我是伟忠。今天要和你分享的内容是如何在编程语言中使用正则，让文本处理能力上一个台阶。 现代主流的编程语言几乎都内置了正则模块，很少能见到不支持正则的编程语言。学会在编程语言中使用正则，可以极大地提高文本的处理能力。 在进行文本处理时，正则解决的问题大概可以分成四类，分别是校验文本内容...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/jk-it/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%E8%AF%BE/%E5%BA%94%E7%94%A8%E7%AF%87/10%20_%20%E5%BA%94%E7%94%A83%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%94%A8%E6%AD%A3%E5%88%99%E8%AE%A9%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%8F%B0%E9%98%B6%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？"}],["meta",{"property":"og:description","content":"10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？ 你好，我是伟忠。今天要和你分享的内容是如何在编程语言中使用正则，让文本处理能力上一个台阶。 现代主流的编程语言几乎都内置了正则模块，很少能见到不支持正则的编程语言。学会在编程语言中使用正则，可以极大地提高文本的处理能力。 在进行文本处理时，正则解决的问题大概可以分成四类，分别是校验文本内容..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T09:30:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T09:30:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-31T09:30:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743411611000,"updatedTime":1743413423000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":16.29,"words":4888},"filePathRelative":"posts/正则表达式入门课/应用篇/10 _ 应用3：如何在语言中用正则让文本处理能力上一个台阶？.md","localizedDate":"2025年3月31日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/f3/22/f3f806df5c8485f50dcf89bf91598022.mp3\\"></audio></p>\\n<p>你好，我是伟忠。今天要和你分享的内容是如何在编程语言中使用正则，让文本处理能力上一个台阶。</p>\\n<p>现代主流的编程语言几乎都内置了正则模块，很少能见到不支持正则的编程语言。学会在编程语言中使用正则，可以极大地提高文本的处理能力。</p>","autoDesc":true}');export{u as comp,o as data};
